{"prompt": "def twoSum(self, nums: List[int], target: int) -> List[int]:\n        \n        d = {}\n        for i, j in enumerate(nums):\n            r = target - j\n            if r in d: return [d[r], i]\n            d[j] = i\n\t\t\n\t\t# An Upvote will be encouraging"}
{"prompt": "def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        res = dummy = ListNode()\n        carry = 0\n        while l1 or l2:\n            v1, v2 = 0, 0\n            if l1: v1, l1 = l1.val, l1.next\n            if l2: v2, l2 = l2.val, l2.next\n            \n            val = carry + v1 + v2\n            res.next = ListNode(val%10)\n            res, carry = res.next, val//10\n            \n        if carry:\n            res.next = ListNode(carry)\n            \n        return dummy.next"}
{"prompt": "def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int abcabcbb\n        \"\"\"\n        if len(s) == 0:\n            return 0\n        seen = {}\n        left, right = 0, 0\n        longest = 1\n        while right < len(s):\n            if s[right] in seen:\n                left = max(left,seen[s[right]]+1)\n            longest = max(longest, right - left + 1)\n            seen[s[right]] = right\n            right += 1\n            print(left, right, longest)\n        return longest"}
{"prompt": "def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n\t    # Get the lengths of both lists\n        l1,l2 = len(nums1), len(nums2)\n\t\t# Determine the middle\n        middle = (l1 + l2) / 2\n\t\t\n\t\t# EDGE CASE:\n\t\t# If we only have 1 value (e.g. [1], []), return nums1[0] if the length of\n\t\t# that list is greater than the length of l2, otherwise return nums2[1]\n\t\tif middle == 0.5: return float(nums1[0]) if l1 > l2 else float(nums2[0])\n\n\t\t# Initialize 2 pointers\n        x =  y = 0\n\t\t# Initialize 2 values to store the previous and current value (in case of an even\n\t\t# amount of values, we need to average 2 values)\n        cur = prev = 0\n\t\t# Determine the amount of loops we need. If the middle is even, loop that amount + 1:\n\t\t# eg: [1, 2, 3, 4, 5, 6]        6 values, middle = 3, loops = 3+1\n\t\t#            ^  ^ \n\t\t#            |  +-- cur\n\t\t#            +----- prev\n \t\t# If the middle is odd, loop that amount + 0.5\n\t\t# eg: [1, 2, 3, 4, 5]           5 values, middle = 2.5, loops = 2.5+0.5\n\t\t#            ^\n        #            +--- cur\n        loops = middle+1 if middle % 1 == 0 else middle+0.5\n\n\t\t# Walk forward the amount of loops\n        for _ in range(int(loops)):\n            # Store the value of cur in prev\n\t\t\tprev = cur\n\t\t\t# If the x pointer is equal to the amount of elements of nums1 (l1 == len(nums1))\n            if x == l1:\n\t\t\t    # Store nums2[y] in cur, 'cause we hit the end of nums1\n                cur =  nums2[y]\n\t\t\t\t# Move the y pointer one ahead\n                y += 1\n\t\t    # If the y pointer is equal to the amount of elements of nums2 (l2 == len(nums2))\n            elif y == l2:\n\t\t\t    # Store nums1[x] in cur, 'cause we hit the end of nums2\n                cur =  nums1[x]\n\t\t\t\t# Move the x pointer one ahead\n                x += 1\n\t\t    # If the value in nums1 is bigger than the value in nums2\n            elif nums1[x] > nums2[y]:\n\t\t\t    # Store nums2[y] in cur, because it's the lowest value\n                cur =  nums2[y]\n\t\t\t\t# Move the y pointer one ahead\n                y += 1\n\t\t\t# If the value in nums2 is bigger than the value in nums1\n            else:\n\t\t\t\t# Store nums1[x] in, because it's the lowest value\n                cur =  nums1[x]\n\t\t\t\t# Move the x pointer one ahead\n                x += 1\n        \n\t\t# If middle is even\n        if middle % 1 == 0.0:\n\t\t\t# Return the average of the cur + prev values (which will return a float)\n            return (cur+prev)/2\n\t\t# If middle is odd\n        else:\n\t\t\t# Return the cur value, as a float\n            return float(cur)"}
{"prompt": "def longestPalindrome(self, s: str) -> str:\n        n=len(s)\n        def expand_pallindrome(i,j):            \n            while 0<=i<=j<n and s[i]==s[j]:\n                i-=1\n                j+=1                            \n            return (i+1, j)\n        \n        res=(0,0)\n        for i in range(n):\n            b1 = expand_pallindrome(i,i)\n            b2 = expand_pallindrome(i,i+1)            \n            res=max(res, b1, b2,key=lambda x: x[1]-x[0]+1) # find max based on the length of the pallindrome strings.\n                    \n        return s[res[0]:res[1]]"}
{"prompt": "def convert(self, s: str, numRows: int) -> str:\n        if numRows == 1:\n            return s\n            \n        row_arr = [\"\"] * numRows\n        row_idx = 1\n        going_up = True\n\n        for ch in s:\n            row_arr[row_idx-1] += ch\n            if row_idx == numRows:\n                going_up = False\n            elif row_idx == 1:\n                going_up = True\n            \n            if going_up:\n                row_idx += 1\n            else:\n                row_idx -= 1\n        \n        return \"\".join(row_arr)"}
{"prompt": "def reverse(self, x: int) -> int:\n        retval = int(str(abs(x))[::-1])\n        \n        if(retval.bit_length()>31):\n            return 0\n    \n        if x<0:\n            return -1*retval\n        else:\n            return retval"}
{"prompt": "def myAtoi(self, s: str) -> int:\n     \n        if not s:\n            return 0\n        sign = 1\n        integer = 0\n        i = 0\n        while i < len(s) and s[i] == ' ':\n            i+=1    #skipping leading white space\n        if i < len(s) and (s[i] == '-' or s[i] == '+'):\n            if s[i] == '-':\n                sign = -1\n            i+=1\n        while(i < len(s) and s[i].isdigit()):\n            integer = integer * 10 + int(s[i])\n            i+=1\n            \n        integer = sign*integer\n        ans = self.limit(integer)\n        return ans\n    \n    def limit(self, num):\n        if num > pow(2, 31) -1:\n            return pow(2, 31) -1\n        if num < -1*pow(2, 31):\n            return -1*pow(2, 31)\n        return num"}
{"prompt": "def isPalindrome(self, x: int) -> bool:\n        if x < 0:\n            return False\n        \n        res = 0\n        temp = x\n        \n        while temp:\n            temp, n = divmod(temp, 10)\n            res = (res * 10) + n\n                \n        return res == x"}
{"prompt": "def isMatch(self, s, p):\n       n = len(s)\n       m = len(p)\n       dp = [[False for _ in range (m+1)] for _ in range (n+1)]\n       dp[0][0] = True\n       for c in range(1,m+1):\n           if p[c-1] == '*' and c > 1:\n               dp[0][c] = dp[0][c-2]\n       for r in range(1,n+1):\n           for c in range(1,m+1):\n               if p[c-1] == s[r-1] or p[c-1] == '.':\n                   dp[r][c] = dp[r-1][c-1]\n               elif c > 1 and p[c-1] == '*':\n                   if  p[c-2] =='.' or s[r-1]==p[c-2]:\n                       dp[r][c] =dp[r][c-2] or dp[r-1][c]\n                   else:\n                       dp[r][c] = dp[r][c-2]\n       return dp[n][m]"}
{"prompt": "def maxArea(self, height: List[int]) -> int:\n        l, r, area = 0, len(height) - 1, 0\n        while l < r:\n            area = max(area, (r - l) * min(height[l], height[r]))\n            if height[l] < height[r]:\n\t\t\t\tl += 1\n            else:\n\t\t\t\tr -= 1\n\t\t\t\t\n        return area"}
{"prompt": "def intToRoman(self, num: int) -> str:\n        # Creating Dictionary for Lookup\n        num_map = {\n            1: \"I\",\n            5: \"V\",    4: \"IV\",\n            10: \"X\",   9: \"IX\",\n            50: \"L\",   40: \"XL\",\n            100: \"C\",  90: \"XC\",\n            500: \"D\",  400: \"CD\",\n            1000: \"M\", 900: \"CM\",\n        }\n        \n        # Result Variable\n        r = ''\n        \n        \n        for n in [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]:\n            # If n in list then add the roman value to result variable\n            while n <= num:\n                r += num_map[n]\n                num-=n\n        return r"}
{"prompt": "def romanToInt(self, s: str) -> int:\n        translations = {\n            \"I\": 1,\n            \"V\": 5,\n            \"X\": 10,\n            \"L\": 50,\n            \"C\": 100,\n            \"D\": 500,\n            \"M\": 1000\n        }\n        number = 0\n        s = s.replace(\"IV\", \"IIII\").replace(\"IX\", \"VIIII\")\n        s = s.replace(\"XL\", \"XXXX\").replace(\"XC\", \"LXXXX\")\n        s = s.replace(\"CD\", \"CCCC\").replace(\"CM\", \"DCCCC\")\n        for char in s:\n            number += translations[char]\n        return number"}
{"prompt": "def longestCommonPrefix(self, strs: List[str]) -> str:\n        \n        pre = strs[0]\n        \n        for i in strs:\n            while not i.startswith(pre):\n                pre = pre[:-1]\n        \n        return pre"}
{"prompt": "def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        levels = []\n        \n        def order(node, level):\n            if level >= len(levels):\n                levels.append([])\n            \n            if node:\n                levels[level].append(node.val)\n            \n                if node.left:\n                    order(node.left, level + 1)\n                \n                if node.right:\n                    order(node.right, level + 1)\n        \n        if not root:\n            return []\n        \n        order(root, 0)\n        return levels"}
{"prompt": "def zigzagLevelOrder(self, root):\n        \n        res = []\n        if not root: return res\n        zigzag = True\n        \n        q = collections.deque()\n        q.append(root)\n        \n        while q:\n            n = len(q)\n            nodesOfThisLevel = []\n            \n            for i in range(n):\n                node = q.popleft()\n                nodesOfThisLevel.append(node.val)\n                \n                if node.left: q.append(node.left)\n                if node.right: q.append(node.right)\n                    \n            if zigzag:\n                res.append(nodesOfThisLevel)\n                zigzag = False\n            else:\n                res.append(nodesOfThisLevel[::-1])\n                zigzag = True\n        \n        return res\n    \n# Time: O(N)\n# Space: O(N)"}
{"prompt": "def maxDepth(self, root: Optional[TreeNode]) -> int:\n        def dfs(root, depth):\n            if not root: return depth\n            return max(dfs(root.left, depth + 1), dfs(root.right, depth + 1))\n                       \n        return dfs(root, 0)"}
{"prompt": "def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\n        loc = {x : i for i, x in enumerate(inorder)}\n        root = None\n        stack = []\n        for x in preorder: \n            if not root: root = node = TreeNode(x)\n            elif loc[x] < loc[node.val]: \n                stack.append(node)\n                node.left = node = TreeNode(x)\n            else: \n                while stack and loc[stack[-1].val] < loc[x]: node = stack.pop() # backtracking\n                node.right = node = TreeNode(x)\n        return root"}
{"prompt": "def buildTree(self, inorder, postorder):\n        inorderIndexDict = {ch : i for i, ch in enumerate(inorder)}\n        self.rootIndex = len(postorder) - 1\n        \n        def solve(l, r):\n            if l > r: return None\n            \n            root = TreeNode(postorder[self.rootIndex]) \n            self.rootIndex -= 1\n            \n            i = inorderIndexDict[root.val]\n            \n            # As we a approaching from end and all right side nodes of i in inorder are\n            # from right sub-tree so first call solve for right then left.\n            root.right = solve(i+1, r)\n            root.left =  solve(l, i-1)\n            \n            return root\n        \n        return solve(0, len(inorder)-1)\n    \n    \n# Time: O(N)\n# Space: O(1)"}
{"prompt": "def helper(self, result, depth, node):\n        if not node:\n            return\n        \n        if len(result) < depth:\n            result.append([])\n            \n        result[depth-1].append(node.val)\n        self.helper(result, depth+1, node.left)\n        self.helper(result, depth+1, node.right)\n        \n    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:\n        if not root:\n            return []\n        \n        result = []\n        depth = 1\n        self.helper(result, depth, root)\n        result.reverse()\n        return result"}
{"prompt": "def sortedArrayToBST(self, nums):\n        # Base condition...\n        if len(nums) == 0:\n            return None\n        # set the middle node...\n        mid = len(nums)//2\n        # Initialise root node with value same as nums[mid]\n        root = TreeNode(nums[mid])\n        # Assign left subtrees as the same function called on left subranges...\n        root.left = self.sortedArrayToBST(nums[:mid])\n        # Assign right subtrees as the same function called on right subranges...\n        root.right = self.sortedArrayToBST(nums[mid+1:])\n        # Return the root node...\n        return root"}
{"prompt": "l = 'left'\n    r = 'right'\n    \n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head: return None\n        \n        nums = []\n        while head:\n            nums.append(head.val)\n            head = head.next\n        \n        mid = len(nums) // 2\n        treeNode = TreeNode(nums[mid])\n        \n        self.binarySearchTree(nums[:mid], self.l, treeNode)\n        self.binarySearchTree(nums[(mid + 1):], self.r, treeNode)\n        \n        return treeNode\n            \n            \n    def binarySearchTree(self, nums, direction, treeNode):\n        if len(nums) <= 0: return\n        \n        mid = len(nums) // 2\n        left, right = nums[:mid], nums[(mid + 1):]\n        \n        if direction == self.l:\n            treeNode.left = TreeNode(nums[mid])\n            self.binarySearchTree(left, self.l, treeNode.left)\n            self.binarySearchTree(right, self.r, treeNode.left)\n        else:\n            treeNode.right = TreeNode(nums[mid])\n            self.binarySearchTree(left, self.l, treeNode.right)\n            self.binarySearchTree(right, self.r, treeNode.right)"}
{"prompt": "def isBalanced(self, root):\n        return (self.Height(root) >= 0)\n    def Height(self, root):\n        if root is None:  return 0\n        leftheight, rightheight = self.Height(root.left), self.Height(root.right)\n        if leftheight < 0 or rightheight < 0 or abs(leftheight - rightheight) > 1:  return -1\n        return max(leftheight, rightheight) + 1"}
{"prompt": "def minDepth(self, root):\n        # Base case...\n        # If the subtree is empty i.e. root is NULL, return depth as 0...\n        if root is None:  return 0\n        # Initialize the depth of two subtrees...\n        leftDepth = self.minDepth(root.left)\n        rightDepth = self.minDepth(root.right)\n        # If the both subtrees are empty...\n        if root.left is None and root.right is None:\n            return 1\n        # If the left subtree is empty, return the depth of right subtree after adding 1 to it...\n        if root.left is None:\n            return 1 + rightDepth\n        # If the right subtree is empty, return the depth of left subtree after adding 1 to it...\n        if root.right is None:\n            return 1 + leftDepth\n        # When the two child function return its depth...\n        # Pick the minimum out of these two subtrees and return this value after adding 1 to it...\n        return min(leftDepth, rightDepth) + 1;    # Adding 1 is the current node which is the parent of the two subtrees..."}
{"prompt": "\"\"\"\n    Time:   O(n)\n    Memory: O(n)\n    \"\"\"\n\n    def hasPathSum(self, root: Optional[TreeNode], target: int) -> bool:\n        if root is None:\n            return False\n        if root.left is None and root.right is None:\n            return target == root.val\n        return self.hasPathSum( root.left, target - root.val) or \\\n               self.hasPathSum(root.right, target - root.val)"}
{"prompt": "def pathSum(self, R: TreeNode, S: int) -> List[List[int]]:\n        A, P = [], []\n        def dfs(N):\n            if N == None: return\n            P.append(N.val)\n            if (N.left,N.right) == (None,None) and sum(P) == S: A.append(list(P))\n            else: dfs(N.left), dfs(N.right)\n            P.pop()\n        dfs(R)\n        return A\n\t\t\n\t\t\n- Junaid Mansuri\n- Chicago, IL"}
{"prompt": "def __init__(self):\n        self.prev = None\n        \n    def flatten(self, root: Optional[TreeNode]) -> None:\n        \n        if not root: return \n        self.flatten(root.right)\n        self.flatten(root.left)\n        root.right = self.prev\n        root.left = None\n        self.prev = root"}
{"prompt": "def numDistinct(self, s: str, t: str) -> int:\n        m = len(s)\n        n = len(t)\n        dp = [[0] * (n+1) for _ in range(m+1)]\n        \n        for i in range(m+1):\n            dp[i][0] = 1\n        \n        \"\"\"redundant, as we have initialised dp table with full of zeros\"\"\"\n#         for i in range(1, n+1): \n#             dp[0][i] = 0\n        \n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                dp[i][j] += dp[i-1][j] \t\t\t#if current character is skipped\n                if s[i-1] == t[j-1]:\n                    dp[i][j] += dp[i-1][j-1]\t#if current character is used\n        \n        return dp[-1][-1]"}
{"prompt": "def connect(self, root: 'Node') -> 'Node':\n        # edge case check\n        if not root:\n            return None\n        \n        # initialize the queue with root node (for level order traversal)\n        queue = collections.deque([root])\n        \n        # start the traversal\n        while queue:\n            size = len(queue) # get number of nodes on the current level\n            for i in range(size):\n                node = queue.popleft() # pop the node\n                \n                # An important check so that we do not wire the node to the node on the next level.\n                if i < size-1:\n                    node.next = queue[0] # because the right node of the popped node would be the next in the queue. \n                    \n                if node.left:\n                    queue.append(node.left) \n                if node.right:\n                    queue.append(node.right)           \n                \n        return root"}
{"prompt": "def connect(self, root: 'Node') -> 'Node':\n        if not root:\n            return None\n        q = deque()\n        q.append(root)\n        dummy=Node(-999) # to initialize with a not null prev\n        while q:\n            length=len(q) # find level length\n            \n            prev=dummy\n            for _ in range(length): # iterate through all nodes in the same level\n                popped=q.popleft()\n                if popped.left:\n                    q.append(popped.left)\n                    prev.next=popped.left\n                    prev=prev.next\n                if popped.right:\n                    q.append(popped.right)\n                    prev.next=popped.right\n                    prev=prev.next                \n                 \n        return root"}
{"prompt": "def generate(self, numRows: int) -> List[List[int]]:\n        l=[0]*numRows\n        for i in range(numRows):\n            l[i]=[0]*(i+1)\n            l[i][0]=1\n            l[i][i]=1\n            for j in range(1,i):\n                l[i][j]=l[i-1][j-1]+l[i-1][j]\n        return l"}
{"prompt": "def getRow(self, rowIndex: int) -> List[int]:\n        \n        if rowIndex == 0:\n            # Base case\n            return [1]\n        \n        elif rowIndex == 1:\n            # Base case\n            return [1, 1]\n        \n        else:\n            # General case:\n            last_row = self.getRow( rowIndex-1 )\n            size = len(last_row)\n            return [ last_row[0] ] + [ last_row[idx] + last_row[idx+1] for idx in range( size-1) ] + [ last_row[-1] ]"}
{"prompt": "def minimumTotal(self, triangle: List[List[int]]) -> int:\n        for i in range(1, len(triangle)):  # for each row in triangle (skipping the first),\n            for j in range(i+1):           # loop through each element in the row\n                triangle[i][j] += min(triangle[i-1][j-(j==i)],  # minimum sum from coordinate (x-1, y)\n                                      triangle[i-1][j-(j>0)])   # minimum sum from coordinate (x-1, y-1)\n        return min(triangle[-1])  # obtain minimum sum from last row"}
{"prompt": "def maxProfit(self, prices):\n        n = len(prices)\n        dp = [0]*n # initializing the dp table\n        dp[0] = [prices[0],0] # filling the the first dp table --> low_price = prices[0] max_profit=0\n        min_price = max_profit = 0\n        # Note that ---> indixing the dp table --> dp[i-1][0] stores minimum price and dp[i-1][1] stores maximum profit\n        for i in range(1,n):\n            min_price = min(dp[i-1][0], prices[i]) # min(previous_min_price, cur_min_price)\n            max_profit = max(dp[i-1][1], prices[i]-dp[i-1][0]) # max(previoius_max_profit, current_profit)\n            dp[i] =[min_price,max_profit]\n                \n        return dp[n-1][1]\n\t\t#Runtime: 1220 ms, \n\t\t#Memory Usage: 32.4 MB,"}
{"prompt": "def maxProfit(self, prices: List[int]) -> int:\n        \n        @cache\n        def trade(day_d):\n            \n            if day_d == 0:\n                \n                # Hold on day_#0 = buy stock at the price of day_#0\n                # Not-hold on day_#0 = doing nothing on day_#0\n                return -prices[day_d], 0\n            \n            prev_hold, prev_not_hold = trade(day_d-1)\n            \n            hold = max(prev_hold, prev_not_hold - prices[day_d] )\n            not_hold = max(prev_not_hold, prev_hold + prices[day_d] )\n            \n            return hold, not_hold\n        \n        # --------------------------------------------------\n        last_day= len(prices)-1\n        \n        # Max profit must come from not_hold state (i.e., no stock position) on last day\n        return trade(last_day)[1]"}
{"prompt": "def maxProfit(self, prices: List[int]) -> int:\n        buy, sell = [inf]*2, [0]*2\n        for x in prices:\n            for i in range(2): \n                if i: buy[i] = min(buy[i], x - sell[i-1])\n                else: buy[i] = min(buy[i], x)\n                sell[i] = max(sell[i], x - buy[i])\n        return sell[1]"}
{"prompt": "def __init__(self):\n        self.maxSum = float('-inf')\n    def maxPathSum(self, root: TreeNode) -> int:\n        def traverse(root):\n            if root:\n                left = traverse(root.left)\n                right = traverse(root.right)\n                self.maxSum = max(self.maxSum,root.val, root.val + left, root.val + right, root.val + left + right)\n                return max(root.val,root.val + left,root.val + right)\n            else:\n                return 0\n        traverse(root)\n        return self.maxSum"}
{"prompt": "def isPalindrome(self, s: str) -> bool:\n    \ts = [i for i in s.lower() if i.isalnum()]\n    \treturn s == s[::-1]"}
{"prompt": "def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n\t\t\td = defaultdict(list)\n\t\t\tfor word in wordList:\n\t\t\t\tfor i in range(len(word)):\n\t\t\t\t\td[word[:i]+\"*\"+word[i+1:]].append(word)\n\n\t\t\tif endWord not in wordList:\n\t\t\t\treturn []\n\n\t\t\tvisited1 = defaultdict(list)\n\t\t\tq1 = deque([beginWord])\n\t\t\tvisited1[beginWord] = []\n\n\t\t\tvisited2 = defaultdict(list)\n\t\t\tq2 = deque([endWord])\n\t\t\tvisited2[endWord] = []\n\n\t\t\tans = []\n\t\t\tdef dfs(v, visited, path, paths):\n\t\t\t\tpath.append(v)\n\t\t\t\tif not visited[v]:\n\t\t\t\t\tif visited is visited1:\n\t\t\t\t\t\tpaths.append(path[::-1])\n\t\t\t\t\telse:\n\t\t\t\t\t\tpaths.append(path[:])\n\t\t\t\tfor u in visited[v]:\n\t\t\t\t\tdfs(u, visited, path, paths)\n\t\t\t\tpath.pop()\n\n\t\t\tdef bfs(q, visited1, visited2, frombegin):\n\t\t\t\tlevel_visited = defaultdict(list)\n\t\t\t\tfor _ in range(len(q)):\n\t\t\t\t\tu = q.popleft()\n\n\t\t\t\t\tfor i in range(len(u)):\n\t\t\t\t\t\tfor v in d[u[:i]+\"*\"+u[i+1:]]:\n\t\t\t\t\t\t\tif v in visited2:\n\t\t\t\t\t\t\t\tpaths1 = []\n\t\t\t\t\t\t\t\tpaths2 = []\n\t\t\t\t\t\t\t\tdfs(u, visited1, [], paths1)\n\t\t\t\t\t\t\t\tdfs(v, visited2, [], paths2)\n\t\t\t\t\t\t\t\tif not frombegin:\n\t\t\t\t\t\t\t\t\tpaths1, paths2 = paths2, paths1\n\t\t\t\t\t\t\t\tfor a in paths1:\n\t\t\t\t\t\t\t\t\tfor b in paths2:\n\t\t\t\t\t\t\t\t\t\tans.append(a+b)\n\t\t\t\t\t\t\telif v not in visited1:\n\t\t\t\t\t\t\t\tif v not in level_visited:\n\t\t\t\t\t\t\t\t\tq.append(v)\n\t\t\t\t\t\t\t\tlevel_visited[v].append(u)\n\t\t\t\tvisited1.update(level_visited)\n\n\t\t\twhile q1 and q2 and not ans:\n\t\t\t\tif len(q1) <= len(q2):\n\t\t\t\t\tbfs(q1, visited1, visited2, True)\n\t\t\t\telse:\n\t\t\t\t\tbfs(q2, visited2, visited1, False)\n\n\t\t\treturn ans"}
{"prompt": "def ladderLength(self, beginWord, endWord, wordList):\n\n        graph = defaultdict(list)\n        for word in wordList:\n            for index in range(len(beginWord)):\n                graph[word[:index] + \"_\" + word[index+1:]].append(word)\n\n        queue = deque()\n        queue.append((beginWord, 1))\n        visited = set()\n        while queue:\n            current_node, current_level = queue.popleft()\n            if current_node == endWord: return current_level\n            for index in range(len(beginWord)):\n                node = current_node[:index] + \"_\" + current_node[index+1:]\n                for neighbour in graph[node]:\n                    if neighbour not in visited:\n                        queue.append((neighbour, current_level + 1))\n                        visited.add(neighbour)\n                graph[node] = []\n                \n        return 0"}
{"prompt": "class Node:\n    def __init__(self, val):\n        self.val = val\n        self.parent = self\n        self.size = 1\n    \nclass UnionFind:\n        \n    def find(self, node):\n        if node.parent != node:\n            node.parent = self.find(node.parent)\n        return node.parent\n    \n    def union(self, node1, node2):\n        parent_1 = self.find(node1)\n        parent_2 = self.find(node2)\n        if parent_1 != parent_2:\n            parent_2.parent = parent_1\n            parent_1.size += parent_2.size\n        return parent_1.size\n                \n        \n        \ndef longestConsecutive(self, nums: List[int]) -> int:\n        uf = UnionFind()\n        nodes = {}\n        max_size = 0\n        for num in nums:\n            if num not in nodes:\n                node = Node(num)\n                nodes[num] = node\n                size = 1\n                if num + 1 in nodes:\n                    size = uf.union(node, nodes[num+1])\n                if num - 1 in nodes:\n                    size = uf.union(node, nodes[num-1])\n                max_size = max(max_size, size)\n                \n        return max_size\n\t\t```"}
{"prompt": "def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        def helper(node, num):\n            if node is None:\n                return 0\n            num = num * 10 + node.val\n            if node.left is None and node.right is None:\n                return num\n            return helper(node.left, num) + helper(node.right, num)\n        \n        return helper(root, 0)"}
{"prompt": "def dfs(self,board,i,j):\n            \n        if i<0 or j<0 or i>=len(board) or j>=len(board[0]) or board[i][j]!='O':\n            return\n        board[i][j]='$'  # converting to  a dollar sign \n            \n        self.dfs(board,i+1,j)\n        self.dfs(board,i-1,j)\n        self.dfs(board,i,j+1)\n        self.dfs(board,i,j-1)\n        \n    def solve(self, board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        if len(board)==0:\n            return None\n        \n        m=len(board)\n        n=len(board[0])\n        \n        \n        for i in range(m):  # call dfs on all border 'O's and turn them to '$'\n            for j in range(n):\n                if i==0 or i==m-1:\n                    self.dfs(board,i,j)\n                        \n                if j==0 or j==n-1:\n                    self.dfs(board,i,j)\n                    \n        \n   \n#all border O and others connected them were already converted to $ sign \n#so left out zeros are surely surrounded by 'X' . Turn all of them to 'X'\n        for i in range(m):   \n            for j in range(n):\n                if board[i][j]=='O':\n                    board[i][j]='X'\n        \n# turn the border zeros and their adjacents to their initial form. ie $ -> O \n        for i in range(m):\n            for j in range(n):\n                if board[i][j]=='$':\n                    board[i][j]='O'"}
{"prompt": "@cache  # the memory trick can save some time\n    def partition(self, s):\n        if not s: return [[]]\n        ans = []\n        for i in range(1, len(s) + 1):\n            if s[:i] == s[:i][::-1]:  # prefix is a palindrome\n                for suf in self.partition(s[i:]):  # process suffix recursively\n                    ans.append([s[:i]] + suf)\n        return ans"}
{"prompt": "def minCut(self, s: str) -> int:\n        #pre-processing\n        palin = dict()\n        for k in range(len(s)):\n            for i, j in (k, k), (k, k+1):\n                while 0 <= i and j < len(s) and s[i] == s[j]: \n                    palin.setdefault(i, []).append(j)\n                    i, j = i-1, j+1\n                \n        #dp \n        @lru_cache(None)\n        def fn(i):\n            \"\"\"Return minimum palindrome partitioning of s[i:]\"\"\"\n            if i == len(s): return 0\n            return min(1 + fn(ii+1) for ii in palin[i])\n        \n        return fn(0)-1"}
{"prompt": "def cloneGraph(self, node: 'Node') -> 'Node':\n        if not node: return node\n        \n        q, clones = deque([node]), {node.val: Node(node.val, [])}\n        while q:\n            cur = q.popleft() \n            cur_clone = clones[cur.val]            \n\n            for ngbr in cur.neighbors:\n                if ngbr.val not in clones:\n                    clones[ngbr.val] = Node(ngbr.val, [])\n                    q.append(ngbr)\n                    \n                cur_clone.neighbors.append(clones[ngbr.val])\n                \n        return clones[node.val]"}
{"prompt": "def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n\t\t\n\t\t# base case\n\t\tif sum(gas) - sum(cost) < 0:\n\t\t\treturn -1\n\n\t\tgas_tank = 0  # gas available in car till now\n\t\tstart_index = 0  # Consider first gas station as starting point\n\n\t\tfor i in range(len(gas)):\n\n\t\t\tgas_tank += gas[i] - cost[i]\n\n\t\t\tif gas_tank < 0:  # the car has deficit of petrol\n\t\t\t\tstart_index = i+1  # change the starting point\n\t\t\t\tgas_tank = 0  # make the current gas to 0, as we will be starting again from next station\n\n\t\treturn start_index"}
{"prompt": "def candy(self, ratings: List[int]) -> int:\n        n=len(ratings)\n        temp = [1]*n\n        \n        for i in range(1,n):\n            if(ratings[i]>ratings[i-1]):\n                temp[i]=temp[i-1]+1\n        if(n>1):\n            if(ratings[0]>ratings[1]):\n                temp[0]=2\n                \n            \n        for i in range(n-2,-1,-1):\n            if(ratings[i]>ratings[i+1] and temp[i]<=temp[i+1]):\n                temp[i]=temp[i+1]+1\n\n                \n        return sum(temp)"}
{"prompt": "def singleNumber(self, nums):\n        # Initialize the unique number...\n        uniqNum = 0;\n        # TRaverse all elements through the loop...\n        for idx in nums:\n            # Concept of XOR...\n            uniqNum ^= idx;\n        return uniqNum;       # Return the unique number..."}
{"prompt": "def singleNumber(self, nums):\n        a, b = 0, 0\n        for x in nums:\n            a, b = (~x&amp;a&amp;~b)|(x&amp;~a&amp;b), ~a&amp;(x^b)\n        return b"}
{"prompt": "def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        hm, zero = dict(), Node(0)\n        \n        cur, copy = head, zero\n        while cur:\n            copy.next = Node(cur.val)\n            hm[cur] = copy.next\n            cur, copy = cur.next, copy.next\n            \n        cur, copy = head, zero.next\n        while cur:\n            copy.random = hm[cur.random] if cur.random else None\n            cur, copy = cur.next, copy.next\n                \n        return zero.next"}
{"prompt": "def wordBreak(self, s, wordDict):\n\t\tdp = [False]*(len(s)+1)\n        dp[0] = True\n        \n        for i in range(1, len(s)+1):\n            for j in range(i):\n                if dp[j] and s[j:i] in wordDict:\n\t\t\t\t\tdp[i] = True\n                    break\n                    \n        return dp[-1]"}
{"prompt": "def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        def wordsEndingIn(i):\n            if i == len(s):\n                return [\"\"]\n            ans = []\n            for j in range(i+1, len(s)+1):\n                if s[i:j] in wordDict:\n                    for tail in wordsEndingIn(j):\n                        if tail != '':\n                            ans.append(s[i:j] + \" \" + tail) \n                        else:\n                            ans.append(s[i:j])\n            return ans\n        return wordsEndingIn(0)"}
{"prompt": "def hasCycle(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n\t\tif head is None or head.next is None return False\n        slow_ref = head\n        fast_ref = head\n        while fast_ref and fast_ref.next:\n            slow_ref = slow_ref.next\n            fast_ref = fast_ref.next.next\n            if slow_ref == fast_ref:\n                return True\n        return False\n\t\t\n\tIf you get it please Upvote."}
{"prompt": "def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fast, slow = head, head\n        while(fast and fast.next):\n            fast = fast.next.next\n            slow = slow.next\n            if(fast == slow):\n                slow = head\n                while(slow is not fast):\n                    fast = fast.next\n                    slow = slow.next\n                return slow\n        return None"}
{"prompt": "def reorderList(self, head: Optional[ListNode]) -> None:\n        if not head.next or not head.next.next:\n            return\n        \n        # search for the middle\n        slow, fast = head, head\n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        tail, cur = None, slow.next\n        slow.next = None # detach list on the middle\n        \n        # reverse right part\n        while cur:\n            cur.next, tail, cur = tail, cur, cur.next\n        \n\t\t# rearrange nodes as asked\n        headCur, headNext = head, head.next\n        tailCur, tailNext = tail, tail.next\n        while True:\n            headCur.next, tailCur.next = tailCur, headNext\n             \n            if not tailNext:\n                return\n            \n            tailCur, headCur = tailNext, headNext\n            tailNext, headNext = tailNext.next, headNext.next"}
{"prompt": "def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        ans = []\n        stack = [root]\n        \n        while stack:\n            temp = stack.pop()\n            \n            if temp:\n                ans.append(temp.val)\n                stack.append(temp.right) #as we are using stack which works on LIFO, we need to push right tree first so that left will be popped out\n                stack.append(temp.left)\n                \n        return ans"}
{"prompt": "def postorderTraversal(self, root):\n        # Base case...\n        if not root: return []\n        # Create an array list to store the solution result...\n        sol = []\n        # Create an empty stack and push the root node...\n        bag = [root]\n        # Loop till stack is empty...\n        while bag:\n            # Pop a node from the stack...\n            node = bag.pop()\n            sol.append(node.val)\n            # Push the left child of the popped node into the stack...\n            if node.left:\n                bag.append(node.left)\n            # Append the right child of the popped node into the stack...\n            if node.right:\n                bag.append(node.right)\n        return sol[::-1]       # Return the solution list..."}
{"prompt": "class ListNode:\n    def __init__(self, key=0, val=0, prev=None, next=None):\n        self.key = key\n        self.val = val\n        self.prev = prev\n        self.next = next\n        \n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        \"\"\"Initialize hash table &amp; dll\"\"\"\n        self.cpty = capacity\n        self.htab = dict() #hash table \n        self.head = ListNode() #doubly linked list\n        self.tail = ListNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head \n        \n    def _del(self, key: int) -> int: \n        \"\"\"Delete given key from hash table &amp; dll\"\"\"\n        node = self.htab.pop(key)\n        node.prev.next = node.next\n        node.next.prev = node.prev\n        return node.val\n\n    def _ins(self, key: int, value: int) -> None: \n        \"\"\"Insert at tail\"\"\"\n        node = ListNode(key, value, self.tail.prev, self.tail)\n        self.tail.prev.next = self.tail.prev = node\n        self.htab[key] = node\n        \n    def get(self, key: int) -> int:\n        if key not in self.htab: return -1\n        value = self._del(key)\n        self._ins(key, value)\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.htab: self._del(key)\n        self._ins(key, value)\n        if len(self.htab) > self.cpty: \n            self._del(self.head.next.key)\n\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)"}
{"prompt": "def insertionSortList(self, head: ListNode) -> ListNode:\n        \n        # No need to sort for empty list or list of size 1\n        if not head or not head.next:\n            return head\n        \n        # Use dummy_head will help us to handle insertion before head easily\n        dummy_head = ListNode(val=-5000, next=head)\n        last_sorted = head # last node of the sorted part\n        cur = head.next # cur is always the next node of last_sorted\n        while cur:\n            if cur.val >= last_sorted.val:\n                last_sorted = last_sorted.next\n            else:\n                # Search for the position to insert\n                prev = dummy_head\n                while prev.next.val <= cur.val:\n                    prev = prev.next\n                    \n                # Insert\n                last_sorted.next = cur.next\n                cur.next = prev.next\n                prev.next = cur\n                \n            cur = last_sorted.next\n            \n        return dummy_head.next"}
{"prompt": "def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        \n        # Split the list into two halfs\n        left = head\n        right = self.getMid(head)\n        tmp = right.next\n        right.next = None\n        right = tmp\n        \n        left = self.sortList(left)\n        right = self.sortList(right)\n        \n        return self.merge(left, right)\n    \n    def getMid(self, head):\n        slow = head\n        fast = head.next\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n    \n    # Merge the list\n    def merge(self, list1, list2):\n        newHead = tail = ListNode()\n        while list1 and list2:\n            if list1.val > list2.val:\n                tail.next = list2\n                list2 = list2.next\n            else:\n                tail.next = list1\n                list1 = list1.next\n            tail = tail.next\n        \n        if list1:\n            tail.next = list1\n        if list2:\n            tail.next = list2\n        \n        return newHead.next"}
{"prompt": "def maxPoints(self, points: List[List[int]]) -> int:\n        if len(points) <= 2:\n            return len(points)\n        \n        def find_slope(p1, p2):\n            x1, y1 = p1\n            x2, y2 = p2\n            if x1-x2 == 0:\n                return inf\n            return (y1-y2)/(x1-x2)\n        \n        ans = 1\n        for i, p1 in enumerate(points):\n            slopes = defaultdict(int)\n            for j, p2 in enumerate(points[i+1:]):\n                slope = find_slope(p1, p2)\n                slopes[slope] += 1\n                ans = max(slopes[slope], ans)\n        return ans+1"}
{"prompt": "def evalRPN(self, tokens: List[str]) -> int:\n        \n        def update(sign):\n            n2,n1=stack.pop(),stack.pop()\n            if sign==\"+\": return n1+n2\n            if sign==\"-\": return n1-n2\n            if sign==\"*\": return n1*n2\n            if sign==\"/\": return int(n1/n2)\n\t\t\t\n        stack=[]\n        \n        for n in tokens:\n            if n.isdigit() or len(n)>1:\n                stack.append(int(n))\n            else:\n                stack.append(update(n))\n        return stack.pop()"}
{"prompt": "def reverseWords(self, s: str) -> str:\n        #Time: O(n) since we scan through the input, where n = len(s)\n        #Space: O(n)\n        words = []\n        slow, fast = 0, 0\n        \n        #Use the first char to determine if we're starting on a \" \" or a word\n        mode = 'blank' if s[0] == ' ' else 'word'\n        \n        while fast < len(s):\n            #If we start on a word and our fast ptr lands on a white space\n            #means that we have singled out a word\n            if mode == 'word' and s[fast] == ' ':\n                words.append(s[slow:fast])\n                slow = fast #Make the slow ptr catch up\n                mode = 'blank'\n                \n            #If we start on a white space and our fast ptr runs into a character\n            #means we are at the start of a word   \n            elif mode == 'blank' and s[fast] != ' ':\n                slow = fast #Make the slow ptr catch up\n                mode = 'word'\n        \n            fast += 1 #Increment the fast pointer\n        \n        #Append the last word\n        #Edge cases where the last chunk of string are white spaces\n        if (lastWord := s[slow:fast]).isalnum():\n            words.append(lastWord)\n        \n        return ' '.join(words[::-1])"}
{"prompt": "def maxProduct(self, nums: List[int]) -> int:\n        curMax, curMin = 1, 1\n        res = nums[0]\n        \n        for n in nums:\n            vals = (n, n * curMax, n * curMin)\n            curMax, curMin = max(vals), min(vals)\n\t\t\t\n            res = max(res, curMax)\n            \n        return res"}
{"prompt": "def findMin(self, nums: List[int]) -> int:\n        start = 0\n        end = len(nums) - 1\n        \n        if(nums[start] <= nums[end]):\n            return nums[0]\n        \n        while start <= end:\n            mid = (start + end) // 2\n            \n            if(nums[mid] > nums[mid+1]):\n                return nums[mid+1]\n            \n            if(nums[mid-1] > nums[mid]):\n                return nums[mid]\n            \n            if(nums[mid] > nums[0]):\n                start = mid + 1\n            else:\n                end = mid - 1\n                \n        return nums[start]"}
{"prompt": "def findMin(self, a: List[int]) -> int:\n        \n        def solve(l,h):\n            while l<h:\n                m=(l+h)//2\n                \n                if a[m]<a[m-1]:\n                    return a[m]\n                \n                elif a[m]>a[h-1]:\n                    l=m+1\n                \n                elif a[m]<a[h-1]:\n                    h=m\n                \n                else:\n                \n                    if len(set(a[l:m+1]))==1:\n                        return min(a[m],solve(m+1,h))\n                    \n                    else:\n                        return min(a[m],solve(l,m))\n            \n            return a[min(l,len(a)-1)]\n        \n        return solve(0,len(a))"}
{"prompt": "class MinStack:\n\n    stackWithMinElements = collections.namedtuple(\"stackWithMinElements\", (\"element\", \"minimum\"))\n    \n    def __init__(self):        \n        self.stack : List[self.stackWithMinElements] = []\n\n    def push(self, x: int) -> None:\n        self.stack.append(self.stackWithMinElements(\n                        x, min(x, self.getMin()) if len(self.stack)>0 else x))\n\n    def pop(self) -> None:\n        self.stack.pop()\n\n    def top(self) -> int:\n        return self.stack[-1].element\n\n    def getMin(self) -> int:\n        return self.stack[-1].minimum"}
{"prompt": "def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        first_set=set()\n        curr=headA\n        \n        while curr:\n            first_set.add(curr)\n            curr=curr.next\n        \n        curr = headB\n        while curr:\n            if curr in first_set:\n                return curr\n            curr=curr.next\n\n        return None"}
{"prompt": "def findPeakElement(self, lst: List[int]) -> int:\n\t\tstart, end = 0, len(lst) - 1\n\n\t\twhile start < end:\n\n\t\t\tmid = start + (end - start) // 2\n\n\t\t\tif lst[mid] > lst[mid + 1]:\n\t\t\t\tend = mid\n\t\t\telse:\n\t\t\t\tstart = mid + 1\n\n\t\treturn start"}
{"prompt": "def maximumGap(self, nums: List[int]) -> int:\n        if len(nums) == 0: return 0 #edge case \n        mn, mx = min(nums), max(nums)\n        step = max(1, (mx - mn)//(len(nums)-1)) #n-1 holes \n        size = (mx - mn)//step + 1\n        buckets = [[inf, -inf] for _ in range(size)]\n        \n        for num in nums: \n            i = (num - mn)//step\n            x, xx = buckets[i]\n            buckets[i] = min(x, num), max(xx, num)\n        \n        ans = 0\n        prev = mn\n        for i in range(size):\n            x, xx = buckets[i]\n            if x < inf:\n                ans = max(ans, x - prev)\n                prev = xx \n        return ans"}
{"prompt": "def compareVersion(self, v1: str, v2: str) -> int:\n        v1, v2 = list(map(int, v1.split('.'))), list(map(int, v2.split('.')))  \n        for rev1, rev2 in zip_longest(v1, v2, fillvalue=0):\n            if rev1 == rev2:\n                continue\n\n            return -1 if rev1 < rev2 else 1 \n\n        return 0"}
{"prompt": "def fractionToDecimal(self, numerator: int, denominator: int) -> str:\n        \n        if numerator % denominator == 0: \n\t\t\treturn str(numerator // denominator)\n        \n        prefix = ''\n        if (numerator > 0) != (denominator > 0):\n            prefix = '-'\n        \n        # Operation must be on positive values\n        if numerator < 0:\n            numerator = - numerator\n        if denominator < 0:\n            denominator = - denominator\n\n        digit, remainder = divmod(numerator, denominator)\n            \n        res = prefix + str(digit) + '.' # EVERYTHING BEFORE DECIMAL\n        \n        table = {}\n        suffix = ''\n        \n        while remainder not in table.keys():\n            \n            # Store index of the reminder in the table\n            table[remainder] = len(suffix)\n            \n            val, remainder = divmod(remainder*10, denominator)\n            \n            suffix += str(val)\n            \n            # No repeating\n            if remainder == 0:\n                return res + suffix\n        \n        indexOfRepeatingPart = table[remainder]\n        \n        decimalTillRepeatingPart = suffix[:indexOfRepeatingPart]\n        \n        repeatingPart = suffix[indexOfRepeatingPart:]\n\n        return res + decimalTillRepeatingPart + '(' + repeatingPart + ')'\n\ns = Solution()\n\nprint(s.fractionToDecimal(2, 3))"}
{"prompt": "def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        i = 0\n        j = len(numbers) -1\n        \n        while i<j:\n            s = numbers[i] + numbers[j]\n            if s == target:\n                return [i + 1 , j + 1]\n            \n            if s > target:\n                j-=1\n            else:\n               i+=1 \n        \n        return []"}
{"prompt": "def convertToTitle(self, columnNumber):\n        # Create an empty string for storing the characters...\n        output = \"\"\n        # Run a while loop while columnNumber is positive...\n        while columnNumber > 0:\n            # Subtract 1 from columnNumber and get current character by doing modulo of columnNumber by 26...\n            output = chr(ord('A') + (columnNumber - 1) % 26) + output\n            # Divide columnNumber by 26...\n            columnNumber = (columnNumber - 1) // 26\n        # Return the output string.\n        return output"}
{"prompt": "def majorityElement(self, nums: List[int]) -> int:\n        curr, count = nums[0], 1              # curr will store the current majority element, count will store the count of the majority\n        for i in range(1,len(nums)):\n            count += (1 if curr == nums[i] else -1)    # if i is equal to current majority, they're in same team, hence added, else one current majority and i both will be dead\n            if not count:                   # if count is 0 means King is de-throwned\n                curr = nums[i+1] if i + 1 < len(nums) else None        # the next element is the new King\n                count = 0         # starting it with 0 because we can't increment the i of the for loop, the count will be 1 in next iteration, and again the battle continues after next iteration\n        return curr"}
{"prompt": "def titleToNumber(self, columnTitle: str) -> int:\n        ans, pos = 0, 0\n        for letter in reversed(columnTitle):\n            digit = ord(letter)-64\n            ans += digit * 26**pos\n            pos += 1\n            \n        return ans"}
{"prompt": "def trailingZeroes(self, n: int) -> int:\n        quotient = n // 5\n        return quotient + self.trailingZeroes(quotient) if quotient >= 5 else quotient"}
{"prompt": "class BSTIterator:\n    def __init__(self, root: Optional[TreeNode]):\n        self.iter = self._inorder(root)\n        self.nxt = next(self.iter, None)\n    \n    def _inorder(self, node: Optional[TreeNode]) -> Generator[int, None, None]:\n        if node:\n            yield from self._inorder(node.left)\n            yield node.val\n            yield from self._inorder(node.right)\n\n    def next(self) -> int:\n        res, self.nxt = self.nxt, next(self.iter, None)\n        return res\n\n    def hasNext(self) -> bool:\n        return self.nxt is not None"}
{"prompt": "def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\n        m, n = len(dungeon), len(dungeon[0])\n        \n        @cache\n        def fn(i, j):\n            \"\"\"Return min health at (i,j).\"\"\"\n            if i == m or j == n: return inf\n            if i == m-1 and j == n-1: return max(1, 1 - dungeon[i][j])\n            return max(1, min(fn(i+1, j), fn(i, j+1)) - dungeon[i][j])\n        \n        return fn(0, 0)"}
{"prompt": "def largestNumber(self, nums: List[int]) -> str:\n        nums = sorted(nums,key=lambda x:x / (10 ** len(str(x)) - 1 ), reverse=True)\n        str_nums = [str(num) for num in nums]\n        res = ''.join(str_nums)\n        res = str(int(res))\n        return res"}
{"prompt": "def findRepeatedDnaSequences(self, s: str) -> List[str]:\n        \n        res, d = [], {}\n        for i in range(len(s)):\n            \n            if s[i:i+10] not in d: d[s[i:i+10]] = 0\n            elif s[i:i+10] not in res: res.append(s[i:i+10])\n                \n        return res\n\t\t\n\t\t# An Upvote will be encouraging"}
{"prompt": "def maxProfit(self, k: int, prices: List[int]) -> int:\n        # no transaction, no profit\n        if k == 0: return 0\n        # dp[k][0] = min cost you need to spend at most k transactions\n        # dp[k][1] = max profit you can achieve at most k transactions\n        dp = [[1000, 0] for _ in range(k + 1)]\n        for price in prices:\n            for i in range(1, k + 1):\n                # price - dp[i - 1][1] is how much you need to spend\n                # i.e use the profit you earned from previous transaction to buy the stock\n                # we want to minimize it\n                dp[i][0] = min(dp[i][0], price - dp[i - 1][1])\n                # price - dp[i][0] is how much you can achieve from previous min cost\n                # we want to maximize it\n                dp[i][1] = max(dp[i][1], price - dp[i][0])\n        # return max profit at most k transactions\n\t\t# or you can write `return dp[-1][1]`\n        return dp[k][1]"}
{"prompt": "def rotate(self, nums: List[int], k: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n            \n        def twopt(arr, i, j):\n            while (i < j):\n                arr[i], arr[j] = arr[j], arr[i]\n                i += 1\n                j -= 1\n            return arr\n        \n        if k > len(nums):\n            k %= len(nums)\n            \n        if (k > 0):\n            twopt(nums, 0, len(nums) - 1)  # rotate entire array\n            twopt(nums, 0, k - 1)          # rotate array upto k elements\n            twopt(nums, k, len(nums) - 1)  # rotate array from k to end of array"}
{"prompt": "def reverseBits(self, n: int) -> int:\n        res = 0\n        for _ in range(32):\n            res = (res<<1) + (n&amp;1)\n            n>>=1\n        return res"}
{"prompt": "def hammingWeight(self, n: int) -> int: \n        return sum((n &amp; (1<<i))!=0 for i in range(32))"}
{"prompt": "def __init__(self):\n        self.cache = {}\n        \n    def rob_rec(self, nums, start):\n        if start >= len(nums):\n            return 0\n        \n        if start in self.cache:\n            return self.cache[start]\n        \n        self.cache[start] = nums[start] + max(self.rob_rec(nums, start+2), self.rob_rec(nums, start+3))\n        return self.cache[start]\n        \n    def rob(self, nums: List[int]) -> int:\n        return max(self.rob_rec(nums, 0), self.rob_rec(nums, 1))"}
{"prompt": "def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        \n        def solve(root, lvl):\n        \tif root:\n        \t\tif len(res)==lvl:\n        \t\t\tres.append(root.val)\n        \t\tsolve(root.right, lvl + 1)\n        \t\tsolve(root.left, lvl + 1)\n        \treturn \n\n        res = []\n        solve(root,0)\n        return res"}
{"prompt": "def numIslands(self, grid: List[List[str]]) -> int:\n        if not grid: return 0\n        m, n = len(grid), len(grid[0])\n        ans = 0\n        def dfs(i, j):\n            grid[i][j] = '2'\n            for di, dj in (0, 1), (0, -1), (1, 0), (-1, 0):\n                ii, jj = i+di, j+dj\n                if 0 <= ii < m and 0 <= jj < n and grid[ii][jj] == '1':\n                    dfs(ii, jj)\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '1':\n                    dfs(i, j)\n                    ans += 1\n        return ans"}
{"prompt": "def rangeBitwiseAnd(self, m: int, n: int) -> int:\n        \n        shift = 0\n        \n        # find the common MSB bits.\n        while m != n:\n            \n            m = m >> 1\n            n = n >> 1\n        \n            shift += 1\n        \n        \n        return m << shift"}
{"prompt": "def isHappy(self, n):\n        hset = set()\n        while n != 1:\n            if n in hset: return False\n            hset.add(n)\n            n = sum([int(i) ** 2 for i in str(n)])\n        else:\n            return True"}
{"prompt": "def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy_head = ListNode(-1)\n        dummy_head.next = head\n        \n        current_node = dummy_head\n        while current_node.next != None:\n            if current_node.next.val == val:\n                current_node.next = current_node.next.next\n            else:\n                current_node = current_node.next\n                \n        return dummy_head.next"}
{"prompt": "def countPrimes(self, n: int) -> int:\n        \n        if n<2:\n            return 0\n        \n        #initialize a list of length n\n        prime=[1]*n\n\t\t#mark 0th  and 1st index as 0\n        prime[0]=prime[1]=0\n        \n\t\t#we will check for multiple from range 2 to sqrt(n)\n        for i in range(2,int(sqrt(n))+1):\n            if prime[i] == 1:\n\t\t\t#mark all multiple of prime number as  0\n                prime[i*i:n:i] = [0] * ((n-1-i*i)//i + 1)\n    #return total count of prime \n        return sum(prime)"}
{"prompt": "def isIsomorphic(self, s: str, t: str) -> bool:\n        return [*map(s.index, s)] == [*map(t.index, t)]"}
{"prompt": "def reverseList(self, head):\n        # Initialize prev pointer as NULL...\n        prev = None\n        # Initialize the curr pointer as the head...\n        curr = head\n        # Run a loop till curr points to NULL...\n        while curr:\n            # Initialize next pointer as the next pointer of curr...\n            next = curr.next\n            # Now assign the prev pointer to curr’s next pointer.\n            curr.next = prev\n            # Assign curr to prev, next to curr...\n            prev = curr\n            curr = next\n        return prev       # Return the prev pointer to get the reverse linked list..."}
{"prompt": "def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n\t\tgraph=defaultdict(list)\n\t\tindegree={}\n\n\t\t#initialising dictionary\n\t\tfor i in range(numCourses):\n\t\t\tindegree[i]=0\t\n\n\t\t#filling graph and indegree dictionaries\n\t\tfor child,parent in prerequisites:\n\t\t\tgraph[parent].append(child)\n\t\t\tindegree[child]+=1\n\n\t\tqueue=deque()\n\t\tfor key,value in indegree.items():\n\t\t\tif value==0:\n\t\t\t\tqueue.append(key)\n\n\t\tcourseSequence=[]\n\t\twhile queue:\n\t\t\tcourse=queue.popleft()\n\t\t\tcourseSequence.append(course)\n\t\t\tfor neighbour in graph[course]:\n\t\t\t\tindegree[neighbour]-=1\n\t\t\t\tif indegree[neighbour]==0:\n\t\t\t\t\tqueue.append(neighbour)\n\n\t\treturn len(courseSequence)==numCourses:"}
{"prompt": "def minSubArrayLen(self, target: int, nums: List[int]) -> int:\n        \n        left = 0 # keep track of left pointer\n        rsum = 0 # keep the running sum\n        res = None # Answer we will return\n        \n        # Iterate through the array, the index will be your right pointer\n        for right in range(len(nums)):\n            \n            # Add the current value to the running sum\n            rsum += nums[right]\n            \n            # Once you reach a value at or equal to the target you\n            # can use a while loop to start subtracting the values from left\n            # to right so that you can produce the minimum size subarray\n            while rsum >= target:\n                \n                # The result is either the current result you have, \n                # or the count of numbers from the current left position \n                # to the rightmost position. You need it to be right + 1 \n                # because index starts at 0 (if you based the right as the \n                # last index it would be 4 or len(nums) - 1)\n                \n                # If res is None we compare it against the max float, \n                # saves us from having an if/else\n                res = min(res or float('inf'), right + 1 - left)\n                \n                # Subtract the number to see if we can continue subtracting based\n                # on the while loop case and increment the left pointer\n                rsum -= nums[left]\n                left += 1\n\n        return res or 0"}
{"prompt": "def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        \n        # Handle edge case.\n        if not prerequisites: return [course for course in range(numCourses)]\n        \n        # 'parents' maps each course to a list of its pre\n\t\t# -requisites.\n        parents = {course: [] for course in range(numCourses)}\n        for course, prerequisite in prerequisites:\n            parents[course].append(prerequisite)\n            \n        topological_order = []\n        visited, current_path = [False]*numCourses, [False]*numCourses\n        \n        # Returns False if the digraph rooted at 'course'\n\t\t# is acyclic, else, appends courses to 'topological\n        # _order' in topological order and returns True.\n        def dfs(course):\n            if current_path[course]: return False\n            if visited[course]: return True\n            visited[course], current_path[course] = True, True\n            if parents[course]:\n                for parent in parents[course]:\n                    if not dfs(parent): return False\n            topological_order.append(course)\n            current_path[course] = False\n            return True\n        \n        for course in range(numCourses):\n            if not dfs(course): return []\n            \n        return topological_order"}
{"prompt": "def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\n        m = len(board)\n        n = len(board[0])\n        res = []\n\n        d = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n\n        ref = set()\n        for i in range(m):\n            for j in range(n-1):\n                ref.add(board[i][j] + board[i][j+1])\n        for j in range(n):\n            for i in range(m-1):\n                ref.add(board[i][j] + board[i+1][j])\n\n        for word in words:\n            f = True\n            for i in range(len(word)-1):\n                if word[i:i+2] not in ref and word[i+1] + word[i] not in ref:\n                    f = False\n                    break\n            if not f:\n                continue\n            if self.findWord(word, m, n, board, d):\n                res.append(word)\n        return res\n    \n    def findWord(self, word, m, n, board, d) -> bool:\n        if word[:4] == word[0] * 4:\n            word = ''.join([c for c in reversed(word)])\n        starts = []\n        stack = []\n        visited = set()\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == word[0]:\n                    if len(word) == 1:\n                        return True\n                    starts.append((i, j))\n        for start in starts:\n            stack.append(start)\n            visited.add((start, ))\n            l = 1\n            while stack != [] and l < len(word):\n                x, y = stack[-1]\n                for dxy in d:\n                    nx, ny = x + dxy[0], y + dxy[1]\n                    if 0 <= nx < m and 0 <= ny < n:\n                        if board[nx][ny] == word[l]:\n                            if (nx, ny) not in stack and tuple(stack) + ((nx, ny),) not in visited:\n                                stack.append((nx, ny))\n                                visited.add(tuple(stack))\n                                l += 1\n                                if l == len(word):\n                                    return True\n                                break\n                else:\n                    stack.pop()\n                    l -= 1\n        else:\n            return False"}
{"prompt": "def rob(self, nums: List[int]) -> int:\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        dp = {}\n        def getResult(a,i):\n            if i>=len(a):\n                return 0\n            if i in dp:\n                return dp[i]\n            \n            sum = 0\n            if i<len(a)-1:\n                sum+= max(a[i]+getResult(a,i+2),a[i+1]+getResult(a,i+3))\n            else:\n                sum+=a[i]+getResult(a,i+2)\n            dp[i] = sum\n            return sum\n            \n        x = getResult(nums[:len(nums)-1],0)\n        dp = {}\n        y = getResult(nums[1:],0)\n            \n        return max(x, y)"}
{"prompt": "def shortestPalindrome(self, s: str) -> str:\n        \n        end = 0\n        \n        # if the string itself is a palindrome return it\n        if(s == s[::-1]):\n            return s\n        \n        # Otherwise find the end index of the longest palindrome that starts\n        # from the first character of the string\n        \n        for i in range(len(s)+1):\n            if(s[:i]==s[:i][::-1]):\n                end=i-1\n        \n        # return the string with the remaining characters other than\n        # the palindrome reversed and added at the beginning\n        \n        return (s[end+1:][::-1])+s"}
{"prompt": "def findKthLargest(self, nums: List[int], k: int) -> int:                    \n        n = len(nums)\n        \n        def partition(l, r, pivot):\n            pivot_elem=nums[pivot]\n            nums[r],nums[pivot]=nums[pivot],nums[r]\n            \n            index=l\n            for i in range(l, r):\n                if nums[i]<pivot_elem:\n                    nums[i],nums[index]=nums[index],nums[i]\n                    index+=1\n            \n            nums[index],nums[r]=nums[r],nums[index]\n            return index\n        \n        def quick_select(l,r,kth_index):\n            if l==r:\n                return nums[l]\n            \n            pivot_index=partition(l,r,l)\n            \n            if pivot_index==kth_index:\n                return nums[pivot_index]\n            \n            if kth_index>pivot_index:\n                return quick_select(pivot_index+1, r, kth_index)\n            else:\n                return quick_select(l,pivot_index-1, kth_index)\n        \n        return quick_select(0, n - 1, n - k)"}
{"prompt": "def combinationSum3(self, k: int, n: int) -> List[List[int]]:\n        \n        current_combination, combinations = [], []\n        integer, combination_sum = 1, 0\n        queue = [(integer, current_combination, combination_sum)]\n        while queue:\n            integer, current_combination, combination_sum = queue.pop()\n            if combination_sum == n and len(current_combination) == k: combinations.append(current_combination)\n            else:\n                for i in range(integer, 10):\n                    if combination_sum + i > n: break\n                    queue.append((i+1, current_combination + [i], combination_sum + i))\n        \n        return combinations"}
{"prompt": "def containsDuplicate(self, nums: List[int]) -> bool:\n        return len(set(nums)) != len(nums)"}
{"prompt": "def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:\n        # for the same x, (x, -H) should be in front of (x, 0)\n        # For Example 2, we should process (2, -3) then (2, 0), as there's no height change\n        x_height_right_tuples = sorted([(L, -H, R) for L, R, H in buildings] + [(R, 0, \"doesn't matter\") for _, R, _ in buildings])   \n        # (0, float('inf')) is always in max_heap, so max_heap[0] is always valid\n        result, max_heap = [[0, 0]], [(0, float('inf'))]\n        for x, negative_height, R in x_height_right_tuples:\n            while x >= max_heap[0][1]:\n                # reduce max height up to date, i.e. only consider max height in the right side of line x\n                heapq.heappop(max_heap)\n            if negative_height:\n                # Consider each height, as it may be the potential max height\n                heapq.heappush(max_heap, (negative_height, R))\n            curr_max_height = -max_heap[0][0]\n            if result[-1][1] != curr_max_height:\n                result.append([x, curr_max_height])\n        return result[1:]"}
{"prompt": "def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\n        # Create hset for storing previous of k elements...\n        hset = {}\n        # Traverse for all elements of the given array in a for loop...\n        for idx in range(len(nums)):\n            # If duplicate element is present at distance less than equal to k, return true...\n            if nums[idx] in hset and abs(idx - hset[nums[idx]]) <= k:\n                return True\n            hset[nums[idx]] = idx\n        # If no duplicate element is found then return false...\n        return False"}
{"prompt": "def containsDuplicate(self, nums: List[int]) -> bool:\n        seen = set()\n        for x in nums:\n            if x in seen: return True \n            seen.add(x)\n        return False"}
{"prompt": "def maximalSquare(self, matrix: List[List[str]]) -> int:\n        result = 0\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                curr = 0  # current length of the square at (i, j)\n                flag = True  # indicates if there still exists a valid square\n                while flag:\n                    for k in range(curr+1):\n                        # check outer border of elements for '1's.\n                        \"\"\"\n                        eg curr = 2, ie a valid 2x2 square exists\n                        'O' is valid, check 'X':\n                        X X X\n                        X O O\n                        X O O\n                        \"\"\"\n                        if i < curr or j < curr or \\\n                                matrix[i-curr][j-k] == '0' or \\\n                                matrix[i-k][j-curr] == '0':\n                            flag = False\n                            break\n                    curr += flag\n                if curr > result:  # new maximum length of square obtained\n                    result = curr\n        return result*result  # area = length x length"}
{"prompt": "def countNodes(self, root: TreeNode) -> int:\n        if not root: return 0\n        return 1 + self.countNodes(root.left) + self.countNodes(root.right)"}
{"prompt": "def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\n        coxl=max(ax1,bx1)\n        coxr=min(ax2,bx2)\n        coyl=max(ay1,by1)\n        coyr=min(ay2,by2)\n        dx=coxr-coxl\n        dy=coyr-coyl\n        comm=0\n        if dx>0 and dy>0:\n            comm=dx*dy\n        a=abs(ax2-ax1)*abs(ay2-ay1)\n        b=abs(bx2-bx1)*abs(by2-by1)\n        area=a+b-comm\n        return area"}
{"prompt": "def calculate(self, s: str) -> int:\n        output, curr, sign, stack = 0, 0, 1, []\n        for c in s:\n            if c.isdigit():\n                curr = (curr * 10) + int(c)\n            \n            elif c in '+-':\n                output += curr * sign\n                curr = 0\n                if c == '+':\n                    sign = 1\n\n                else:\n                    sign = -1\n            \n            elif c == '(':\n                stack.append(output)\n                stack.append(sign)\n                sign = 1\n                output = 0\n            \n            elif c == ')':\n                output += curr * sign\n                output *= stack.pop()    #sign\n                output += stack.pop()    #last output\n                curr = 0\n\n        return output + (curr * sign)"}
{"prompt": "def invertTree(self, root):\n        # Base case...\n        if root == None:\n            return root\n        # swapping process...\n        root.left, root.right = root.right, root.left\n        # Call the function recursively for the left subtree...\n        self.invertTree(root.left)\n        # Call the function recursively for the right subtree...\n        self.invertTree(root.right)\n        return root     # Return the root..."}
{"prompt": "def calculate(self, s: str) -> int:\n        curr_res = 0\n        res = 0\n        num = 0\n        op = \"+\"  # keep the last operator we have seen\n        \n\t\t# append a \"+\" sign at the end because we can catch the very last item\n        for ch in s + \"+\":\n            if ch.isdigit():\n                num = 10 * num + int(ch)\n\n            # if we have a symbol, we would start to calculate the previous part.\n            # note that we have to catch the last chracter since there will no sign afterwards to trigger calculation\n            if ch in (\"+\", \"-\", \"*\", \"/\"):\n                if op == \"+\":\n                    curr_res += num\n                elif op == \"-\":\n                    curr_res -= num\n                elif op == \"*\":\n                    curr_res *= num\n                elif op == \"/\":\n                    # in python if there is a negative number, we should alway use int() instead of //\n                    curr_res = int(curr_res / num)\n                \n                # if the chracter is \"+\" or \"-\", we do not need to worry about\n                # the priority so that we can add the curr_res to the eventual res\n                if ch in (\"+\", \"-\"):\n                    res += curr_res\n                    curr_res = 0\n                \n                op = ch\n                num = 0\n        \n        return res"}
{"prompt": "def summaryRanges(self, nums: List[int]) -> List[str]:\n\n\t\tstart = 0\n\t\tend = 0\n\n\t\tresult = []\n\n\t\twhile start < len(nums) and end<len(nums):\n\n\t\t\tif end+1 < len(nums) and nums[end]+1 == nums[end+1]:\n\t\t\t\tend=end+1\n\n\t\t\telse:\n\t\t\t\tif start == end:\n\t\t\t\t\tresult.append(str(nums[start]))\n\t\t\t\t\tstart = start + 1\n\t\t\t\t\tend = end + 1\n\t\t\t\telse:\n\t\t\t\t\tresult.append(str(nums[start])+'->'+str(nums[end]))\n\t\t\t\t\tstart = end + 1\n\t\t\t\t\tend = end + 1\n\n\t\treturn result"}
{"prompt": "def majorityElement(self, nums: List[int]) -> List[int]:\n        return [x for x in set(nums) if nums.count(x) > len(nums)/3]"}
{"prompt": "import heapq\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        \n        heap = []\n        def inorder(r):\n            if r:\n                inorder(r.left)\n                heapq.heappush(heap,-(r.val))\n                if len(heap) > k:\n                    heapq.heappop(heap)\n                inorder(r.right)\n        inorder(root)\n        \n        return -heapq.heappop(heap)"}
{"prompt": "def isPowerOfTwo(self, n: int) -> bool:\n        return n>0 and n&amp;(n-1)==0"}
{"prompt": "def countDigitOne(self, n: int) -> int:\n        \n        #O(logn) mathematical solution\n        #intervals of new 1s: 0-9, 10-99, 100-999, 1000,9999... \n            #each interval yields 1,10,100,etc. new '1's respectively\n\t\t#first and foremost, we want to check how many of each interval repeats \n        #conditions for FULL yield when curr%upper bound+1: 1 <=, 19 <=, 199 <=...\n        #conditions for PARTIAL yielf when curr%upper bound+1: None, 10 <= < 19,  100 <= < 199, 1000 <= < 1999 ... \n        \n        ans = 0\n        for i in range(len(str(n))):\n            curr = 10**(i+1)\n            hi,lo = int('1'+'9'*i), int('1'+'0'*i)\n            ans += (n//curr) * 10**i\n            if (pot:=n%curr) >= hi: ans += 10**i\n            elif lo <= pot < hi: \n                ans += pot - lo + 1\n        return ans"}
{"prompt": "def isPalindrome(self, head: Optional[ListNode]) -> bool:\n        def reverse(node):\n            prev = None\n            while node:\n                next_node = node.next\n                node.next = prev \n                prev, node = node, next_node\n                \n            return prev\n        \n        slow = head\n        fast = head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        n1 = head\n        n2 = reverse(slow.next)\n        while n2:\n            if n1.val != n2.val:\n                return False\n            \n            n1 = n1.next\n            n2 = n2.next\n            \n        return True"}
{"prompt": "def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        \n        while True:\n            if root.val > p.val and root.val > q.val:\n                root = root.left\n            elif root.val < p.val and root.val < q.val:\n                root = root.right\n            else:\n                return root"}
{"prompt": "def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        if root==None or root.val==p.val or root.val==q.val:\n            return root\n        left=self.lowestCommonAncestor(root.left,p,q)\n        right=self.lowestCommonAncestor(root.right,p,q)\n        if left!=None and right!=None:\n            return root\n        elif left!=None:\n            return left\n        else:\n            return right"}
{"prompt": "def deleteNode(self, node):\n\n        nextNode = node.next\n        node.val = nextNode.val\n        node.next = nextNode.next"}
{"prompt": "def productExceptSelf(self, nums: List[int]) -> List[int]:\n        leftProducts = [0]*len(nums) # initialize left array \n        rightProducts = [0]*len(nums) # initialize right array\n        \n        leftProducts[0] = 1 # the left most is 1\n        rightProducts[-1] = 1 # the right most is 1\n        res = [] # output\n        \n        for i in range(1, len(nums)):\n            leftProducts[i] = leftProducts[i-1]*nums[i-1]\n            rightProducts[len(nums) - i - 1] = rightProducts[len(nums) - i]*nums[len(nums) - i]\n            \n        for i in range(len(nums)):\n            res.append(leftProducts[i]*rightProducts[i])\n        \n        return res"}
{"prompt": "def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        res = []\n        window = collections.deque()\n        for i, num in enumerate(nums):\n            while window and num >= nums[window[-1]]:\n                window.pop()\n            window.append(i)\n            \n            if i + 1 >= k:\n                res.append(nums[window[0]])\n            \n            if i - window[0] + 1 == k:\n                window.popleft()\n        \n        return res"}
{"prompt": "def searchMatrix(self, mat: List[List[int]], target: int) -> bool:\n        \n        m=len(mat)\n        n=len(mat[0])\n        \n        i=m-1\n        j=0\n        \n        while i>=0 and j<n:\n            if mat[i][j]==target:\n                return True\n            elif mat[i][j]<target:\n                j+=1\n            else:\n                i-=1\n                \n        return False"}
{"prompt": "def diffWaysToCompute(self, s, memo=dict()):\n        if s in memo:\n            return memo[s]\n        if s.isdigit(): # base case\n            return [int(s)]\n        calculate = {'*': lambda x, y: x * y,\n                     '+': lambda x, y: x + y,\n                     '-': lambda x, y: x - y\n                    }\n        result = []\n        for i, c in enumerate(s):\n            if c in '+-*':\n                left = self.diffWaysToCompute(s[:i], memo)\n                right = self.diffWaysToCompute(s[i+1:], memo)\n                for l in left:\n                    for r in right:\n                        result.append(calculate[c](l, r))\n        memo[s] = result\n        return result"}
{"prompt": "def isAnagram(self, s: str, t: str) -> bool:\n        tracker = collections.defaultdict(int)\n        for x in s: tracker[x] += 1\n        for x in t: tracker[x] -= 1\n        return all(x == 0 for x in tracker.values())"}
{"prompt": "def binaryTreePaths(self, R: TreeNode) -> List[str]:\n        A, P = [], []\n        def dfs(N):\n            if N == None: return\n            P.append(N.val)\n            if (N.left,N.right) == (None,None): A.append('->'.join(map(str,P)))\n            else: dfs(N.left), dfs(N.right)\n            P.pop()\n        dfs(R)\n        return A\n\t\t\n\t\t\n- Junaid Mansuri\n- Chicago, IL"}
{"prompt": "def addDigits(self, num):\n        while num > 9:\n            num = num % 10 + num // 10\n        return num"}
{"prompt": "def singleNumber(self, nums: List[int]) -> List[int]:\n        dc=defaultdict(lambda:0)\n        for a in(nums):\n            dc[a]+=1\n        ans=[]\n        for a in dc:\n            if(dc[a]==1):\n                ans.append(a)\n        return ans"}
{"prompt": "def isUgly(self, num: int) -> bool:\n        if num == 0: return False\n        while num % 5 == 0: num /= 5\n        while num % 3 == 0: num /= 3\n        while num % 2 == 0: num /= 2\n        return num == 1\n\t\t\n\n- Junaid Mansuri"}
{"prompt": "def nthUglyNumber(self, n: int) -> int:\n        k = [0] * n\n        t1 = t2 = t3 = 0\n        k[0] = 1\n        for i in range(1,n):\n            k[i] = min(k[t1]*2,k[t2]*3,k[t3]*5)\n            if(k[i] == k[t1]*2): t1 += 1\n            if(k[i] == k[t2]*3): t2 += 1\n            if(k[i] == k[t3]*5): t3 += 1\n        return k[n-1]"}
{"prompt": "def missingNumber(self, nums: List[int]) -> int:\n        return (len(nums) * (len(nums) + 1))//2 - sum(nums)"}
{"prompt": "def numberToWords(self, num: int) -> str:\n        mp = {1: \"One\",   11: \"Eleven\",    10: \"Ten\", \n              2: \"Two\",   12: \"Twelve\",    20: \"Twenty\", \n              3: \"Three\", 13: \"Thirteen\",  30: \"Thirty\", \n              4: \"Four\",  14: \"Fourteen\",  40: \"Forty\",\n              5: \"Five\",  15: \"Fifteen\",   50: \"Fifty\", \n              6: \"Six\",   16: \"Sixteen\",   60: \"Sixty\", \n              7: \"Seven\", 17: \"Seventeen\", 70: \"Seventy\", \n              8: \"Eight\", 18: \"Eighteen\",  80: \"Eighty\",\n              9: \"Nine\",  19: \"Nineteen\",  90: \"Ninety\"}\n        \n        def fn(n):\n            \"\"\"Return English words of n (0-999) in array.\"\"\"\n            if not n: return []\n            elif n < 20: return [mp[n]]\n            elif n < 100: return [mp[n//10*10]] + fn(n%10)\n            else: return [mp[n//100], \"Hundred\"] + fn(n%100)\n        \n        ans = []\n        for i, unit in zip((9, 6, 3, 0), (\"Billion\", \"Million\", \"Thousand\", \"\")): \n            n, num = divmod(num, 10**i)\n            ans.extend(fn(n))\n            if n and unit: ans.append(unit)\n        return \" \".join(ans) or \"Zero\""}
{"prompt": "def hIndex(self, citations: List[int]) -> int:\n        tmp = [0] * (len(citations) + 1)\n\t\t\n        for i in range(len(citations)):\n            if citations[i] > len(citations):\n                tmp[len(citations)] += 1\n            else:\n                tmp[citations[i]] += 1\n\n        sum_ = 0\n        for i in range(len(tmp) - 1, -1, -1):\n            sum_ += tmp[i]\n            if sum_ >= i:\n                return i"}
{"prompt": "def hIndex(self, A):\n        n = len(A)\n        l, r = 0, n - 1\n        while l < r:\n            m = (l + r + 1) // 2\n            if A[m] > n - m: r = m - 1\n            else: l = m\n        return n - l - (A[l] < n - l)"}
{"prompt": "def firstBadVersion(self, n: int) -> int:\n        left = 1\n        right = n\n        result = 1\n        \n        while left<=right:\n            mid = (left+right)//2\n            if isBadVersion(mid) == False:\n                left = mid+1\n            else:\n                right = mid-1\n                result = mid\n                \n        return result"}
{"prompt": "def isSquare(self, n: int) -> bool:\n        sq = int(math.sqrt(n))\n        return sq*sq == n\n        \n    def numSquares(self, n: int) -> int:\n        # Lagrange's four-square theorem\n        if self.isSquare(n):\n            return 1\n        while (n &amp; 3) == 0:\n            n >>= 2\n        if (n &amp; 7) == 7:\n            return 4\n        sq = int(math.sqrt(n)) + 1\n        for i in range(1,sq):\n            if self.isSquare(n - i*i):\n                return 2\n        return 3"}
{"prompt": "def addOperators(self, num: str, target: int) -> List[str]:\n        exprs = []\n        \n        def recurse(idx, value, delta, exp):\n            # base case here\n            if idx == len(num):\n                if value == target:\n                    exprs.append(\"\".join(exp))\n            \n            # the loop will create the current operand and recursively call\n            # the next set of actions to be executed\n            for i in range(idx, len(num)):\n                # this is to avoid cases where the operand starts with a 0\n                # we need to have a case with just the 0 but not something like\n                # 05, so the condition will return early if we find such cases\n                if num[idx] == '0' and i > idx:\n                    return\n                \n                curr = int(num[idx:i+1])\n                curr_str = num[idx:i+1]\n                \n                # when we start the problem we dont have a preceding operator or operand\n                if idx == 0:\n                    recurse(i+1, curr, curr, exp + [curr_str])\n                else:\n                    # We need to do 3 different recursions for each operator\n                    # value stores the running value of the expression evaluated so far\n                    # the crux of the logic lies in how we use and pass delta\n                    # when the operation is '+' or '-' we don't care much about it and can just\n                    # add or subtract it from the value \n                    # when '*' is involved, we need to follow the precedence relation,\n                    # but we have already evaluated the previous operator. We know the\n                    # previous operation that was performed and how much it contributed to the value i.e., delta\n                    # so, we can revert that operation by subtracting delta from value and reapplying the multiplication\n                    recurse(i+1, value+curr, curr, exp + ['+', curr_str])\n                    recurse(i+1, value-curr, -curr, exp + ['-', curr_str])\n                    recurse(i+1, (value-delta)+curr*delta, curr*delta, exp + ['*', curr_str])\n                            \n        recurse(0, 0, 0, [])\n        return exprs"}
{"prompt": "def moveZeroes(self, nums):\n\t\ti=0\n\t\tn = len(nums)\n\t\twhile i <n:\n\t\t\tif nums[i]==0:\n\t\t\t\tnums.pop(i)\n\t\t\t\tnums.append(0)\n\t\t\t\tn-=1\n\t\t\telse:\n\t\t\t\ti+=1"}
{"prompt": "def findDuplicate(self, nums: List[int]) -> int:\n        slow = fast = ans = 0\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast:\n                break\n        while ans != slow:\n            ans = nums[ans]\n            slow = nums[slow]\n        return ans"}
{"prompt": "def gameOfLife(self, board: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def is_neighbor(board, i, j):\n            return (0 <= i < len(board)) and (0 <= j < len(board[0])) and board[i][j] % 10 == 1\n        \n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                for d in directions:\n                    board[i][j] += 10 if is_neighbor(board, i + d[0], j + d[1]) else 0 # if adj cell is neighbor, add 10\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                neighbors = board[i][j] // 10 # count of neighbors\n                is_live = board[i][j] % 10 == 1 # state is live or not\n                if is_live: # live(1)\n                    if neighbors < 2:   # Rule 1\n                        board[i][j] = 0\n                    elif neighbors > 3: # Rule 3\n                        board[i][j] = 0\n                    else:               # Rule 2\n                        board[i][j] = 1\n                else: # dead(0)\n                    if neighbors == 3:  # Rule 4\n                        board[i][j] = 1\n                    else:\n                        board[i][j] = 0"}
{"prompt": "def wordPattern(self, pattern: str, s: str) -> bool:\n        li = s.split(' ')\n        di = {}\n        if len(li) != len(pattern):\n            return False\n        \n        for i, val in enumerate(pattern):\n            if val in di and di[val] != li[i]:\n                return False\n            elif val not in di and li[i] in di.values():\n                return False\n            elif val not in di:\n                di[val] = li[i]\n                    \n        return True"}
{"prompt": "def canWinNim(self, n: int) -> bool:        \n        if n <= 3:\n            return True\n        new_size = n + 1\n        memo = [False] * (new_size)\n        \n        for i in range(4): \n            memo[i] = True\n        \n        for i in range(4,new_size):\n            for j in range(1,4):\n                if memo[i] == True:\n                    break\n                if memo[i-j] == True:\n                    memo[i] = False\n                else:\n                    memo[i] = True\n        \n        return memo[n]"}
{"prompt": "def getHint(self, secret: str, guess: str) -> str:\n        \n\t\t# The main idea is to understand that cow cases contain the bull cases\n\t\t\n\t\t# This loop will take care of \"bull\" cases\n        bull=0\n        for i in range(len(secret)):\n            bull += int(secret[i] == guess[i])\n        \n\t\t# This loop will take care of \"cow\" cases\n        cows=0\n        for c in set(secret):\n            cows += min(secret.count(c), guess.count(c))\n        \n        return f\"{bull}A{cows-bull}B\""}
{"prompt": "# Suppose, for example:\n                    #           nums = [1,8,4,5,3,7],\n                    # for which the longest strictly increasing subsequence is arr = [1,4,5,7],\n                    # giving len(arr) = 4 as the answer\n                    #\n                    # Here's the plan:\n                    #   1) Initiate arr = [num[0]], which in this example means arr = [1]\n                    #     \n                    #   2) Iterate through nums. 2a) If n in nums is greater than arr[-1], append n to arr. 2b) If \n                    #      not, determine the furthest position in arr at which n could be placed so that arr\n                    #      remains strictly increasing, and overwrite the element at that position in arr with n.\n\n                    #   3) Once completed, return the length of arr.\n\n                    # Here's the iteration for the example:\n\n                    #       nums = [ _1_, 8,4,5,3,7]     arr = [1]              (initial step)\n                    #       nums = [1, _8_, 4,5,3,7]     arr = [1, 8]           (8 > 1, so    append 8)\n                    #       nums = [1,8, _4_, 5,3,7]     arr = [1, 4]           (4 < 8, so overwrite 8)\n                    #       nums = [1_8,4, _5_, 3,7]     arr = [1, 4, 5]        (5 > 4, so    append 5)\n                    #       nums = [1_8,4,5, _3_, 7]     arr = [1, 3, 5]        (3 < 5, so overwrite 4)\n                    #       nums = [1_8,4,5,3, _7_ ]     arr = [1, 3, 5, 7]     (7 > 5, so    append 7)    \n\n                    # Notice that arr is not the sequence given above as the correct seq. The ordering for [1,3,5,7]\n                    # breaks the \"no changing the order\" rule. Cheating? Maybe... However len(arr) = 4 is the \n                    # correct answer. Overwriting 4 with 3 did not alter the sequence's length.\n                                \n    def lengthOfLIS(self, nums: list[int]) -> int:\n\n        arr = [nums.pop(0)]                  # <-- 1) initial step\n \n        for n in nums:                       # <-- 2) iterate through nums\n            \n            if n > arr[-1]:                  # <--    2a)\n                arr.append(n)\n\n            else:                            # <--    2b)\n                arr[bisect_left(arr, n)] = n \n\n        return len(arr)                      # <-- 3) return the length of arr"}
{"prompt": "def removeInvalidParentheses(self, s: str) -> List[str]:\n        \n        def valid(s):\n            l,r=0,0\n            for c in s:\n                if c=='(':\n                    l+=1\n                elif c==')':\n                    if  l<=0:\n                        r+=1\n                    else:\n                        l-=1\n            return not l and not r\n        \n        res=[]\n        seen=set()\n        level={s}\n        while True:\n            newLevel=set()\n            for word in level:\n                if valid(word):\n                    res.append(word)\n            if res: return res\n            \n            for word in level:\n                for i in range(len(word)):\n                    if word[i] in '()':\n                        newWord=word[:i]+word[i+1:]\n                        if newWord not in seen:\n                            seen.add(newWord)\n                            newLevel.add(newWord)\n                  \n            level=newLevel\n                \n        return [\"\"]"}
{"prompt": "def isAdditiveNumber(self, s: str) -> bool:\n        n = len(s)\n        for i in range(1, n): # Choose the length of first number\n            # If length of 1st number is > 1 and starts with 0 -- skip\n            if i != 1 and s[0] == '0':\n                continue\n            for j in range(1, n): # Choose the length of second number\n                # If length of 2nd number is > 1 and starts with 0 -- skip\n                if j != 1 and s[i] == '0':\n                    continue\n\n                # If the total length of 1st and 2nd number >= n -- skip\n                if i + j >= n:\n                    break\n\n                # Just use the brute force approach\n                a = int(s[0: i])\n                b = int(s[i: i+j])\n                d = i+j\n                while d < n:\n                    c = a + b\n                    t = str(c)\n                    if s[d: d + len(t)] != t:\n                        break\n                    d += len(t)\n                    a = b\n                    b = c\n                if d == n:\n                    return True\n        return False"}
{"prompt": "def maxProfit(self, prices: List[int]) -> int:\n        n = len(prices)\n        dp = [[0 for i in range(2)] for i in range(n+2)]\n        \n        dp[n][0] = dp[n][1] = 0\n            \n        ind = n-1\n        while(ind>=0):\n\t\t\n            for buy in range(2):\n                if(buy):\n                    profit = max(-prices[ind] + dp[ind+1][0], 0 + dp[ind+1][1])\n\t\t\t\t\t\n                else:\n                    profit = max(prices[ind] + dp[ind+2][1], 0 + dp[ind+1][0])\n                    \n                dp[ind][buy] = profit\n\t\t\t\t\n            ind -= 1    \n\t\t\t\n        return dp[0][1]"}
{"prompt": "def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\n        if n == 1:\n            return [0]\n        graph = {i:[] for i in range(n)}\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        leaves = []\n        for node in graph:\n            if len(graph[node]) == 1:\n                leaves.append(node)\n        \n        while len(graph) > 2:\n            new_leaves = []\n            for leaf in leaves:\n                nei = graph[leaf].pop()\n                del graph[leaf]\n                graph[nei].remove(leaf)\n                if len(graph[nei]) == 1:\n                    new_leaves.append(nei)\n            leaves = new_leaves\n        \n        return leaves"}
{"prompt": "def maxCoins(self, nums):\n        n=len(nums)\n        nums.insert(n,1)\n        nums.insert(0,1)\n        self.dp={}\n        return self.dfs(1,nums,n)\n    def dfs(self,strt,nums,end):\n        ans=0\n        if strt>end:\n            return 0\n        if (strt,end) in self.dp:\n            return self.dp[(strt,end)]\n        for i in range(strt,end+1):\n            lmax=self.dfs(strt,nums,i-1)\n            rmax=self.dfs(i+1,nums,end)\n            curr_coins=nums[strt-1]*nums[i]*nums[end+1]+lmax+rmax\n            ans=max(ans,curr_coins)\n        self.dp[(strt,end)]=ans\n        return self.dp[(strt,end)]"}
{"prompt": "def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:\n        hp=[1]\n        dc={1}\n        i=1\n        while(n):\n            mn=heapq.heappop(hp)\n            if(n==1):\n                return mn\n            for p in primes:\n                newno=mn*p\n                if(newno in dc):\n                    continue\n                heapq.heappush(hp,newno)\n                dc.add(newno)\n            n-=1"}
{"prompt": "# Here's the plan:\n                    #   1) Make arr, a sorted copy of the list nums.\n                    #   2) iterate through nums. For each element num in nums:\n                    #       2a) use a binary search to determine the count of elements\n                    #         in the arr that are less than num.\n                    #       2b) append that count to the answer list\n                    #       2c) delete num from arr\n                    #   3) return the ans list \n                    #   \n                    #   For example, suppose nums = [5,2,6,1] Then arr = [1,2,5,6].\n                    #       num = 5 => binsearch: arr = [1,2,/\\5,6], i = 2 => ans = [2,_,_,_], del 5\n                    #       num = 2 => binsearch: arr = [1,/\\2,6],   i = 1 => ans = [2,1,_,_], del 2\n                    #       num = 6 => binsearch: arr = [1,/\\6],     i = 1 => ans = [2,1,1,_], del 6\n                    #       num = 1 => binsearch: arr = [/\\1],       i = 0 => ans = [2,1,1,0], del 1\n\n    def countSmaller(self, nums: List[int]) -> List[int]:\n        arr, ans = sorted(nums), []     #   <-- 1)\n        \n        for num in nums:\n            i = bisect_left(arr,num)    #   <-- 2a)\n            ans.append(i)               #   <-- 2b)\n            del arr[i]                  #   <-- 2c)\n            \n        return ans                      #   <-- 3)"}
{"prompt": "def removeDuplicateLetters(self, s: str) -> str:\n        stack = []\n        \n        for idx, character in enumerate(s):\n            if not stack:\n                stack.append(character)\n            elif character in stack:\n                continue\n            else:\n                while stack and (character < stack[-1]):\n                    if stack[-1] in s[idx + 1:]:\n                        _ = stack.pop()\n                    else:\n                        break\n                        \n                stack.append(character)\n                \n        return ''.join(stack)"}
{"prompt": "def maxProduct(self, words: List[str]) -> int:\n        n=len(words)                        \n        char_set = [set(words[i]) for i in range(n)] # precompute hashset for each word                                                  \n        max_val = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                if not (char_set[i] &amp; char_set[j]): # if nothing common\n                    max_val=max(max_val, len(words[i]) * len(words[j]))\n        \n        return max_val"}
{"prompt": "def bulbSwitch(self, n: int) -> int:\n        \n        # Only those bulds with perferct square number index will keep \"ON\" at last.\n        \n        return int(n**0.5)"}
{"prompt": "def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\n        def maximum_num_each_list(nums: List[int], k_i: int) -> List[int]:\n            # monotonically decreasing stack\n            s = []\n            m = len(nums) - k_i\n            for n in nums:\n                while s and s[-1] < n and m > 0:\n                    s.pop()\n                    m -= 1\n                s.append(n)\n            s = s[:len(s)-m] # very important\n            return s\n        def greater(a, b, i , j): # get the number which is lexiographically greater\n            while i< len(a) or j < len(b): \n                if i == len(a): return False\n                if j == len(b): return True\n                if a[i] > b[j]: return True\n                if a[i] < b[j]: return False\n                i += 1 # we increment until each of their elements are same\n                j += 1\n        \n        def merge(x_num, y_num):\n            n = len(x_num)\n            m = len(y_num)\n            i = 0\n            j = 0\n            s = []\n            while i < n or j < m:\n                a = x_num[i] if i < n else float(\"-inf\") \n                b = y_num[j] if j < m else float(\"-inf\") \n\n                if a > b or greater(x_num, y_num, i , j):\n# greater(x_num, y_num, i , j): this function is meant for check which list has element lexicographically greater means it will iterate through both arrays incrementing both at the same time until one of them is greater than other.\n                    chosen = a\n                    i += 1\n                else:\n                    chosen = b\n                    j += 1\n                s.append(chosen)\n            return s\n\n        max_num_arr = []\n        for i in range(k+1): # we check for all values of k and find the maximum number we can create for that value of k and we repeat this for all values of k and then at eacch time merge the numbers to check if arrive at optimal solution\n            first = maximum_num_each_list(nums1, i)\n            second = maximum_num_each_list(nums2, k-i)\n            merged = merge(first, second)\n            # these two conditions are required because list comparison in python only compares the elements even if one of their lengths is greater, so I had to add these conditions to compare elements only if length is equal.\n\t\t\t# Alternatively you can avoid this and convert them both to int and then compare, but I wanted to this as  it is somewhat more efficient.\n            if len(merged) == len(max_num_arr) and  merged > max_num_arr:\n                max_num_arr = merged\n            elif len(merged) > len(max_num_arr):\n                max_num_arr = merged\n        return max_num_arr"}
{"prompt": "def coinChange(self, coins: List[int], amount: int) -> int:        \n        dp=[math.inf] * (amount+1)\n        dp[0]=0\n        \n        for coin in coins:\n            for i in range(coin, amount+1):\n                if i-coin>=0:\n                    dp[i]=min(dp[i], dp[i-coin]+1)\n        \n        return -1 if dp[-1]==math.inf else dp[-1]"}
{"prompt": "def wiggleSort(self, nums: List[int]) -> None:\n        sortedList = sorted(nums)\n        n = len(nums)\n        if n%2==0:\n            small = sortedList[:((n//2))][::-1]\n            large = (sortedList[(n//2):])[::-1]\n            for i in range(1,n,2):\n                nums[i] = large[i//2]\n            for i in range(0,n,2):\n                nums[i] = small[i//2]\n        else:\n            small = sortedList[:1+((n//2))][::-1]\n            large = (sortedList[1+(n//2):])[::-1]\n            for i in range(1,n,2):\n                nums[i] = large[i//2]\n            for i in range(0,n,2):\n                nums[i] = small[i//2]"}
{"prompt": "def isPowerOfThree(self, n: int) -> bool:\n        if n == 1:\n            return True\n        if n == 0:\n            return False\n        else:\n            return n % 3 == 0 and self.isPowerOfThree(n // 3)"}
{"prompt": "def countRangeSum(self, nums: List[int], lower: int, upper: int) -> int:\n        prefix = [0]\n        for x in nums: prefix.append(prefix[-1] + x)\n        \n        def fn(lo, hi): \n            \"\"\"Return count of range sum between prefix[lo:hi].\"\"\"\n            if lo+1 >= hi: return 0 \n            mid = lo + hi >> 1\n            ans = fn(lo, mid) + fn(mid, hi)\n            k = kk = mid \n            for i in range(lo, mid): \n                while k < hi and prefix[k] - prefix[i] < lower: k += 1\n                while kk < hi and prefix[kk] - prefix[i] <= upper: kk += 1\n                ans += kk - k \n            prefix[lo:hi] = sorted(prefix[lo:hi])\n            return ans \n        \n        return fn(0, len(prefix))"}
{"prompt": "def oddEvenList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if(head is None or  head.next is None):\n            return head\n        # assign odd = head(starting node of ODD)\n        # assign even = head.next(starting node of EVEN)\n        odd  , even  =  head , head.next\n        \n        Even = even # keep starting point of Even Node so later we will connect with Odd Node\n        while(odd.next and even.next):\n            odd.next = odd.next.next # Connect odd.next to odd Node\n            even.next = even.next.next # Connect even,next to Even Node\n            \n            odd = odd.next # move odd \n            even = even.next # move even\n        \n        odd.next = Even # now connect odd.next to starting point to Even list\n        \n        return head"}
{"prompt": "def longestIncreasingPath(self, grid: List[List[int]]) -> int:\n        m,n=len(grid),len(grid[0])\n        directions = [0, 1, 0, -1, 0] # four directions \n        \n        @lru_cache(maxsize=None) # using python cache lib for memoization\n        def dfs(r,c):\n            ans=1                  \n\t\t\t# iterating through all 4 directions\n            for i in range(4): \n                new_row,new_col=r+directions[i], c+directions[i+1] # calculating the new cell\n\t\t\t\t# check if new cell is within the grid bounds and is an increasing sequence\n                if 0<=new_row<m and 0<=new_col<n and grid[new_row][new_col]>grid[r][c]: \n                    ans = max(ans, dfs(new_row, new_col) + 1 )  # finding the max length of valid path from the current cell                                      \n            return ans\n        \n        return max(dfs(r,c) for r in range(m) for c in range(n))"}
{"prompt": "def minPatches(self, nums: List[int], n: int) -> int:\n\t\tans, total = 0, 0\n\t\tnum_idx = 0\n\t\twhile total < n:\n\t\t\tif num_idx < len(nums):\n\t\t\t\tif total < nums[num_idx] - 1:\n\t\t\t\t\ttotal = total * 2 + 1\n\t\t\t\t\tans += 1\n\t\t\t\telse:\n\t\t\t\t\ttotal += nums[num_idx]\n\t\t\t\t\tnum_idx += 1\n\t\t\telse:\n\t\t\t\ttotal = total * 2 + 1\n\t\t\t\tans += 1\n\t\treturn ans"}
{"prompt": "def isValidSerialization(self, preorder: str) -> bool:\n        stack = []\n        items = preorder.split(\",\")\n        for i, val in enumerate(items):\n            if i>0 and not stack:\n                return False\n            if stack:\n                stack[-1][1] -= 1\n                if stack[-1][1] == 0:\n                    stack.pop()\n            if val != \"#\":\n                stack.append([val, 2])\n        return not stack"}
{"prompt": "def __init__(self):\n        self.path = []\n    \n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        flights = {}\n        \n        # as graph is directed\n        # => no bi-directional paths\n        for t1, t2 in tickets:\n            if t1 not in flights:\n                flights[t1] = []\n                \n            flights[t1].append(t2)\n\n        visited = {}\n        for k, v in flights.items():\n            v.sort()\n            visited[k] = [False for _ in range(len(v))]\n        \n        base_check = len(tickets) + 1\n        routes = ['JFK']\n        self.dfs('JFK', routes, base_check, flights, visited)\n        \n        return self.path\n        \n        \n    def dfs(self, curr, routes, base_check, flights, visited):\n        if len(routes) == base_check:\n            self.path = routes\n            return True\n        \n        # deadlock\n        if curr not in flights:\n            return False\n        \n        for idx in range(len(flights[curr])):\n            if not visited[curr][idx]:\n                visited[curr][idx] = True\n                \n                next_airport = flights[curr][idx]\n                routes += [next_airport]\n                result = self.dfs(next_airport, routes, base_check,\n                                    flights, visited)\n                \n                if result:\n                    return True\n                routes.pop()\n                visited[curr][idx] = False\n\n        return False"}
{"prompt": "def increasingTriplet(self, nums: List[int]) -> bool:\n        n = len(nums)\n        maxRight = [0] * n  # maxRight[i] is the maximum element among nums[i+1...n-1]\n        maxRight[-1] = nums[-1]\n        for i in range(n-2, -1, -1):\n            maxRight[i] = max(maxRight[i+1], nums[i+1])\n            \n        minLeft = nums[0]\n        for i in range(1, n-1):\n            if minLeft < nums[i] < maxRight[i]:\n                return True\n            minLeft = min(minLeft, nums[i])\n        return False"}
{"prompt": "def isSelfCrossing(self, x: List[int]) -> bool:\n        def intersect(p1, p2, p3, p4):\n            v1 = p2 - p1\n            if v1.real == 0:\n                return p1.imag <= p3.imag <= p2.imag and p3.real <= p1.real <= p4.real\n            return p3.imag <= p1.imag <= p4.imag and p1.real <= p3.real <= p2.real\n        \n        def overlap(p1, p2, p3, p4):\n            v1 = p2 - p1\n            if v1.real == 0:\n                return min(p2.imag, p4.imag) >= max(p1.imag, p3.imag) and p1.real == p3.real\n            return min(p2.real, p4.real) >= max(p1.real, p3.real) and p1.imag == p3.imag\n                \n        uv = complex(0, 1)\n        p = complex(0, 0)\n        segments = deque()\n        for s in x:\n            segments.append(sorted([p, (np := p + uv * s)], key=lambda x:(x.real, x.imag)))\n            if len(segments) > 5 and intersect(*segments[-1], *segments[-6]):\n                    return True\n            if len(segments) > 4 and overlap(*segments[-1], *segments[-5]):\n                    return True\n            if len(segments) > 3 and intersect(*segments[-1], *segments[-4]):\n                    return True\n            if len(segments) == 6:\n                segments.popleft()\n            p = np\n            uv *= complex(0, 1)\n        return False"}
{"prompt": "def palindromePairs(self, words: List[str]) -> List[List[int]]:\n        backward, res = {}, []\n        for i, word in enumerate(words):\n            backward[word[::-1]] = i\n\n        for i, word in enumerate(words):\n            \n            if word in backward and backward[word] != i:\n                res.append([i, backward[word]])\n                \n            if word != \"\" and \"\" in backward and word == word[::-1]:\n                res.append([i, backward[\"\"]])\n                res.append([backward[\"\"], i])\n                \n            for j in range(len(word)):\n                if word[j:] in backward and word[:j] == word[j-1::-1]:\n                    res.append([backward[word[j:]], i])\n                if word[:j] in backward and word[j:] == word[:j-1:-1]:\n                    res.append([i, backward[word[:j]]])\n                    \n        return res"}
{"prompt": "def rob(self, root: TreeNode) -> int:\n        def dfs(node):\n            if not node: return 0, 0\n            left, right = dfs(node.left), dfs(node.right)\n            v_take = node.val + left[1] + right[1]\n            v_not_take = max(left) + max(right)\n            return v_take, v_not_take\n        return max(dfs(root))"}
{"prompt": "def countBits(self, N: int) -> List[int]:\n        stem = [0]\n        while len(stem) < N+1:\n            stem.extend([s + 1 for s in stem])\n            \n        return stem[:N+1]"}
{"prompt": "def isPowerOfFour(self, num: int) -> bool:\n        return num > 0 and not num &amp; (num - 1)  and len(bin(num)) % 2"}
{"prompt": "def integerBreak(self, n: int) -> int:\n        if(n<=3):\n            return n-1\n        n3=n//3\n        r3=n%3\n        if(r3==0):\n            return 3**n3\n        if(r3==1):\n            r3=4\n            n3-=1\n        return r3*(3**n3)"}
{"prompt": "def reverseString(self, s: List[str]) -> None:\n        s[:] = s[::-1]"}
{"prompt": "def reverseVowels(self, s: str) -> str:\n        s = list(s)\n        left = 0\n        right = len(s) - 1\n        m = 'aeiouAEIOU'\n        while left < right:\n            if s[left] in m and s[right] in m:\n                \n                s[left], s[right] = s[right], s[left]\n                \n                left += 1; right -= 1\n            \n            elif s[left] not in m:\n                left += 1\n            \n            elif s[right] not in m:\n                right -= 1\n            \n        return ''.join(s)"}
{"prompt": "def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n\n\t\tfrequency = {}\n\n\t\tfor num in nums:\n\n\t\t\tif num not in frequency:\n\n\t\t\t\tfrequency[num] = 1\n\n\t\t\telse:\n\n\t\t\t\tfrequency[num] = frequency[num] + 1\n\n\t\tfrequency = dict(sorted(frequency.items(), key=lambda x: x[1], reverse=True))\n\n\t\tresult = list(frequency.keys())[:k]\n\n\t\treturn result"}
{"prompt": "def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        a = []\n        for i in nums1:\n            if i not in a and i in nums2:\n                a.append(i)\n        return a"}
{"prompt": "def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        \n        nums1.sort()\n        nums2.sort()\n        \n        \n        one=0\n        two=0\n        \n        ans=[]\n        \n        while one < len(nums1) and two < len(nums2):\n            \n            if nums1[one] < nums2[two]:\n                one+=1\n            elif nums2[two] < nums1[one]:\n                two+=1\n            else:\n                \n                ans.append(nums1[one])\n                one+=1\n                two+=1\n        return ans"}
{"prompt": "def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        \n        res = []\t\t\n\t\t# Perform LIS\n        for _, h in envelopes:\n            l,r=0,len(res)-1\n\t\t\t# find the insertion point in the Sort order\n            while l <= r:\n                mid=(l+r)>>1\n                if res[mid]>=h:\n                    r=mid-1\n                else:\n                    l=mid+1        \n            idx = l\n            if idx == len(res):\n                res.append(h)\n            else:\n                res[idx]=h\n        return len(res)"}
{"prompt": "def countNumbersWithUniqueDigits(self, n: int) -> int:\n        if n == 0: return 1\n        if n == 1: return 10\n\n        res = 91\n        mult = 8\n        comb = 81\n        for i in range(n - 2):\n            comb *=  mult\n            mult -= 1\n            res += comb\n\n        return res"}
{"prompt": "def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\n        ans = float(\"-inf\")\n        m, n = len(matrix), len(matrix[0])\n        for i in range(n):\n            lstSum = [0] * m\n            for j in range(i, n):\n                currSum = 0\n                curlstSum = [0]\n                for t in range(m):\n                    lstSum[t] += matrix[t][j]\n                    currSum += lstSum[t]\n                    pos = bisect_left(curlstSum, currSum - k)\n                    if pos < len(curlstSum):\n                        if curlstSum[pos] == currSum - k:\n                            return k\n                        else:\n                            ans = max(ans, currSum - curlstSum[pos])\n                    insort(curlstSum, currSum)\n        return ans"}
{"prompt": "def canMeasureWater(self, x: int, y: int, z: int) -> bool:\n        return False if x + y < z else True if x + y == 0 else not z % math.gcd(x,y)\n\t\t\n\t\t\n- Junaid Mansuri\n(LeetCode ID)@hotmail.com"}
{"prompt": "def isPerfectSquare(self, num: int) -> bool:\n        return int(num**0.5) == num**0.5"}
{"prompt": "def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\n        if not nums or len(nums) == 0:\n            return []\n\n        # since we are doing a \"subset\" question\n        # sorting does not make any differences\n        nums.sort()\n        n = len(nums)\n\n        # initilization\n        # f[i] represents the size of LDS ended with nums[i]\n        f = [1 for _ in range(n)]\n        for i in range(1, n):\n            for j in range(i):\n                # since we have already sorted,\n                # then nums[j] % nums[i] will never equals zero\n                # unless nums[i] == nums[j]\n                if nums[i] % nums[j] == 0:\n                    f[i] = max(f[i], f[j] + 1)\n\n        # extract result from dp array\n        max_size = max(f)\n        max_idx = f.index(max_size) # since we can return one of the largest\n        prev_num, prev_size = nums[max_idx], f[max_idx]\n        res = [prev_num]\n        for curr_idx in range(max_idx, -1, -1):\n            if prev_num % nums[curr_idx] == 0 and f[curr_idx] == prev_size - 1:\n                # update\n                res.append(nums[curr_idx])\n                prev_num = nums[curr_idx]\n                prev_size = f[curr_idx]\n\n        return res[::-1]"}
{"prompt": "def getSum(self, a: int, b: int) -> int:\n        return int(math.log2(2**a * 2**b))"}
{"prompt": "def superPow(self, a: int, b: List[int]) -> int:\n        return (a % 1337)**(1140 + int(''.join(map(str, b))) % 1140) % 1337\n\t\t\n\t\t\n- Junaid Mansuri"}
{"prompt": "def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n        hq = []\n        heapq.heapify(hq)\n        \n        # add all the pairs that we can form with\n        # all the (first k) items in nums1 with the first\n        # item in nums2\n        for i in range(min(len(nums1), k)):\n            heapq.heappush(hq, (nums1[i]+nums2[0], nums1[i], nums2[0], 0))\n\n        # since the smallest pair will\n        # be the first element from both nums1 and nums2. We'll\n        # start with that and then subsequently, we'll pop it out\n        # from the heap and also insert the pair of the current\n        # element from nums1 with the next nums2 element\n        out = []\n        while k > 0 and hq:\n            _, n1, n2, idx = heapq.heappop(hq)\n            out.append((n1, n2))\n            if idx + 1 < len(nums2):\n                # the heap will ensure that the smallest element\n                # based on the sum will remain on top and the\n                # next iteration will give us the pair we require\n                heapq.heappush(hq, (n1+nums2[idx+1], n1, nums2[idx+1], idx+1))\n            k -= 1\n                \n        return out"}
{"prompt": "def guessNumber(self, n: int) -> int:\n        return __pick__"}
{"prompt": "def getMoneyAmount(self, n: int) -> int:\n        if n == 1:\n            return 1\n        starting_index = 1 if n % 2 == 0 else 2\n        selected_nums = [i for i in range(starting_index, n, 2)]\n        selected_nums_length = len(selected_nums)\n        dp = [[0] * selected_nums_length for _ in range(selected_nums_length)]\n\n        for i in range(selected_nums_length):\n            dp[i][i] = selected_nums[i]\n\n        for length in range(2, selected_nums_length + 1):\n            for i in range(selected_nums_length - length + 1):\n                j = i + length - 1\n                dp[i][j] = float(\"inf\")\n                for k in range(i, j + 1):\n                    dp_left = dp[i][k - 1] if k != 0 else 0\n                    dp_right = dp[k + 1][j] if k != j else 0\n                    dp[i][j] = min(dp[i][j], selected_nums[k] + max(dp_left, dp_right))\n\n        return dp[0][-1]"}
{"prompt": "def wiggleMaxLength(self, nums: List[int]) -> int:\n        length = 0\n        curr = 0\n        \n        for i in range(len(nums) - 1):\n            if curr == 0 and nums[i + 1] - nums[i] != 0:\n                length += 1\n                curr = nums[i + 1] - nums[i]\n                \n            if curr < 0 and nums[i + 1] - nums[i] > 0:\n                length += 1\n                curr = nums[i + 1] - nums[i]\n                \n            elif curr > 0 and nums[i + 1] - nums[i] < 0:\n                length += 1\n                curr = nums[i + 1] - nums[i]\n                \n            else:\n                continue\n                \n        return length + 1"}
{"prompt": "def combinationSum4(self, nums: List[int], target: int) -> int:\n        waysToAdd = [0 for x in range(target+1)]\n        waysToAdd[0] = 1\n        \n        for i in range(min(nums), target+1):\n            waysToAdd[i] = sum(waysToAdd[i-num] for num in nums if i-num >= 0)\n        \n        return waysToAdd[-1]"}
{"prompt": "def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        def count(m):\n            c = 0                   # count of element less than equals to 'm'\n            i = n-1\n            j = 0\n            \n            while i >= 0 and j < n:\n                if matrix[i][j] > m:\n                    i -= 1\n                else:\n                    c += i+1\n                    j += 1\n            return c\n           \n        \n        low = matrix[0][0]\n        high = matrix[n-1][n-1]\n        \n        while low <= high:\n            m = (low+high)//2\n            cnt = count(m)\n            if cnt < k:\n                low = m + 1\n            else:\n                cnt1 = count(m-1)\n                if cnt1 < k:\n                    return m\n                high = m-1\n        return 0"}
{"prompt": "def __init__(self, head: ListNode):\n        \"\"\"\n        @param head The linked list's head.\n        Note that the head is guaranteed to be not null, so it contains at least one node.\n        \"\"\"\n        self.head = head # store head of linked list \n\n    def getRandom(self) -> int:\n        \"\"\"\n        Returns a random node's value.\n        \"\"\"\n        cnt = 0\n        node = self.head \n        while node: \n            cnt += 1\n            if randint(1, cnt) == cnt: ans = node.val # reservoir sampling \n            node = node.next \n        return ans"}
{"prompt": "def canConstruct(self, ransomNote, magazine):\n        for i in set(ransomNote):\n            if magazine.count(i) < ransomNote.count(i):\n                return False\n        return True"}
{"prompt": "def __init__(self, nums: List[int]):\n\t\tself.arr = nums[:]  # Deep Copy, Can also use Shallow Copy concept!\n\t\t# self.arr = nums  # Shallow Copy would be something like this!\n\n\tdef reset(self) -> List[int]:\n\t\treturn self.arr\n\n\tdef shuffle(self) -> List[int]:\n\t\tans = self.arr[:]\n\t\tfor i in range(len(ans)):\n\t\t\tswp_num = random.randrange(i, len(ans))  # Fisher-Yates Algorithm\n\t\t\tans[i], ans[swp_num] = ans[swp_num], ans[i]\n\t\treturn ans"}
{"prompt": "def deserialize(self, s: str) -> NestedInteger:\n        if not s: return NestedInteger()\n        if not s.startswith(\"[\"): return NestedInteger(int(s)) # integer \n        ans = NestedInteger()\n        s = s[1:-1] # strip outer \"[\" and \"]\"\n        if s: \n            ii = op = 0 \n            for i in range(len(s)): \n                if s[i] == \"[\": op += 1\n                if s[i] == \"]\": op -= 1\n                if s[i] == \",\" and op == 0: \n                    ans.add(self.deserialize(s[ii:i]))\n                    ii = i+1\n            ans.add(self.deserialize(s[ii:i+1]))\n        return ans"}
{"prompt": "def lexicalOrder(self, n: int) -> List[int]:\n        return sorted([x for x in range(1,n+1)],key=lambda x: str(x))"}
{"prompt": "def firstUniqChar(self, s: str) -> int:\n\n\t\tfor i in range(len(s)):\n\n\t\t\tif s[i] not in s[:i] and s[i] not in s[i+1:]:\n\n\t\t\t\treturn i\n\n\t\treturn -1"}
{"prompt": "def lengthLongestPath(self, s: str) -> int:\n        paths, stack, ans = s.split('\\n'), [], 0\n        for path in paths:\n            p = path.split('\\t')\n            depth, name = len(p) - 1, p[-1]\n            l = len(name)\n            while stack and stack[-1][1] >= depth: stack.pop()\n            if not stack: stack.append((l, depth))\n            else: stack.append((l+stack[-1][0], depth))\n            if '.' in name: ans = max(ans, stack[-1][0] + stack[-1][1])   \n        return ans"}
{"prompt": "def findTheDifference(self, s: str, t: str) -> str:\n    \ts, t = sorted(s), sorted(t)\n    \tfor i,j in enumerate(s):\n    \t\tif j != t[i]: return t[i]\n    \treturn t[-1]"}
{"prompt": "def lastRemaining(self, n: int) -> int:\n        if n == 1: return 1\n        if n&amp;1: n -= 1\n        return n + 2 - 2*self.lastRemaining(n//2)"}
{"prompt": "def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\n        \n        area = 0\n        corners = set()\n        a = lambda: (Y-y) * (X-x)\n        \n        for x, y, X, Y in rectangles:\n            area += a()\n            corners ^= {(x,y), (x,Y), (X,y), (X,Y)}\n\n        if len(corners) != 4: return False\n        x, y = min(corners, key=lambda x: x[0] + x[1])\n        X, Y = max(corners, key=lambda x: x[0] + x[1])\n        return a() == area"}
{"prompt": "def isSubsequence(self, s, t):\n        # Base case\n        if not s:\n            return True\n        i = 0\n        # Traverse elements of t string\n        for j in t:\n            # If this index matches to the index of s string, increment i pointer...\n            if j == s[i]:\n                i += 1\n            # If the pointer is equal to the size of s...\n            if i == len(s):\n                break\n        return i == len(s)"}
{"prompt": "def validUtf8(self, data: List[int]) -> bool:\n        n = len(data)\n        l = [2**i for i in range(7, -1, -1)]\n        \n        def isXByteSeq(pos, X):\n            f = data[pos]\n            rem = data[pos+1:pos+X]\n            ret = (f&amp;l[X]) == 0\n            for i in range(X):\n                ret &amp;= (f&amp;l[i]) != 0\n            for num in rem:\n                ret &amp;= (num&amp;l[0]) != 0\n                ret &amp;= (num&amp;l[1]) == 0\n            return ret\n            \n        @cache\n        def res(pos = 0):\n            ret = False\n            if pos == n:\n                ret = True\n            if pos + 3 < n:\n                ret |= isXByteSeq(pos, 4) and res(pos + 4)\n            if pos + 2 < n:\n                ret |= isXByteSeq(pos, 3) and res(pos + 3)\n            if pos + 1 < n:\n                ret |= isXByteSeq(pos, 2) and res(pos + 2)\n            if pos < n:\n                ret |= isXByteSeq(pos, 0) and res(pos + 1)\n            return ret\n        \n        return res()"}
{"prompt": "def decodeString(self, s: str) -> str:\n    \n    res,num = \"\",0\n    st = []\n    for c in s:\n        if c.isdigit():\n            num = num*10+int(c)    \n        elif c==\"[\":\n            st.append(res)\n            st.append(num)\n            res=\"\"\n            num=0\n        elif c==\"]\":\n            pnum = st.pop()\n            pstr = st.pop()\n            res = pstr + pnum*res\n        else:\n            res+=c\n    \n    return res"}
{"prompt": "def rec(self, s, k):\n        c = Counter(s)\n\n        if pattern := \"|\".join(filter(lambda x: c[x] < k, c)):\n            if arr := list(filter(lambda x: len(x) >= k, re.split(pattern, s))):\n            \n                return max(map(lambda x: self.rec(x, k), arr))\n            \n            return 0\n        \n        return len(s)\n    \n    def longestSubstring(self, s: str, k: int) -> int:\n        return self.rec(s, k)"}
{"prompt": "def maxRotateFunction(self, A: List[int]) -> int:\n        s, n = sum(A), len(A)\n        cur_sum = sum([i*j for i, j in enumerate(A)])\n        ans = cur_sum\n        for i in range(n): ans = max(ans, cur_sum := cur_sum + s-A[n-1-i]*n)\n        return ans"}
{"prompt": "def integerReplacement(self, n: int) -> int:\n        cnt = 0\n        while n != 1:\n            if n%2 == 0:\n                n//=2\n            elif n%4 == 1 or n == 3:\n                n -= 1\n            else:\n                n += 1\n            cnt += 1\n        return cnt"}
{"prompt": "def __init__(self, nums: List[int]):\n        # Reservoir Sampling (which can handle the linked list with unknown size), time complexity O(n) (init: O(1), pick: O(n)), space complextiy O(1)\n        self.nums = nums\n\n    def pick(self, target: int) -> int:\n        # https://docs.python.org/3/library/random.html\n        count = 0\n        chosen_index = None\n        for i in range(len(self.nums)):\n            if self.nums[i] != target:\n                continue\n            count += 1\n            if count == 1:\n                chosen_index = i\n            elif random.random() < 1 / count:\n                chosen_index = i\n        return chosen_index"}
{"prompt": "def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\n        graph = {}\n        for (u, v), w in zip(equations, values): \n            graph.setdefault(u, []).append((v, 1/w))\n            graph.setdefault(v, []).append((u, w))\n\n        def dfs(n, g, val=1):\n            \"\"\"Depth-first traverse the graph.\"\"\"\n            if n in vals: return \n            vals[n] = val, g\n            for nn, w in graph.get(n, []): dfs(nn, g, w*val)\n    \n        vals = dict()\n        for i, n in enumerate(graph): dfs(n, i)\n        \n        ans = []\n        for u, v in queries: \n            if u in vals and v in vals and vals[u][1] == vals[v][1]: ans.append(vals[u][0]/vals[v][0])\n            else: ans.append(-1)\n        return ans"}
{"prompt": "def findNthDigit(self, n: int) -> int:\n        digit = base = 1 # starting from 1 digit\n        while n > 9*base*digit: # upper limit of d digits \n            n -= 9*base*digit\n            digit += 1\n            base *= 10 \n        q, r = divmod(n-1, digit)\n        return int(str(base + q)[r])"}
{"prompt": "def readBinaryWatch(self, n: int) -> List[str]:\n    \treturn [str(h)+':'+'0'*(m<10)+str(m) for h in range(12) for m in range(60) if (bin(m)+bin(h)).count('1') == n]"}
{"prompt": "def removeKdigits(self, num: str, k: int) -> str:\n        st = list()\n        for n in num:\n            while st and k and st[-1] > n:\n                st.pop()\n                k -= 1\n            \n            if st or n is not '0': # prevent leading zeros\n                st.append(n)\n                \n        if k: # not fully spent\n\t\t\tst = st[0:-k]\n            \n        return ''.join(st) or '0'"}
{"prompt": "def canCross(self, stones):\n        n = len(stones)\n        stoneSet = set(stones)\n        visited = set()\n        def goFurther(value,units):\n            if (value+units not in stoneSet) or ((value,units) in visited):\n                return False\n            if value+units == stones[n-1]:\n                return True\n            visited.add((value,units))\n            return goFurther(value+units,units) or goFurther(value+units,units-1) or goFurther(value+units,units+1)\n        return goFurther(stones[0],1)"}
{"prompt": "def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n\n        # does this node have a left child which is a leaf?\n        if root.left and not root.left.left and not root.left.right:\n\t\t\t# gotcha\n            return root.left.val + self.sumOfLeftLeaves(root.right)\n\n        # no it does not have a left child or it's not a leaf\n        else:\n\t\t\t# bummer\n            return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)"}
{"prompt": "def toHex(self, num: int) -> str:\n        hex=\"0123456789abcdef\" #created string for reference\n        ot=\"\" # created a string variable to store and update output string\n        if num==0:\n            return \"0\"\n        elif num<0:\n            num+=2**32\n        while num:\n            ot=hex[num%16]+ot # we update the output string with the reminder of num/16 , 16 because we are dealing with hex.\n            num//=16 # now we are updating num by dividing it by 16 ***// operator used for floor division , means division will be always integer not float.\n        return ot # then we simply return ot"}
{"prompt": "def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:\n        output=[] \n        \n        # sort the array in decreasing order of height \n        # within the same height group, you would sort it in increasing order of k\n        # eg: Input : [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]\n        # after sorting: [[7,0],[7,1],[6,1],[5,0],[5,2],[4,4]]\n        people.sort(key=lambda x: (-x[0], x[1]))                \n        for a in people:\n            # Now let's start the greedy here\n            # We insert the entry in the output array based on the k value\n            # k will act as a position within the array\n            output.insert(a[1], a)\n        \n        return output"}
{"prompt": "def trapRainWater(self, heightMap: List[List[int]]) -> int:\n        if not heightMap or not heightMap[0]:\n            return 0\n\t\t\t\n\t\t\t\n\t\t# Initial\n\t\t# Board cells cannot trap the water\n        m, n = len(heightMap), len(heightMap[0])\n        if m < 3 or n < 3:\n            return 0\n\t\t\t\n\t\t\t\n\t\t# Add Board cells first\n        heap = []\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m - 1 or j == 0 or j == n - 1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    heightMap[i][j] = -1\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t# Start from level 0\n        level, res = 0, 0\n        \n\t\twhile heap:\n            height, x, y = heapq.heappop(heap)\n            level = max(height, level)\n\n            for i, j in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]:\n                if 0 <= i < m and 0 <= j < n and heightMap[i][j] != -1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n\t\t\t\t\t\n\t\t\t\t\t# If cell's height smaller than the level, then it can trap the rain water\n                    if heightMap[i][j] < level:\n                        res += level - heightMap[i][j]\n\t\t\t\t\t\t\n\t\t\t\t\t# Set the height to -1 if the cell is visited\n                    heightMap[i][j] = -1\n\n        return res"}
{"prompt": "def longestPalindrome(self, s: str) -> int:\n        oddFlag=0\n        \n        count=collections.Counter(s)\n\n        ans=0\n        for k,v in count.items():\n            if v%2==1:\n                ans+=v-1\n                oddFlag= 1\n            else:\n                ans+=v\n                \n        if oddFlag == 1:\n            return ans+1\n        return ans"}
{"prompt": "def splitArray(self, nums: List[int], m: int) -> int:\n        def isPossible(maxSum):\n            curr = count = 0\n            for i in nums:\n                count += (i + curr > maxSum)\n                curr = curr + i if i + curr <= maxSum else i\n            return count + 1 <= m\n        \n        lo, hi = max(nums), sum(nums)\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if isPossible(mid): hi = mid - 1\n            else: lo = mid + 1\n        return lo"}
{"prompt": "def fizzBuzz(self, n: int) -> List[str]:\n    \treturn ['FizzBuzz' if i%15 == 0 else 'Buzz' if i%5 == 0 else 'Fizz' if i%3 == 0 else str(i) for i in range(1,n+1)]\n\t\t\n\t\t\n- Junaid Mansuri\n(LeetCode ID)@hotmail.com"}
{"prompt": "def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        count = 0\n        for i in range(len(nums)-2):\n            j = i+1\n            while(j<len(nums)-1):\n                if nums[j]-nums[j-1] == nums[j+1]-nums[j]:\n                    count += 1\n                    j += 1\n                else:\n                    break\n        return count"}
{"prompt": "def thirdMax(self, nums: List[int]) -> int:\n    \tn, T = list(set(nums)), [float('-inf')]*3\n    \tfor i in n:\n    \t\tif i > T[0]:\n    \t\t\tT = [i,T[0],T[1]]\n    \t\t\tcontinue\n    \t\tif i > T[1]:\n    \t\t\tT = [T[0],i,T[1]]\n    \t\t\tcontinue\n    \t\tif i > T[2]:\n    \t\t\tT = [T[0],T[1],i]\n    \treturn T[2] if T[2] != float('-inf') else T[0]\n\t\t\n\t\t\n- Junaid Mansuri"}
{"prompt": "def addStrings(self, num1: str, num2: str) -> str:\n\t\tnum1 = list(num1)\n\t\tnum2 = list(num2)\n\t\tcar = 0\n\t\tres = \"\"\n\t\twhile num1 or num2 or car:\n\t\t\tif num1:\n\t\t\t\tcar += int(num1.pop())\n\t\t\tif num2:\n\t\t\t\tcar += int(num2.pop())\n\t\t\tres += str((car % 10))\n\t\t\tcar //= 10\n\t\treturn res[::-1]"}
{"prompt": "def canPartition(self, nums: List[int]) -> bool:\n\t    if sum(nums)%2:  # or if sum(nums)&amp;1\n\t\t    return False\n\t\t# main logic here"}
{"prompt": "def pacificAtlantic(self, ht: List[List[int]]) -> List[List[int]]:\n        \n        def pac(i,j):\n            if rp[i][j]:\n                return True\n            k=False\n            h=ht[i][j]\n            ht[i][j]=100001\n            if ht[i-1][j]<=h:\n                k=k or pac(i-1,j)\n                \n            if ht[i][j-1]<=h:\n                k=k or pac(i,j-1)\n                \n            if i<m-1 and ht[i+1][j]<=h:\n                k=k or pac(i+1,j)\n                \n            if j<n-1 and ht[i][j+1]<=h:\n                k=k or pac(i,j+1)\n                \n            ht[i][j]=h\n            rp[i][j]=k\n            return k\n        \n        def ant(i,j):\n            if ra[i][j]:\n                return True\n            k=False\n            h=ht[i][j]\n            ht[i][j]=100001\n            if i>0 and ht[i-1][j]<=h:\n                k=k or ant(i-1,j)\n                \n            if j>0 and ht[i][j-1]<=h:\n                k=k or ant(i,j-1)\n                \n            if ht[i+1][j]<=h:\n                k=k or ant(i+1,j)\n                \n            if ht[i][j+1]<=h:\n                k=k or ant(i,j+1)\n                \n            ht[i][j]=h\n            ra[i][j]=k\n            return k\n        \n        m=len(ht)\n        n=len(ht[0])\n        rp=[[False for i in range(n)] for j in range(m)]\n        ra=[[False for i in range(n)] for j in range(m)]\n        \n        for i in range(m):\n            rp[i][0]=True\n            ra[i][-1]=True\n        for i in range(n):\n            rp[0][i]=True\n            ra[-1][i]=True\n        \n        for i in range(m):\n            for j in range(n):\n                pac(i,j)\n                ant(i,j)\n        res=[]\n        for i in range(m):\n            for j in range(n):\n                if rp[i][j] and ra[i][j]:\n                    res.append([i,j])\n        return res"}
{"prompt": "def countBattleships(self, board: List[List[str]]) -> int:\n        count = 0\n        for r in range(len(board)):\n            for c in range(len(board[0])):\n                if board[r][c] == 'X':\n                    var = 1\n                    if (r > 0 and board[r-1][c] == 'X') or (c > 0 and board[r][c-1] == 'X'):\n                        var = 0\n                    count += var\n        return count"}
{"prompt": "def strongPasswordChecker(self, password: str) -> int:\n        #vimla_kushwaha\n        s = password\n        missing_type = 3\n        if any('a' <= c <= 'z' for c in s): missing_type -= 1\n        if any('A' <= c <= 'Z' for c in s): missing_type -= 1\n        if any(c.isdigit() for c in s): missing_type -= 1\n\n        change = 0\n        one = two = 0\n        p = 2\n        while p < len(s):\n            if s[p] == s[p-1] == s[p-2]:\n                length = 2\n                while p < len(s) and s[p] == s[p-1]:\n                    length += 1\n                    p += 1\n                    \n                change += length // 3\n                if length % 3 == 0: one += 1\n                elif length % 3 == 1: two += 1\n            else:\n                p += 1\n        \n        if len(s) < 6:\n            return max(missing_type, 6 - len(s))\n        elif len(s) <= 20:\n            return max(missing_type, change)\n        else:\n            delete = len(s) - 20\n            \n            change -= min(delete, one)\n            change -= min(max(delete - one, 0), two * 2) // 2\n            change -= max(delete - one - 2 * two, 0) // 3\n                \n            return int(delete + max(missing_type, change))"}
{"prompt": "def findMaximumXOR(self, nums: List[int]) -> int:\n        # need to know the largest binary representation\n\t\t# bin prepends '0b', ignore\n\t\tL = len(bin(max(nums))) - 2\n\n\t\t# preprocess step - left-pad zeros to ensure each number has L bits\n\t\t# (x >> i) &amp; 1 produces the bit at position i for number x\n\t\t# x's value is moved right by i bits, we &amp; 1 to produce 0 or 1\n\t\t# e.g., if L = 5, then 3 = [0, 0, 0, 1, 1], so the steps to get there are:\n\t\t# (3 >> 4) &amp; 1 = 0\n\t\t# (3 >> 3) &amp; 1 = 0\n\t\t# (3 >> 2) &amp; 1 = 0\n\t\t# (3 >> 1) &amp; 1 = 1\n\t\t# (3 >> 0) &amp; 1 = 1\n\t\tnums_bits = [[(x >> i) &amp; 1 for i in reversed(range(L))] for x in nums]\n\t\troot = {}\n\t\t# build the trie\n\t\tfor num, bits in zip(nums, nums_bits):\n\t\t\tnode = root\n\t\t\tfor bit in bits:\n\t\t\t\tnode = node.setdefault(bit, {})\n\t\t\tnode[\"#\"] = num\n\n\t\tmax_xor = 0\n\t\tfor num, bits in zip(nums, nums_bits):\n\t\t\tnode = root\n\t\t\t# we want to find the node that will produce the largest XOR with num\n\t\t\tfor bit in bits:\n\t\t\t\t# our goal is to find the opposite bit, e.g. bit = 0, we want 1\n\t\t\t\t# this is our goal because we want as many 1's as possible\n\t\t\t\ttoggled_bit = 1 - bit\n\t\t\t\tif toggled_bit in node:\n\t\t\t\t\tnode = node[toggled_bit]\n\t\t\t\telse:\n\t\t\t\t\tnode = node[bit]\n\t\t\t# we're at a leaf node, now we can do the XOR computation\n\t\t\tmax_xor = max(max_xor, node[\"#\"] ^ num)\n\n\n        return max_xor"}
{"prompt": "def originalDigits(self, s: str) -> str:\n        c = collections.Counter(s)\n        \n        digit_count = [0] * 10\n        digit_count[0] = c['z']\n        digit_count[2] = c['w']\n        digit_count[4] = c['u']\n        digit_count[6] = c['x']\n        digit_count[8] = c['g']\n        \n        digit_count[3] = c['h'] - digit_count[8]\n        digit_count[5] = c['f'] - digit_count[4]\n        digit_count[7] = c['s'] - digit_count[6]\n        \n        digit_count[9] = c['i'] - digit_count[5] - digit_count[6] - digit_count[8]\n        digit_count[1] = c['n'] - digit_count[9] * 2 - digit_count[7]\n        \n        return \"\".join([str(idx) * cnt for idx, cnt in enumerate(digit_count) if cnt > 0])"}
{"prompt": "def characterReplacement(self, s: str, k: int) -> int:\n        \n        # Maintain a dictionary that keeps track of last 'window' characters\n        # See if 'window' size minus occurrences of the most common char is <= k, if so it's valid\n        # Run time is O(length of string * size of alphabet)\n\t\t# Space is O(size of alphabet)\n        \n        d = {}\n        window = 0\n        \n        for i, char in enumerate(s):\n            d[char] = d.get(char, 0) + 1\n            if window+1 - max(d.values()) <= k:\n                window += 1\n            else:\n                d[s[i-window]] -= 1\n        \n        return window"}
{"prompt": "def construct(self, grid: List[List[int]]) -> 'Node':\n        \n        def fn(x0, x1, y0, y1): \n            \"\"\"Return QuadTree subtree.\"\"\"\n            val = {grid[i][j] for i, j in product(range(x0, x1), range(y0, y1))}\n            if len(val) == 1: return Node(val.pop(), True, None, None, None, None)\n            tl = fn(x0, (x0+x1)//2, y0, (y0+y1)//2)\n            tr = fn(x0, (x0+x1)//2, (y0+y1)//2, y1)\n            bl = fn((x0+x1)//2, x1, y0, (y0+y1)//2)\n            br = fn((x0+x1)//2, x1, (y0+y1)//2, y1)\n            return Node(None, False, tl, tr, bl, br)\n        \n        n = len(grid)\n        return fn(0, n, 0, n)"}
{"prompt": "def levelOrder(self, root: 'Node') -> List[List[int]]:\n        result = []        \n        q = deque([root] if root else [])\n        while q:\n            result.append([])\n            for _ in range(len(q)):\n                node = q.popleft()\n                result[-1].append(node.val)\n                q.extend(node.children)\n            \n        return result"}
{"prompt": "def flatten(self, head: 'Node') -> 'Node':\n        def getTail(node):\n            prev = None\n            while node:\n                _next = node.next\n                if node.child:\n\t\t\t\t\t# ... <-> node <-> node.child <-> ...\n                    node.next = node.child\n                    node.child = None\n                    node.next.prev = node\n\t\t\t\t\t# get the end node of the node.child list\n                    prev = getTail(node.next)\n                    if _next:\n\t\t\t\t\t\t# ... <-> prev (end node) <-> _next (originally node.next) <-> ...\n                        _next.prev = prev\n                        prev.next = _next\n                else:\n                    prev = node\n                node = _next  # loop through the list of nodes\n            return prev  # return end node\n        \n        getTail(head)\n        return head"}
{"prompt": "def minMutation(self, start: str, end: str, bank: List[str]) -> int:\n        dic=defaultdict(lambda :0)\n        lst=[[start,0]]\n        dic[start]=1\n        while lst:\n            x,d=lst.pop(0)\n            if x==end:\n                return d\n            for i in range(len(bank)):\n                ct=0\n                for j in range(8):\n                    if x[j]!=bank[i][j]:\n                        ct+=1\n                if ct==1:\n                    if dic[bank[i]]==0:\n                        lst.append([bank[i],d+1])\n                        dic[bank[i]]=1\n        return -1"}
{"prompt": "def countSegments(self, s: str) -> int:\n        return len([i for i in s.split(\" \") if i!=\"\"])"}
{"prompt": "def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key=lambda x: x[1])\n        n = len(intervals)\n        ans, curr = 1, intervals[0]\n\n        for i in range(n):\n            if intervals[i][0] >= curr[1]:\n                ans += 1\n                curr = intervals[i]\n\n        return n - ans"}
{"prompt": "def findRightInterval(self, intervals: List[List[int]]) -> List[int]:\n        start = sorted([[intervals[i][0], i] for i in range(len(intervals))])\n        end = sorted([[intervals[i][1], i] for i in range(len(intervals))])\n        i = 0\n        res = []\n        for endVal, endIdx in end:\n            while i < len(start) and (endVal > start[i][0]):\n                i += 1\n            if i < len(start):\n                res.append(start[i][1])\n            else:\n                while len(res) < len(start):\n                    res.append(-1)\n        ans = []\n        for i in range(len(end)):\n            ans.append((end[i][1], res[i]))\n        ans.sort()\n        return [ele[1] for ele in sorted([[a[1], b] for a, b in zip(end, res)])]"}
{"prompt": "def pathSum(self, root: TreeNode, sum: int) -> int:\n        \n        global result\n        result = 0\n        \n        def dfs(node, target):\n            if node is None: return\n            find_path_from_node(node, target)\n            dfs(node.left, target)\n            dfs(node.right, target)\n                \n        def find_path_from_node(node, target):\n            global result\n            if node is None: return\n            if node.val == target: result += 1\n            find_path_from_node(node.left, target-node.val)\n            find_path_from_node(node.right, target-node.val)\n            \n        dfs(root, sum)\n        \n        return result"}
{"prompt": "def findAnagrams(self, s: str, p: str) -> List[int]: \n        # take counter of first n elements in s_dict with n = len(p) - 1\n        s_dict = collections.Counter(s[:len(p)-1]) \n        # counter of p, this should not be changed\n        p_dict = collections.Counter(p)\n        start = 0\n        # final result list\n        res = []\n        # We iterate over the string s, and in each step we check if s_dict and p_dict match\n        for i in range(len(p)-1, len(s)):\n            # updating the counter &amp; adding the character\n            s_dict[s[i]] += 1\n            # checking if counters match\n            if s_dict == p_dict:\n                res.append(start)\n            # remove the first element from counter\n            s_dict[s[start]] -= 1\n            #if element count = 0, pop it from the counter\n            if s_dict[s[start]] == 0:\n                del s_dict[s[start]]\n            start += 1\n            \n        return res"}
{"prompt": "def findKthNumber(self, n: int, k: int) -> int:\n        \n        def fn(x): \n            \"\"\"Return node counts in denary trie.\"\"\"\n            ans, diff = 0, 1\n            while x <= n: \n                ans += min(n - x + 1, diff)\n                x *= 10 \n                diff *= 10 \n            return ans \n        \n        x = 1\n        while k > 1: \n            cnt = fn(x)\n            if k > cnt: k -= cnt; x += 1\n            else: k -= 1; x *= 10 \n        return x"}
{"prompt": "def arrangeCoins(self, n: int) -> int:\n\n        first = 1\n        last = n\n        if n==1:\n            return 1\n        while first <= last:\n            mid = (first+last)//2\n\n            if mid*(mid+1) == 2*n:\n                return mid\n            elif mid*(mid+1) > 2*n:\n                last = mid-1\n            else:\n                first = mid+1\n        return last"}
{"prompt": "def findDuplicates(self, N: List[int]) -> List[int]:\n        S, A = set(), []\n        for n in N:\n            if n in S: A.append(n)\n            else: S.add(n)\n        return A"}
{"prompt": "def compress(self, chars: List[str]) -> int:\n        if not chars:\n            return 0\n        mychar = chars[0]\n        count = 0\n        length = len(chars)\n        chars.append(\" \") # Append a space so last char group is not left out in loop\n        for i in range(length+1): #+1 for extra space char we added\n            char = chars.pop(0)\n            if char == mychar: #if same character then just increase the count\n                count += 1\n            else:\n                if count == 1: #if not same then append the char to chars\n                    chars.append(mychar) #if count is 1 don't append count\n                elif count > 1:\n                    chars.append(mychar)\n                    chars += (list(str(count))) #if count > 1 append count as a string\n                mychar = char #update mychar as the new different char in chars\n                count = 1 #reset count to 1 as we have already read the new char\n        return len(chars) #since all previous are popped, only the answer remains in chars now"}
{"prompt": "def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n\t\n        n1 = n2 = 0\n        ptr1, ptr2 = l1, l2\n        stack = []\n        \n        while ptr1: n1 += 1; ptr1 = ptr1.next\n        while ptr2: n2 += 1; ptr2 = ptr2.next\n        max_len = max(n1, n2)\n        \n        while max_len:\n            a = b = 0\n            if max_len <= n1: a = l1.val; l1 = l1.next\n            if max_len <= n2: b = l2.val; l2 = l2.next\n            stack.append(a + b)\n            max_len -= 1\n        \n        sumval, head = 0, None\n        while stack or sumval:\n            if stack: sumval += stack.pop()\n            node = ListNode(sumval % 10)\n            node.next = head\n            head = node\n            sumval //= 10\n        return head"}
{"prompt": "def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        ans = 0 \n        freq = [defaultdict(int) for _ in range(len(nums))] # arithmetic sub-seqs\n        for i, x in enumerate(nums): \n            for ii in range(i): \n                diff = x - nums[ii]\n                ans += freq[ii].get(diff, 0)\n                freq[i][diff] += 1 + freq[ii][diff]\n        return ans"}
{"prompt": "def numberOfBoomerangs(self, p: List[List[int]]) -> int:\n        L, t = len(p), 0\n        D = [[0]*L for i in range(L)]\n        for i in range(L):\n        \tE = {}\n        \tfor j in range(L):\n        \t\tif j > i: D[i][j] = D[j][i] = (p[j][0]-p[i][0])**2 + (p[j][1]-p[i][1])**2\n        \t\tE[D[i][j]] = E[D[i][j]] + 1 if D[i][j] in E else 1\n        \tt += sum(r*(r-1) for r in E.values())\n        return t\n\t\t\n\t\t\n- Junaid Mansuri\n(LeetCode ID)@hotmail.com"}
{"prompt": "def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\n        for n in nums:\n            a = abs(n) - 1\n            if nums[a] > 0: nums[a] *= -1\n        return [i+1 for i in range(len(nums)) if nums[i] > 0]"}
{"prompt": "def deleteNode(self, root: TreeNode, key: int) -> TreeNode:\n        \n        if not root:\n            return None\n            \n        if root.val > key:\n\t\t    # Target node is smaller than currnet node, search left subtree\n\t\t\t\n            root.left = self.deleteNode( root.left, key )\n\n        elif root.val < key:\n\t\t    # Target node is larger than currnet node, search right subtree\n\t\t\t\n            root.right = self.deleteNode( root.right, key )\n\n        else:\n            # Current node is target node\n\t\t\t\n            if (not root.left) or (not root.right):\n                # At least one child is empty\n                # Target node is replaced by either non-empty child or None\n                root = root.left if root.left else root.right\n\n            else:\n                # Both two childs exist\n                # Target node is replaced by smallest element of right subtree\n                cur = root.right\n\n                while cur.left:\n                    cur = cur.left\n\n                root.val = cur.val\n                root.right = self.deleteNode( root.right, cur.val )\n                    \n        return root"}
{"prompt": "def frequencySort(self, s: str) -> str:\n        \n        ans_str = ''\n        # Find unique characters\n        characters = set(s)\n        \n        counts = []\n        # Count their frequency\n        for i in characters:\n            counts.append([i,s.count(i)])\n        \n\t\t# Sort characters according to their frequency\n        counts = sorted(counts, key= lambda x: x[1], reverse = True)\n        \n\t\t# Generate answer string by multiplying frequency count with the character\n        for i,j in counts:\n            ans_str += i*j\n        \n        return ans_str"}
{"prompt": "def findMinArrowShots(self, points: List[List[int]]) -> int:\n        pts = sorted(points, key=lambda el: el[1])\n        \n        res, combo = 0, (float(\"-inf\"), float(\"-inf\"))\n        for start, end in pts:\n            if start <= combo[1]: # overlaps?\n                combo = (max(combo[0], start), min(combo[1], end))\n            else:\n                combo = (start, end)\n                res += 1\n                \n        return res"}
{"prompt": "def minMoves(self, nums: List[int]) -> int:\n        return sum(nums) - (len(nums) * min(nums))"}
{"prompt": "def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\n        \n        # hashmap and final result count\n        nums12, res = defaultdict(int), 0\n        \n        # storing all possible combinations of sum\n        for i in nums1:\n            for j in nums2:\n                nums12[i+j] += 1\n        \n        # iterating the left out two array to find negation of same value\n        for k in nums3:\n            for l in nums4:\n                res += nums12[-(k+l)]\n        \n        return res"}
{"prompt": "def findContentChildren(self, g: List[int], s: List[int]) -> int:\n        g.sort()  # O(nlogn)\n        s.sort()  # O(nlogn)\n        \n        child_point = 0\n        cookie_point = 0\n        counter = 0\n        \n        # O(n)\n        while child_point < len(g) and cookie_point < len(s):\n            if g[child_point] <= s[cookie_point]:\n                counter += 1\n                child_point += 1\n                cookie_point += 1\n            else:\n                cookie_point += 1\n            \n        return counter"}
{"prompt": "def find132pattern(self, nums: List[int]) -> bool:\n        if len(nums)<3:\n            return False\n      \n        second_num = -math.inf\n        stck = []\n        # Try to find nums[i] < second_num < stck[-1]\n        for i in range(len(nums) - 1, -1, -1):\n            if nums[i] < second_num:\n                return True\n            # always ensure stack can be popped in increasing order\n            while stck and stck[-1] < nums[i]:\n\t\t\t\tsecond_num = stck.pop()  # this will ensure  second_num < stck[-1] for next iteration\n\n            stck.append(nums[i])\n        return False"}
{"prompt": "def circularArrayLoop(self, nums: List[int]) -> bool:\n        n, visited = len(nums), set()\n        for i in range(n):\n            if i not in visited:\n                local_s = set()\n                while True:\n                    if i in local_s: return True\n                    if i in visited: break          # credit to @crazyhyz, add this condition to avoid revisited\n                    visited.add(i)\n                    local_s.add(i)\n                    prev, i = i, (i + nums[i]) % n\n                    if prev == i or (nums[i] > 0) != (nums[prev] > 0): break\n        return False"}
{"prompt": "def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:\n        return ceil(log(buckets) / log(minutesToTest / minutesToDie + 1));"}
{"prompt": "def repeatedSubstringPattern(self, s: str) -> bool:\n        return s in s[1:] + s[:-1]"}
{"prompt": "def hammingDistance(self, x: int, y: int) -> int:\n        def get_bin(num):\n            res = []\n            while num > 0:\n                res.append(num % 2)\n                num //= 2\n            return ''.join(str(num) for num in res[::-1])\n        \n        if x < y:\n            x, y = y, x\n        \n        bin_x, bin_y = get_bin(x), get_bin(y)\n        res = 0\n        s1, s2 = len(bin_x), len(bin_y)\n        bin_y = '0' * (s1 - s2) + bin_y\n        \n        return sum(bin_x[i] != bin_y[i] for i in range(s1))"}
{"prompt": "def minMoves2(self, nums: List[int]) -> int:\n        nums.sort()\n        mid = nums[len(nums)//2]\n        result = 0\n        for i in nums:\n            result+=abs(mid-i)\n        return result"}
{"prompt": "def islandPerimeter(self, grid: List[List[int]]) -> int: \n    \tM, N, p = len(grid), len(grid[0]), 0\n    \tfor m in range(M):\n    \t\tfor n in range(N):\n    \t\t\tif grid[m][n] == 1:\n    \t\t\t\tif m == 0   or grid[m-1][n] == 0: p += 1\n    \t\t\t\tif n == 0   or grid[m][n-1] == 0: p += 1\n    \t\t\t\tif n == N-1 or grid[m][n+1] == 0: p += 1\n    \t\t\t\tif m == M-1 or grid[m+1][n] == 0: p += 1\n    \treturn p\n\t\t\n\t\t\t\n- Junaid Mansuri\n- Chicago, IL"}
{"prompt": "def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\n        if desiredTotal == 0: return True # edge case 1\n        if maxChoosableInteger * (maxChoosableInteger+1)//2 < desiredTotal: return False # edge case 2\n        \n        @lru_cache(None)\n        def fn(mask, total): \n            \"\"\"Return True if there is a winning strategy given mask &amp; total.\"\"\"\n            if total <= 0: return False # already lost \n            for i in range(maxChoosableInteger): \n                if mask &amp; (1 << i): # integer i+1 is not used yet \n                    if not fn(mask ^ (1 << i), total - (i + 1)): return True \n            return False \n        \n        return fn(int(\"1\"*maxChoosableInteger, 2), desiredTotal)"}
{"prompt": "def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n        cnt = idx = 0 \n        count = []\n        index = []\n        for i in range(n1): \n            for ch in s1: \n                if ch == s2[idx]: \n                    idx += 1\n                    if idx == len(s2): \n                        cnt += 1\n                        idx = 0 \n            count.append(cnt)\n            index.append(idx)\n            for ii in range(i): \n                if index[ii] == idx: \n                    prev = count[ii]\n                    repeat = (cnt - prev) * ((n1-1-ii) // (i - ii))\n                    post = count[ii + (n1-1-ii) % (i-ii)] - count[ii]\n                    return (prev + repeat + post) // n2\n        return count[-1]//n2"}
{"prompt": "def findSubstringInWraproundString(self, p: str) -> int:\n        consecutive = 1\n        \n        # stores the maximum length of a substring ending at a character \n        maxSubstr = defaultdict(int)\n        maxSubstr[p[0]] = 1\n        \n        ans = 0\n        for x in range(1, len(p)):\n            if ord(p[x]) - ord(p[x - 1]) == 1 or p[x] == 'a' and p[x - 1] == 'z':\n                consecutive += 1\n            else:\n                consecutive = 1\n            maxSubstr[p[x]] = max(maxSubstr[p[x]], consecutive)\n        \n        return sum(maxSubstr.values())"}
{"prompt": "def validIPAddress(self, query: str) -> str:\n\t\tdot = query.count(\".\")\n\t\tcolon = query.count(\":\")\n\t\tif colon == 0 and dot == 3:\n\t\t\tarr = [i for i in query.split(\".\")]\n\t\t\tprint(arr)\n\t\t\tflag = True\n\t\t\tfor i in arr:\n\t\t\t\tif i.isdigit() and int(i) <= 255:\n\t\t\t\t\tx = int(i)\n\t\t\t\t\tif str(x) != i:\n\t\t\t\t\t\tflag = False\n\t\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\tflag = False\n\t\t\t\t\tbreak\n\t\t\tif flag:\n\t\t\t\treturn \"IPv4\"\n\t\t\telse:\n\t\t\t\treturn \"Neither\"\n\t\telif colon == 7 and dot == 0:\n\t\t\tflag = True\n\t\t\tarr = [i for i in query.split(\":\")]\n\t\t\tfor parts in arr:\n\t\t\t\tl = 0\n\t\t\t\tfor i in parts:\n\t\t\t\t\tl += 1\n\t\t\t\t\tif i not in \"0123456789abcdefABCDEF\":\n\t\t\t\t\t\tflag = False\n\t\t\t\t\t\tbreak\n\t\t\t\tif l > 4 or l < 1:flag = False;break\n\t\t\tif flag:\n\t\t\t\treturn \"IPv6\"\n\t\t\telse:\n\t\t\t\treturn \"Neither\"\n\n\t\telse:\n\t\t\treturn \"Neither\""}
{"prompt": "def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\n        ddic = lambda: defaultdict(ddic)\n        trie = ddic()\n        \n        for word in words:\n            cur = trie\n            for char in word:\n                cur = cur[char]\n\n            cur['end'] = True\n        \n        def isConcat(word, start):\n            cur = trie\n            for i in range(start, len(word)):\n                char = word[i]\n                if char not in cur:\n                    return False\n                cur = cur[char]\n\n                if 'end' in cur:\n                    if i + 1 == len(word):\n                        # tricky part that helps us distinguish simple word from concat word\n                        return start != 0\n                    \n                    if isConcat(word, i + 1):\n                        return True\n\n            return False\n            \n        return [word for word in words if isConcat(word, 0)]"}
{"prompt": "def makesquare(self, arr: List[int]) -> bool:\n\t\t# no way to make the square if total length not divisble by 4\n        if sum(arr) % 4:\n            return False\n        \n\t\t# target side length\n        side = sum(arr) // 4\n        \n        @lru_cache(None)\n        def dp(k, mask, s):\n\t\t\t# finish all four sides\n            if k == 4:\n                return True\n\t\t\t# move on to next side if current one finished\n            if not s:\n                return dp(k+1, mask, side)\n            \n            for i in range(len(arr)):\n\t\t\t\t# if current matchstick used or longer than remaining side length to fill then skip\n                if mask &amp; (1 << i) or s < arr[i]: continue\n                if dp(k, mask ^ (1 << i), s - arr[i]):\n                    return True\n            return False\n        \n        return dp(0, 0, side)"}
{"prompt": "def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\n        counter=[[s.count(\"0\"), s.count(\"1\")] for s in strs]\n        \n        @cache\n        def dp(i,j,idx):\n            if i<0 or j<0:\n                return -math.inf\n            \n            if idx==len(strs):\n                return 0\n            \n            return max(dp(i,j,idx+1), 1 + dp(i-counter[idx][0], j-counter[idx][1], idx+1))\n        return dp(m,n,0)"}
{"prompt": "def findRadius(self, houses: List[int], heaters: List[int]) -> int:\n        houses.sort()\n        heaters.sort()\n\n        if len(heaters) == 1:\n            return max(abs(houses[0] - heaters[0]), abs(houses[-1] - heaters[0]))\n\n        m_value = -1\n        f, s, ind_heat = heaters[0], heaters[1], 2\n        for i in range(len(houses)):\n            while houses[i] > s and ind_heat < len(heaters):\n                f, s = s, heaters[ind_heat]\n                ind_heat += 1\n            m_value = max(m_value, min(abs(houses[i] - f), abs(houses[i] - s)))\n        return m_value"}
{"prompt": "def findComplement(self, num: int) -> int:\n        \n        bit_mask = 2**num.bit_length() -1 \n        \n        return ( num ^ bit_mask )"}
{"prompt": "def totalHammingDistance(self, nums: List[int]) -> int:\n        ans = 0\n        for i in range(32):\n            zero = one = 0\n            mask = 1 << i\n            for num in nums:\n                if mask &amp; num: one += 1\n                else: zero += 1    \n            ans += one * zero        \n        return ans"}
{"prompt": "def __init__(self, radius: float, x_center: float, y_center: float):\n        self.x = x_center\n        self.y = y_center\n        self.radius = radius\n\n    def randPoint(self) -> List[float]:\n        first = random.uniform(-self.radius, self.radius)\n        secondmax = (self.radius ** 2 - first ** 2) ** 0.5\n        second = random.uniform(-secondmax, secondmax)\n        return [self.x + first, self.y + second]"}
{"prompt": "def largestPalindrome(self, n: int) -> int:\n        \n        # just to forget about 1-digit case\n        if n == 1:\n            return 9\n        \n        # minimal number with n digits (for ex. for n = 4, min_num = 1000)\n        min_num = 10 ** (n - 1)\n        \n        # maximal number with n digits (for ex. 9999)\n        max_num = 10 ** n - 1       \n        \n        max_pal = 0\n        \n        # step is equal to 2, because we have to get a number, the 1st digit of which is 9, so we have to   \n\t\t# iterate only over odd numbers\n        for i in range(max_num, min_num - 1, -2): \n            \n            # since we are looking for the maximum palindrome number, it makes no sense to iterate over the \n            # product less than the max_pal obtained from the last iteration\n            if i * i < max_pal:\n                break\n                \n            for j in range(max_num, i - 1, -2):\n                product = i * j\n                \n                # since a palindrome with an even number of digits must be mod 11 == 0 and we have no reason to \n                # check the product which less or equal than max_pal\n                if product % 11 != 0 and product >= max_pal:\n                    continue\n                    \n                # check if product is a palindrome then update the max_pal\n                if str(product) == str(product)[::-1]:\n                    max_pal = product\n\n        return max_pal % 1337"}
{"prompt": "# TC - O((n - k)*log(k))\n    # SC - O(k)\n\t# 121 ms, faster than 96.23%\n\n    def find_median(self, max_heap, min_heap, heap_size):\n        if heap_size % 2 == 1:\n            return -max_heap[0]\n        else:\n            return (-max_heap[0] + min_heap[0]) / 2\n\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        max_heap = []\n        min_heap = []\n        heap_dict = defaultdict(int)\n        result = []\n        \n        for i in range(k):\n            heappush(max_heap, -nums[i])\n            heappush(min_heap, -heappop(max_heap))\n            if len(min_heap) > len(max_heap):\n                heappush(max_heap, -heappop(min_heap))\n        \n        median = self.find_median(max_heap, min_heap, k)\n        result.append(median)\n        \n        for i in range(k, len(nums)):\n            prev_num = nums[i - k]\n            heap_dict[prev_num] += 1\n\n            balance = -1 if prev_num <= median else 1\n            \n            if nums[i] <= median:\n                balance += 1\n                heappush(max_heap, -nums[i])\n            else:\n                balance -= 1\n                heappush(min_heap, nums[i])\n            \n            if balance < 0:\n                heappush(max_heap, -heappop(min_heap))\n            elif balance > 0:\n                heappush(min_heap, -heappop(max_heap))\n\n            while max_heap and heap_dict[-max_heap[0]] > 0:\n                heap_dict[-max_heap[0]] -= 1\n                heappop(max_heap)\n            \n            while min_heap and heap_dict[min_heap[0]] > 0:\n                heap_dict[min_heap[0]] -= 1\n                heappop(min_heap)\n\n            median = self.find_median(max_heap, min_heap, k)\n            result.append(median)\n        \n        return result"}
{"prompt": "def magicalString(self, n: int) -> int:\n        arr, i = [1,2,2], 2\n   \n        while len(arr) < n:\n            arr.extend([arr[-1]^3]*arr[i])\n            i += 1\n    \n        return arr[:n].count(1)"}
{"prompt": "def licenseKeyFormatting(self, S: str, K: int) -> str:\n        \n        # Eliminate all dashes\n        S = S.replace('-', '')\n        \n        head = len(S) % K\n        \n        grouping = []\n        \n        # Special handle for first group\n        if head:\n            grouping.append( S[:head] )\n        \n        # General case:\n        for index in range(head, len(S), K ):\n            grouping.append( S[ index : index+K ] )\n        \n        \n        # Link each group togetger and separated by dash '-'\n        return '-'.join( grouping ).upper()"}
{"prompt": "def smallestGoodBase(self, n: str) -> str:\n        import math\n        n = int(n)\n        max_m = math.floor(math.log(n, 2))\n        ans = 0\n        for m in range(max_m, 0, -1):\n            k = int(n ** (1 / m))\n            if (k ** (m + 1)  - 1) // (k - 1) == n:\n                return str(k)\n        return str(n - 1)"}
{"prompt": "def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\n        c1,c2=0,0\n        for i in nums:\n            if i==1:\n                c1+=1\n            elif i==0:\n                c1=0\n            if c1>c2:\n                c2=c1\n        return c2"}
{"prompt": "def PredictTheWinner(self, nums: List[int]) -> bool:\n        def helper(i, j):\n            if i == j:\n                return nums[i]\n            \n            if (i, j) in memo:\n                return memo[(i, j)]\n            \n            score = max(nums[j] - helper(i, j-1), nums[i] - helper(i+1, j))\n            memo[(i, j)] = score\n            \n            return score\n            \n        memo = {}            \n        return helper(0, len(nums)-1) >= 0"}
{"prompt": "def findMinStep(self, board: str, hand: str) -> int:\n        \n        # start from i and remove continues ball\n        def remove_same(s, i):\n            if i < 0:\n                return s\n            \n            left = right = i\n            while left > 0 and s[left-1] == s[i]:\n                left -= 1\n            while right+1 < len(s) and s[right+1] == s[i]:\n                right += 1\n            \n            length = right - left + 1\n            if length >= 3:\n                new_s = s[:left] + s[right+1:]\n                return remove_same(new_s, left-1)\n            else:\n                return s\n\n\n\n        hand = \"\".join(sorted(hand))\n\n        # board, hand and step\n        q = collections.deque([(board, hand, 0)])\n        visited = set([(board, hand)])\n\n        while q:\n            curr_board, curr_hand, step = q.popleft()\n            for i in range(len(curr_board)+1):\n                for j in range(len(curr_hand)):\n                    # skip the continue balls in hand\n                    if j > 0 and curr_hand[j] == curr_hand[j-1]:\n                        continue\n                    \n                    # only insert at the begin of continue balls in board\n                    if i > 0 and curr_board[i-1] == curr_hand[j]: # left side same color\n                        continue\n                    \n                    pick = False\n                    # 1. same color with right\n                    # 2. left and right are same but pick is different\n                    if i < len(curr_board) and curr_board[i] == curr_hand[j]:\n                        pick = True\n                    if 0<i<len(curr_board) and curr_board[i-1] == curr_board[i] and curr_board[i] != curr_hand[j]:\n                        pick = True\n                    \n                    if pick:\n                        new_board = remove_same(curr_board[:i] + curr_hand[j] + curr_board[i:], i)\n                        new_hand = curr_hand[:j] + curr_hand[j+1:]\n                        if not new_board:\n                            return step + 1\n                        if (new_board, new_hand) not in visited:\n                            q.append((new_board, new_hand, step+1))\n                            visited.add((new_board, new_hand))\n\n        return -1"}
{"prompt": "def findSubsequences(self, nums: List[int]) -> List[List[int]]:\n        def dfs(i, num, curr):\n            if len(curr)>=2:\n                ans.add(curr[:])\n            if i>=len(nums):\n                return\n            for j in range(i, len(nums)):\n                if nums[j]>=num:\n                    dfs(j+1, nums[j], curr+(nums[j],))\n                        \n        ans = set()\n        dfs(0, -float(\"inf\"), ())\n        return ans"}
{"prompt": "def constructRectangle(self, area: int) -> List[int]:\n        \n        for i in range(int(area**0.5),0,-1):\n            if area % i == 0: return [area//i,i]"}
{"prompt": "def reversePairs(self, nums: List[int]) -> int:\n        ans = 0\n        seen = []\n        for x in nums: \n            k = bisect_right(seen, 2*x)\n            ans += len(seen) - k\n            insort(seen, x)\n        return ans"}
{"prompt": "def findTargetSumWays(self, nums: List[int], target: int) -> int:     \n        dic = defaultdict(int)\n        \n        def dfs(index=0, total=0):          \n            key = (index, total)\n            \n            if key not in dic:\n                if index == len(nums):                    \n                    return 1 if total == target else 0\n                else:\n                    dic[key] = dfs(index+1, total + nums[index]) + dfs(index+1, total - nums[index])                    \n                        \n            return dic[key]                                                             \n                \n        return dfs()"}
{"prompt": "def findPoisonedDuration(self, timeSeries, duration):\n        repeat = 0\n        for i in range(len(timeSeries)-1):\n            diff = timeSeries[i+1] - timeSeries[i]\n            if diff < duration:\n                repeat += duration - diff\n        return len(timeSeries)*duration - repeat"}
{"prompt": "def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        \n        \n        # a stack with monotonic decreasing\n        monotonic_stack = []\n        \n        # dictionary:\n        # key: number\n        # value: next greater number of key\n        dict_of_greater_number = {}\n\n        # ----------------------------------------------\n        \n        # launch linear scan to build dict_of_greater_number\n        for cur_number in nums2:\n            \n            # maintain a monotonic decreasing stack\n            while monotonic_stack and cur_number > monotonic_stack[-1]:\n                \n                pop_out_number = monotonic_stack.pop()\n                \n                # next greater number of pop_out_number is cur_number\n                dict_of_greater_number[pop_out_number] = cur_number\n            \n            monotonic_stack.append(cur_number)\n        # ----------------------------------------------\n        \n        # solution output\n        next_greater_element = []\n        \n        # get next greater element by dictionary\n        for x in nums1:\n            \n            if x in dict_of_greater_number:\n                next_greater_element.append( dict_of_greater_number[x] )\n                \n            else:\n                next_greater_element.append(-1)\n                \n        return next_greater_element"}
{"prompt": "def __init__(self, rects: List[List[int]]):\n        self.rects = rects\n        self.search_space = []\n\n        for i, rect in enumerate(rects):\n            a, b, c, d = rect\n            self.search_space.append((d - b + 1) * (c - a + 1))\n            if i != 0:\n                self.search_space[i] += self.search_space[i - 1]\n      \n\n    def pick(self) -> List[int]:\n        randval = random.randint(0, self.search_space[-1] - 1)\n\n        low = 0\n        high = len(self.search_space) - 1\n\n        while low < high:\n            midpt = low + (high - low) // 2\n\n            if self.search_space[midpt] <= randval:\n                low = midpt + 1\n            else:\n                high = midpt\n\n\n        rect = self.rects[low]\n        rect_range = randval\n\n        if low > 0:\n            rect_range -= self.search_space[low - 1] \n\n\n        a, b, c, d = rect\n\n        return [(rect_range % (c - a + 1)) + a, (rect_range // (c - a + 1)) + b]"}
{"prompt": "def findDiagonalOrder(self, matrix: List[List[int]]) -> List[int]:\n        res = []\n        if not matrix:\n            return res\n\n        # group values in matrix by the sum of their indices in a map\n        map = {}\n        for i in range(len(matrix) + len(matrix[0]) - 1):\n            map[i] = []\n\n        # populate the map\n        for i, row in enumerate(matrix):\n            for j, val in enumerate(row):\n                map[i + j].append(val)\n\n        # iterate through map and reverse values where key is divisible by two\n        for k, v in map.items():\n            if k % 2 == 0:\n                map[k] = v[::-1]\n        \n        # populate output\n        for v in map.values():\n            for val in v:\n                res.append(val)\n                \n        return res"}
{"prompt": "def findWords(self, wds: List[str]) -> List[str]:\n        st = {'q': 1, 'w': 1, 'e': 1, 'r': 1, 't': 1, 'y': 1, 'u': 1, 'i': 1, 'o': 1, 'p': 1, 'a': 2, 's': 2, 'd': 2, 'f': 2, 'g': 2, 'h': 2, 'j': 2, 'k': 2, 'l': 2, 'z': 3, 'x': 3, 'c': 3, 'v': 3, 'b': 3, 'n': 3, 'm': 3}\n\n        ret = []\n\n        for wd in wds:\n            val = 0\n            for i in range(len(wd)):\n                if i == 0:\n                    val = st.get(wd[i].lower())\n                else:\n                    if val != st.get(wd[i].lower()):\n                        val = -1\n                        break\n            if val != -1:\n                ret.append(wd)\n        return ret"}
{"prompt": "def findMode(self, root: Optional[TreeNode]) -> List[int]:\n        \n        def traverse(root: TreeNode) -> None:\n            \n            if not root:\n                return\n            \n            nonlocal maxcount, count, prevval, modes\n            \n            traverse(root.left)\n            \n            if root.val == prevval:\n                count += 1\n            else:                \n                count = 1\n                \n            if count > maxcount:\n                maxcount = count\n                modes = [root.val]\n            elif count == maxcount:\n                modes.append(root.val)\n                \n            prevval = root.val\n            traverse(root.right)\n                \n                \n        modes = []\n        maxcount = 0\n        count = 0\n        prevval = root.val\n        traverse(root)\n        \n        return modes"}
{"prompt": "def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -> int:\n        capital, profits = zip(*sorted(zip(capital, profits)))\n        i = 0 \n        pq = []\n        for _ in range(k): \n            while i < len(capital) and capital[i] <= w: \n                heappush(pq, -profits[i])\n                i += 1\n            if pq: w -= heappop(pq)\n        return w"}
{"prompt": "def nextGreaterElements(self, nums: List[int]) -> List[int]:\n        stack, res = [], [-1] * len(nums) # taking an empty stack for storing index, a list with the lenght same as of nums so that we wont add unnecessary elements.\n        # [-1] * len(nums) = this will produce a list with len of nums and all elems will be -1.\n        for i in list(range(len(nums))) * 2: # see explanation below.\n            while stack and (nums[stack[-1]] < nums[i]): # stack is not empty and nums previous elem is less then current, i.e 1<2. \n                res[stack.pop()] = nums[i] # then we`ll pop the index in stack and in the res on the same index will add the current num. \n            stack.append(i) # if stack is empty then we`ll add the index of num in it for comparision to the next element in the provided list. \n        return res # returing the next greater number for every element in nums."}
{"prompt": "def convertToBase7(self, num: int) -> str:\n        if not num:\n            return \"0\"\n        l=[]\n        x=num\n        if num<0:\n            num=-num\n        while num>0:\n            r=num%7\n            l.append(str(r))\n            num//=7\n        return \"\".join(l[::-1]) if x>=0 else \"-\"+ \"\".join(l[::-1])"}
{"prompt": "def findRelativeRanks(self, score: List[int]) -> List[str]:\n        rankings = []\n        for i, val in enumerate(score):\n            heappush(rankings, (-val, i))\n        ans = [''] * len(score)\n        r = 1\n        rank = [\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\"]\n        while len(rankings) != 0:\n            _, i = heappop(rankings)\n            if r <= 3:\n                ans[i] = rank[r-1]\n            else:\n                ans[i] = f'{r}'\n            r += 1\n        return ans"}
{"prompt": "def checkPerfectNumber(self, num: int) -> bool:\n        if num == 1:\n            return False\n        res = 1\n        for i in range(2,int(num**0.5)+1):\n            if num%i == 0:\n                res += i + num//i\n        return res == num"}
{"prompt": "def findFrequentTreeSum(self, root: TreeNode) -> List[int]:\n        \n        counts = collections.Counter()\n        \n        def dfs(node):\n            if not node: return 0            \n            result = node.val + dfs(node.left) + dfs(node.right)\n            counts[result] += 1        \n            return result\n        \n        dfs(root)       \n        \n        # Try to return the most frequent elements\n        # Return [] if we run into index errors\n        try:\n            freq = counts.most_common(1)[0][1]\n            return [x[0] for x in counts.items() if x[1] == freq]\n        except:\n            return []"}
{"prompt": "def fib(self, N: int) -> int:\n    \ta, b = 0, 1\n    \tfor i in range(N): a, b = b, a + b\n    \treturn a\n\t\t\n\t\t\n- Python 3\n- Junaid Mansuri"}
{"prompt": "def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        q=[[root]]\n        nodes=[]\n        while q:\n            nodes = q.pop(0)\n            t=[]\n            for n in nodes:\n                if n.left:\n                    t.append(n.left)\n                if n.right:\n                    t.append(n.right)\n            if t:\n                q.append(t)\n        return nodes[0].val\n# Please upvote if you understand the solution"}
{"prompt": "def findRotateSteps(self, ring: str, key: str) -> int:\n        locs = {}\n        for i, ch in enumerate(ring): locs.setdefault(ch, []).append(i)\n            \n        @cache \n        def fn(i, j): \n            \"\"\"Return turns to finish key[j:] startin from ith position on ring.\"\"\"\n            if j == len(key): return 0 \n            loc = locs[key[j]]\n            k = bisect_left(loc, i) % len(loc)\n            ans = min(abs(i-loc[k]), len(ring) - abs(i-loc[k])) + fn(loc[k], j+1)\n            k = (k-1) % len(loc)\n            ans = min(ans, min(abs(i-loc[k]), len(ring) - abs(i-loc[k])) + fn(loc[k], j+1))\n            return ans \n        \n        return fn(0, 0) + len(key)"}
{"prompt": "def largestValues(self, root: Optional[TreeNode]) -> List[int]:\n        res = []\n\n        def helper(root, depth):\n            if root is None:\n                return\n            \n            if depth == len(res):\n                res.append(root.val)\n            else:\n                res[depth] = max(res[depth], root.val)\n            \n            helper(root.left, depth + 1)\n            helper(root.right, depth + 1)\n        \n        helper(root, 0)\n        return res"}
{"prompt": "def longestPalindromeSubseq(self, s: str) -> int:\n        return self.get_longest_subseq(0, len(s)-1, s)\n    \n    def get_longest_subseq(self, start, end, s):\n        \"\"\"\n            method used to find the longest palindrome subsequence in a string\n            start: start index of the string\n            end: end index of the string\n            s: string\n            return: length of the longest palindrome subsequence\n        \"\"\"\n        if start == end:\n            return 1\n\t\t\t\n        if start > end:\n            return 0\n\n        if s[start] == s[end]:\n            return 2 + self.get_longest_subseq(start + 1, end - 1, s)\n        \n        return max(self.get_longest_subseq(start + 1, end, s), self.get_longest_subseq(start, end - 1, s))"}
{"prompt": "def findMinMoves(self, machines: List[int]) -> int:\n        total = sum(machines)\n        if total % len(machines): return -1 # impossible \n        avg = total // len(machines)\n        \n        ans = prefix = 0\n        for i, x in enumerate(machines): \n            ans = max(ans, abs(prefix), x - avg)\n            prefix += x - avg\n        return ans"}
{"prompt": "def change(self, amount: int, coins: List[int]) -> int:\n        dp = [[1]+[0]*amount for _ in range(len(coins)+1)]\n        for i in range(1, len(coins)+1):\n            for j in range(1, amount+1):\n                if coins[i-1] <= j:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]]\n                else:\n                    dp[i][j] = dp[i-1][j]\n        return dp[len(coins)][amount]  # or dp[-1][-1]"}
{"prompt": "def __init__(self, m: int, n: int):\n        self.nums = m * n - 1\n        self.cols = n\n        self.flipped = set()\n        \n\n    def flip(self) -> List[int]:\n        rc = random.randint(0, self.nums)\n        while rc in self.flipped:\n            rc = random.randint(0, self.nums)\n            \n        self.flipped.add(rc)\n        return [rc // self.cols, rc % self.cols]\n    \n\n    def reset(self) -> None:\n        self.flipped = set()"}
{"prompt": "def detectCapitalUse(self, word: str) -> bool:\n    \treturn word in [word.upper(), word.lower(), word.title()]\n\t\t\n\n- Python 3\n- Junaid Mansuri"}
{"prompt": "def findLUSlength(self, a: str, b: str) -> int:\n        if a==b:return -1\n        else:return max(len(a),len(b))"}
{"prompt": "def findLUSlength(self, S: List[str]) -> int:\n    \tC = collections.Counter(S)\n    \tS = sorted(C.keys(), key = len, reverse = True)\n    \tfor i,s in enumerate(S):\n    \t\tif C[s] != 1: continue\n    \t\tb = True\n    \t\tfor j in range(i):\n    \t\t\tI, c = -1, True\n    \t\t\tfor i in s:\n    \t\t\t\tI = S[j].find(i,I+1)\n    \t\t\t\tif I == -1:\n    \t\t\t\t\tc = False\n    \t\t\t\t\tbreak\n    \t\t\tif c:\n    \t\t\t\tb = False\n    \t\t\t\tbreak\n    \t\tif b: return len(s)\n    \treturn -1\n\t\t\n\t\t\n- Junaid Mansuri\n(LeetCode ID)@hotmail.com"}
{"prompt": "def checkSubarraySum(self, nums: List[int], k: int) -> bool:\n\t\t# Brute Force: O(𝑛^2) - TLE\n\t\tcount = 0\n\t\tfor i in range(len(nums)):\n\t\t\tsum = 0\n\t\t\tfor j in range(i, len(nums)):\n\t\t\t\tsum += nums[j]\n\t\t\t\tif sum % k == 0:\n\t\t\t\t   return True\n\t\treturn False\n\ndef checkSubarraySum(self, nums: List[int], k: int) -> bool:\n\t\t# Optimal Approach - Time and Space: O(n), O(n)\n\t\tres = {0: -1}\n\t\tprefSum = 0\n\t\tfor i in range(len(nums)):\n\t\t\tprefSum += nums[i]\n\t\t\trem = prefSum % k\n\t\t\tif rem in res:\n\t\t\t\tif i-res[rem] > 1:\n\t\t\t\t\treturn True\n\t\t\telse:\n\t\t\t\tres[rem] = i\n\t\treturn False"}
{"prompt": "def findLongestWord(self, s: str, d: List[str]) -> str:\n        def is_subseq(main: str, sub: str) -> bool:\n            i, j, m, n = 0, 0, len(main), len(sub)\n            while i < m and j < n and n - j >= m - i:\n                if main[i] == sub[j]:\n                    i += 1\n                j += 1\n            return i == m\n        \n        res = ''\n        helper = sorted(d, key = lambda x: len(x), reverse = True)\n        for word in helper:\n            if len(word) < len(res): return res\n            if ( not res or word < res )  and is_subseq(word, s):\n                res = word\n        return res"}
{"prompt": "def findMaxLength(self, nums: List[int]) -> int:\n\n        partial_sum = 0\n        \n\t\t# table is a dictionary\n\t\t# key : partial sum value\n\t\t# value : the left-most index who has the partial sum value\n\t\t\n        table = { 0: -1}\n        \n        max_length = 0\n        \n        for idx, number in enumerate( nums ):\n            \n            # partial_sum add 1 for 1\n            # partial_sum minus 1 for 0\n            \n            if number:\n                partial_sum += 1\n            else:\n                partial_sum -= 1\n                \n            \n            if partial_sum in table:\n                \n                # we have a subarray with equal number of 0 and 1\n                # update max length\n                \n                max_length = max( max_length, ( idx - table[partial_sum] ) )\n                \n            else:\n                # update the left-most index for specified partial sum value\n                table[ partial_sum ] = idx\n                \n        return max_length"}
{"prompt": "def countArrangement(self, n: int) -> int:\n        self.count = 0\n        self.backtrack(n, 1, [])\n        return self.count\n        \n    def backtrack(self, N, idx, temp):\n        if len(temp) == N:\n            self.count += 1\n            return\n        \n        for i in range(1, N+1):\n            if i not in temp and (i % idx == 0 or idx % i == 0):\n                temp.append(i)\n                self.backtrack(N, idx+1, temp)\n                temp.pop()"}
{"prompt": "def __init__(self, w: List[int]):\n        self.li = []\n        ma = sum(w)\n        \n        for i, weight in enumerate(w):\n            ratio = ceil(weight / ma * 100)\n            self.li += ([i] * ratio)\n        \n\n    def pickIndex(self) -> int:\n        return random.choice(self.li)"}
{"prompt": "def updateBoard(self, board: List[List[str]], click: List[int]) -> List[List[str]]:\n        m, n = len(board), len(board[0])\n        def dfs(x, y):\n            if board[x][y] == 'M': board[x][y] = 'X'\n            elif board[x][y] == 'E':\n                cnt, nei = 0, []\n                for i, j in map(lambda v: (v[0]+x, v[1]+y), [(-1, 0), (1, 0), (-1, -1), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 1)]):\n                    if 0 <= i < m and 0 <= j < n:\n                        nei.append((i, j))\n                        if board[i][j] == 'M': cnt += 1\n                if not cnt:\n                    board[x][y] = 'B'\n                    for i, j in nei: dfs(i, j)\n                else: board[x][y] = str(cnt)\n        dfs(*click)            \n        return board"}
{"prompt": "def getMinimumDifference(self, root: Optional[TreeNode]) -> int:\n        d = float('inf')\n        s = []\n        if root == None:\n            return \n        d = self.traverse(root,d,s)\n        return d\n    def traverse(self,root,d,s):\n        if root.left != None:\n            d = self.traverse(root.left,d,s)\n        s.append(root.val)\n        if len(s)>1:\n            diff = s[-1]-s[-2]\n            if diff < d:\n                d = diff\n        if root.right != None:\n            d = self.traverse(root.right,d,s) \n        return d"}
{"prompt": "def findPairs(self, nums: List[int], k: int) -> int:\n        cnt=0\n        c=Counter(nums)\n        \n        if k==0:\n            for key,v in c.items():\n                if v>1:\n                    cnt+=1\n        else:\n            for key,v in c.items():\n                if key+k in c:\n                    cnt+=1\n        return cnt"}
{"prompt": "def complexNumberMultiply(self, num1: str, num2: str) -> str:\n        a1,b1 = num1.split('+')\n        a1 = int(a1)\n        b1 = int(b1[:-1])\n        a2,b2 = num2.split('+')\n        a2 = int(a2)\n        b2 = int(b2[:-1])\n        return str(a1*a2 + b1*b2*(-1)) + '+' + str(a1*b2 + a2*b1) + 'i'"}
{"prompt": "def convertBST(self, root: TreeNode) -> TreeNode:\n\t\tsum = 0\n\t\t\n\t\tdef sol(root: TreeNode) -> TreeNode:\n\t\t\tnonlocal sum\n\t\t\tif root:\n\t\t\t\tsol(root.right)\n\t\t\t\troot.val += sum\n\t\t\t\tsum = root.val\n\t\t\t\tsol(root.left)\n\t\t\treturn root\n\t\t\n\t\treturn sol(root)"}
{"prompt": "def findMinDifference(self, timePoints: List[str]) -> int:\n        M = 1440\n        times = [False] * M\n        for time in timePoints:\n            minute = self.minute(time)\n            if times[minute]:\n                return 0\n            times[minute] = True\n        \n        minutes = [i for i in range(M) if times[i]]\n        return min((minutes[i] - minutes[i-1]) % M for i in range(len(minutes)))\n        \n    def minute(self, time: str) -> int:\n        h, m = map(int, time.split(':'))\n        return 60*h + m"}
{"prompt": "def singleNonDuplicate(self, nums: List[int]) -> int:\n        counts = defaultdict(int)\n        for num in nums:\n            counts[num] += 1\n        for num, count in counts.items():\n            if count == 1:\n                return num\n        return -1  # this will never be reached\n\t\t# return Counter(nums).most_common()[-1][0]  # one-liner, but TC O(nlogn)"}
{"prompt": "def reverseStr(self, s: str, k: int) -> str:\n        if len(s)<(k):return s[::-1]\n        if len(s)<(2*k):return (s[:k][::-1]+s[k:])\n        return s[:k][::-1]+s[k:2*k]+self.reverseStr(s[2*k:],k)"}
{"prompt": "def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:\n\t\trow, col = len(mat), len(mat[0])\n\t\tqueue = deque([])\n\n\t\tfor x in range(row):\n\t\t\tfor y in range(col):\n\t\t\t\tif mat[x][y] == 0:\n\t\t\t\t\tqueue.append((x, y, 1))\n\n\n\t\treturn self.bfs(row, col, queue, mat)\n\n\tdef bfs(self, row, col, queue, grid):\n\t\tvisited = set()\n\t\twhile queue:\n\t\t\tx, y, steps = queue.popleft()\n\n\t\t\tfor nx, ny in [[x+1,y], [x-1,y], [x,y+1], [x,y-1]]:\n\t\t\t\tif 0<=nx<row and 0<=ny<col and (nx,ny) not in visited:\n\t\t\t\t\tif grid[nx][ny] == 1:\n\t\t\t\t\t\tvisited.add((nx,ny))\n\t\t\t\t\t\tgrid[nx][ny] = steps\n\t\t\t\t\t\tqueue.append((nx, ny, steps+1))\n\n\t\treturn grid"}
{"prompt": "def __init__(self):\n\t    self.diameter = 0  # stores the maximum diameter calculated\n\t\n    def depth(self, node: Optional[TreeNode]) -> int:\n        \"\"\"\n        This function needs to do the following:\n            1. Calculate the maximum depth of the left and right sides of the given node\n            2. Determine the diameter at the given node and check if its the maximum\n        \"\"\"\n        # Calculate maximum depth\n        left = self.depth(node.left) if node.left else 0\n        right = self.depth(node.right) if node.right else 0\n        # Calculate diameter\n        if left + right > self.diameter:\n            self.diameter = left + right\n        # Make sure the parent node(s) get the correct depth from this node\n        return 1 + (left if left > right else right)\n    \n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\n        # if not root:\n        #     return 0\n        self.depth(root)  # root is guaranteed to be a TreeNode object\n        return self.diameter"}
{"prompt": "def removeBoxes(self, boxes: List[int]) -> int:\n        \n        @cache\n        def fn(lo, hi, k): \n            \"\"\"Return max score of removing boxes from lo to hi with k to the left.\"\"\"\n            if lo == hi: return 0 \n            while lo+1 < hi and boxes[lo] == boxes[lo+1]: lo, k = lo+1, k+1\n            ans = (k+1)*(k+1) + fn(lo+1, hi, 0)\n            for mid in range(lo+2, hi): \n                if boxes[lo] == boxes[mid]: \n                    ans = max(ans, fn(lo+1, mid, 0) + fn(mid, hi, k+1))\n            return ans \n                \n        return fn(0, len(boxes), 0)"}
{"prompt": "def findCircleNum(self, M):\n        \"\"\"\n        :type M: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n = len(M)  #1\n        visited = [False]*n  #2\n        count = 0  #3\n        \n        if not M:  #4\n            return 0  #5\n        \n        def dfs(u):  #6\n            for v in range(n):  #7\n                if M[u][v] == 1 and visited[v] == False:  #8\n                    visited[v] = True  #9\n                    dfs(v)  #10\n        \n        \n        for idx in range(n): #11\n            if visited[idx] == False: #12\n                count += 1 #13\n                visited[idx] == True #14\n                dfs(idx) #15\n        \n        return count #16"}
{"prompt": "def checkRecord(self, s: str) -> bool:\n    \treturn (s.count('A') < 2) and ('LLL' not in s)\n\t\t\n\t\t\n- Junaid Mansuri\n(LeetCode ID)@hotmail.com"}
{"prompt": "def checkRecord(self, n: int) -> int:\n    \tC, m = [1,1,0,1,0,0], 10**9 + 7\n    \tfor i in range(n-1):\n    \t\ta, b = sum(C[:3]) % m, sum(C[3:]) % m\n    \t\tC = [a, C[0], C[1], a + b, C[3], C[4]]\n    \treturn (sum(C) % m)"}
{"prompt": "def optimalDivision(self, nums: List[int]) -> str:\n        if len(nums) <= 2: return \"/\".join(map(str, nums))\n        return f'{nums[0]}/({\"/\".join(map(str, nums[1:]))})'"}
{"prompt": "def leastBricks(self, wall: List[List[int]]) -> int:\n        count = defaultdict(int)\n        tot = len(wall)\n        if tot == 1 and len(wall[0]) > 1:\n            return 0\n        elif tot == 1 and len(wall[0]) == 1:\n            return 1\n        \n        for w in wall:\n            s = 0 \n            for i in range(len(w)):\n                s += w[i]\n                count[s] += 1\n            count[s] -= 1\n\n        return tot - max(count.values())"}
{"prompt": "def nextGreaterElement(self, n: int) -> int:\n        m=list(str(n))                       ## n = 257761\n        l = len(m)                           ## l = 6\n        d = {}\n        res = str(n)\n        \n        ## reading character backwards: 1->6->7->7->5 break\n        for i,c in enumerate(m[::-1]): \n            if not d:\n                d[c]=1                       ## d = {'1':1}\n            else:\n                if all(c >= x for x in d):\n                    d[c]=d.get(c,0)+1        ## d = {'1':1,'6':1,'7':2} \n                else:\n                    d[c]=d.get(c,0)+1        ## d = {'1':1,'5':1,'6':1,'7':2}\n                    res = ''.join(m[:l-1-i])        ## res = '2'\n                    stock = sorted(list(d.keys()))  ## stock = ['1','5','6','7']\n                    cplus = stock[stock.index(c)+1] ## cplus = '6' just > '5'\n                    res += cplus                    ## res = '26'\n                    d[cplus] -= 1                   ## d = {'1':1,'5':1,'6':0,'7':2}\n                    res += ''.join([x * d[x] for x in stock]) \n\t\t\t\t\t                                ## res = '26' + '1577'\n                    break\n        \n        return int(res) if n < int(res) < (2**31-1) else -1"}
{"prompt": "def reverseWords(self, s: str) -> str:\n    \ts = s.split()\n    \tfor i in range(len(s)): s[i] = s[i][::-1]\n    \treturn \" \".join(s)\n\t\n\n- Junaid Mansuri\n(LeetCode ID)@hotmail.com"}
{"prompt": "def intersect(self, quadTree1: 'Node', quadTree2: 'Node') -> 'Node':\n        if quadTree1.isLeaf: return quadTree1 if quadTree1.val else quadTree2 # boundary condition \n        if quadTree2.isLeaf: return quadTree2 if quadTree2.val else quadTree1 # boundary condition \n        tl = self.intersect(quadTree1.topLeft, quadTree2.topLeft)\n        tr = self.intersect(quadTree1.topRight, quadTree2.topRight)\n        bl = self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)\n        br = self.intersect(quadTree1.bottomRight, quadTree2.bottomRight)\n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf and tl.val == tr.val == bl.val == br.val: \n            return Node(tl.val, True, None, None, None, None)\n        return Node(None, False, tl, tr, bl, br)"}
{"prompt": "def maxDepth(self, root: 'Node') -> int:\n        \n        if root is None:\n            # empty node or empty tree\n            return 0\n    \n        else:\n            # DFS to choose the longest path\n            \n            if root.children:\n                # current node has subtrees\n                return max( self.maxDepth(child) for child in root.children ) + 1\n            \n            else:\n                # current node is leaf node\n                return 1"}
{"prompt": "def subarraySum(self, nums: List[int], k: int) -> int:\n\n\t\tans=0\n\t\tprefsum=0\n\t\td={0:1}\n\n\t\tfor num in nums:\n\t\t\tprefsum = prefsum + num\n\n\t\t\tif prefsum-k in d:\n\t\t\t\tans = ans + d[prefsum-k]\n\n\t\t\tif prefsum not in d:\n\t\t\t\td[prefsum] = 1\n\t\t\telse:\n\t\t\t\td[prefsum] = d[prefsum]+1\n\n\t\treturn ans"}
{"prompt": "def arrayPairSum(self, nums: List[int]) -> int:\n        nums.sort()\n        sum_ = 0\n        for i in range(0,len(nums),2):\n            sum_ += nums[i]\n        return sum_\n\n# Time : 356 ms\n# Memory : 16.7 M"}
{"prompt": "def findTilt(self, root: Optional[TreeNode]) -> int:\n        def rec(node):\n            nonlocal res\n            if not node:\n                return 0\n            left_sum = rec(node.left)\n            right_sum = rec(node.right)\n            res += abs(left_sum - right_sum)\n            \n            return left_sum + node.val + right_sum\n        \n        res = 0\n        rec(root)\n        return res"}
{"prompt": "def find_next_palindrome(self, n, additive):\n        l = len(n)\n        if l == 0:\n            return 0\n        first_half = str(int(n[:l // 2 + l % 2]) + additive)\n        return int(first_half + first_half[(-1 - l%2)::-1])\n            \n    def nearestPalindromic(self, n: str) -> str:\n        m = int(n)\n        candidates = [self.find_next_palindrome(n, additive) for additive in range(-1, 2)] # Cases 1, 2, and 3\n        candidates.append(self.find_next_palindrome(\"9\"*(len(n)-1), 0)) # Case 4\n        candidates.append(self.find_next_palindrome(\"1\" + \"0\"*len(n), 0)) # Case 5\n\n        ans = None\n        for t in candidates:\n            if t == m:\n                continue\n            if ans is None or abs(ans - m) > abs(t - m) or (abs(ans - m) == abs(t - m) and t < m):\n                ans = t\n        return str(ans)"}
{"prompt": "def arrayNesting(self, nums: List[int]) -> int:\n        res, l = 0, len(nums)\n        globalSet = set()\n        for k in range(l):\n            if k not in globalSet:\n                currLength, currSet, val = 0, set(), k\n                while True:\n                    if nums[val] in currSet: break\n                    currSet.add(nums[val])\n                    globalSet.add(nums[val])\n                    currLength, val = currLength + 1, nums[val]\n                res = max(res, currLength)        \n        return res"}
{"prompt": "def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:\n        flatten = []\n        new_mat = []\n        for row in mat:\n            for num in row:\n                flatten.append(num)\n                \n        if r * c != len(flatten):   # when given parameters is NOT possible and legal\n            return mat\n        else:\n            for row_index in range(r):\n                new_mat.append(flatten[row_index * c : row_index * c + c])\n            return new_mat"}
{"prompt": "def checkInclusion(self, s1: str, s2: str) -> bool:\n        window = len(s1)\n        s1_c = Counter(s1)\n        \n        for i in range(len(s2)-window+1):\n            s2_c = Counter(s2[i:i+window])\n            if s2_c == s1_c:\n                return True\n            \n        return False"}
{"prompt": "def isSubtree(self, s: TreeNode, t: TreeNode) -> bool:\n        if not s: \n            return False\n        if self.isSameTree(s, t): \n            return True\n        return self.isSubtree(s.left, t) or self.isSubtree(s.right, t)\n\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if p and q:\n            return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n        return p is q"}
{"prompt": "def distributeCandies(self, candyType: List[int]) -> int:\n        return min(len(candyType) //2, len(set(candyType)))"}
{"prompt": "# The plan is to accrete the number of paths from the starting cell, which\n                        # is the sum of (a) the number of adjacent positions that are off the grid\n                        # and (b) the number of paths from the adjacent cells in the grid within \n                        # maxMove steps. We determine (b) recursively.\n\n    def findPaths(self, m: int, n: int, maxMove: int, startRow: int, startColumn: int) -> int:\n\n        @lru_cache(None)                                # <-- Many cells are revisited so we cache the previous calls\n        def dp (x,y,steps = maxMove):\n            if x not in range(m) or y not in range(n):  # <-- Moved off the grid so increment the tally\n                return 1\n            if not steps:                               # <-- Ran out of the maxMove steps\n                return 0\n\n            ans, dx, dy = 0, 1, 0\n            for _ in range(4):\n                ans+= dp(x+dx, y+dy, steps-1)           # <-- visit the adjacent cells\n                dx, dy = dy,-dx                         # <-- iterates thru the directions:\n\t\t\t\t                                        #         south => east => north => west \n\n            return ans  \n\n        return dp (startRow, startColumn)%1000000007\n\t\t\n\t\t# Thanks to XixiangLiu for fixing a number of my errors in the original post."}
{"prompt": "def findUnsortedSubarray(self, nums: List[int]) -> int:\n        sorted_nums = sorted(nums)\n        \n        l, u = len(nums) - 1,0\n        for i in range(len(nums)):\n            if nums[i]!=sorted_nums[i]:\n                l=min(l, i)\n                u=max(u, i)\n        \n        \n        return 0 if l>=u else u-l+1"}
{"prompt": "def minDistance(self, word1: str, word2: str) -> int:\n        m,n=len(word1),len(word2)\n        @cache\n        def lcs(i, j): # find longest common subsequence\n            if i==m or j==n:\n                return 0            \n            return 1 + lcs(i+1, j+1) if word1[i]==word2[j] else  max(lcs(i+1, j), lcs(i,j+1))                               \n        # subtract the lcs length from both the strings \n        # the difference is the number of characters that has to deleted\n        return m + n - 2*lcs(0,0)"}
{"prompt": "def outerTrees(self, points: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        Use Monotone Chain algorithm.\n        \"\"\"\n        def is_clockwise(\n                p0: List[int], p1: List[int], p2: List[int]) -> bool:\n            \"\"\"\n            Determine the orientation the slope p0p2 is on the clockwise\n            orientation of the slope p0p1.\n            \"\"\"\n            return (p1[1] - p0[1]) * (p2[0] - p0[0]) > \\\n                (p2[1] - p0[1]) * (p1[0] - p0[0])\n\n        sortedPoints = sorted(points)\n\n        # Scan from left to right to generate the lower part of the hull.\n        hull = []\n        for p in sortedPoints:\n            while len(hull) > 1 and is_clockwise(hull[-2], hull[-1], p):\n                hull.pop()\n\n            hull.append(p)\n\n        if len(hull) == len(points):  # All the points are on the perimeter now.\n            return hull\n\n        # Scan from right to left to generate the higher part of the hull.\n        # Remove the last point first as it will be scanned again.\n        hull.pop()\n        for p in reversed(sortedPoints):\n            while len(hull) > 1 and is_clockwise(hull[-2], hull[-1], p):\n                hull.pop()\n\n            hull.append(p)\n\n        # Pop the first point as it is already added to hull when processing\n        # the lower part.\n        hull.pop()\n\n        return hull"}
{"prompt": "def preorder(self, root):\n        # To store the output result...\n        output = []\n        self.traverse(root, output)\n        return output\n    def traverse(self, root, output):\n        # Base case: If root is none...\n        if root is None: return\n        # Append the value of the root node to the output...\n        output.append(root.val)\n        # Recursively traverse each node in the children array...\n        for child in root.children:\n            self.traverse(child, output)"}
{"prompt": "def postorder(self, root: 'Node') -> List[int]:\n        \n        def dfs(node):\n            \"\"\"Populate ans via post-order traversal.\"\"\"\n            if not node: return \n            for child in node.children: dfs(child)\n            ans.append(node.val)\n            \n        ans = []\n        dfs(root)\n        return ans"}
{"prompt": "def isValid(self, code: str) -> bool:\n        if code[0] != '<' or code[-1] != '>': return False\n        i, n = 0, len(code)\n        stk = []\n        while i < n:\n            if code[i] == '<':\n                if i != 0 and code[i: i + 9] == '<![CDATA[':\n                    if not stk: return False\n                    j = i + 9\n                    while j + 3 <= n and code[j: j + 3] != ']]>': j += 1\n                    if code[j: j + 3] == ']]>': i = j + 3\n                    else: return False\n                else:\n                    start = i\n                    isend = False\n                    i += 1\n                    if i >= n: return False\n                    if code[i] == r'/':\n                        isend = True\n                        i += 1\n                    if i >= n: return False\n                    tag = ''\n                    while i < n and code[i] != '>':\n                        if not code[i].isupper(): return False\n                        tag += code[i]\n                        i += 1\n                    if i >= n or len(tag) == 0 or len(tag) > 9: return False\n                    if isend:\n                        if not stk or stk[-1] != tag: return False\n                        stk.pop(-1)\n                    else:\n                        if start != 0 and not stk: return False\n                        stk.append(tag)\n                    i += 1\n            else:\n                if not stk: return False\n                while i < n and code[i] != '<': i += 1\n        return not stk"}
{"prompt": "def fractionAddition(self, exp: str) -> str:\n        \n        if not exp:\n            return \"0/1\"\n        \n        if exp[0] != '-':\n            exp = '+' + exp\n        \n        # Parse the expression to get the numerator and denominator of each fraction\n        num = []\n        den = []\n        pos = True\n        i = 0\n        while i < len(exp):\n            # Check sign\n            pos = True if exp[i] == '+' else False\n            \n            # Get numerator\n            i += 1\n            n = 0\n            while exp[i].isdigit():\n                n = n*10 + int(exp[i])\n                i += 1\n            num.append(n if pos else -n)\n            \n            # Get denominator\n            i += 1\n            d = 0\n            while i < len(exp) and exp[i].isdigit():\n                d = d*10 + int(exp[i])\n                i += 1\n            den.append(d)\n        \n        # Multiply the numerator of all fractions so that they have the same denominator\n        denominator = functools.reduce(lambda x, y: x*y, den)\n        for i,(n,d) in enumerate(zip(num, den)):\n            num[i] = n * denominator // d\n        \n        # Sum up all of the numerator values\n        numerator = sum(num)\n        \n        # Divide numerator and denominator by the greatest common divisor (gcd)\n        g = math.gcd(numerator, denominator)\n        numerator = numerator // g\n        denominator = denominator // g\n        \n        return f\"{numerator}/{denominator}\""}
{"prompt": "def validSquare(self, p1: List[int], p2: List[int], p3: List[int], p4: List[int]) -> bool:\n        def dist(point1,point2):\n            return (point1[0]-point2[0])**2+(point1[1]-point2[1])**2\n            \n        D=[\n        dist(p1,p2),\n        dist(p1,p3),\n        dist(p1,p4),\n        dist(p2,p3),\n        dist(p2,p4),\n        dist(p3,p4)\n        ]\n        D.sort()\n        return 0<D[0]==D[1]==D[2]==D[3] and D[4]==D[5]"}
{"prompt": "def findLHS(self, nums: List[int]) -> int:\n\t\ttmp = Counter(nums)\n\t\tkeys = tmp.keys()\n\t\tmax = 0\n\t\tfor num in keys:\n\t\t\tif num - 1 in keys:\n\t\t\t\tif tmp[num - 1] + tmp[num] > max:\n\t\t\t\t\tmax = tmp[num - 1] + tmp[num]\n\t\treturn max"}
{"prompt": "def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\n        min_row = m\n        min_col = n\n        for i in range(len(ops)):\n            min_row=min(min_row, ops[i][0])\n            min_col=min(min_col, ops[i][1])\n        return min_row*min_col"}
{"prompt": "def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\n        d = {}\n        d2 = {}\n        min_ = 5000\n        ret = []\n\n        for i in range(len(list1)):\n            d[list1[i]] = i+1\n\n        for i in range(len(list2)):\n            a = d.get(list2[i], 0)\n            if a:\n                b = a+i-1\n                if b <= min_:\n                    min_ = b\n                    d2[list2[i]] = b\n\n        for k,v in d2.items():\n            if v <= min_:\n                ret.append(k)\n\n        return ret"}
{"prompt": "def findIntegers(self, n: int) -> int:\n        # f stores the fibonacci numbers\n        f = [1, 2]\n        for i in range(2, 30):\n            f.append(f[-1]+f[-2])\n        \n        # last_seen tells us if there was a one right before. \n        # If that is the case, we are done then and there!\n        # ans is the answer\n        ans, last_seen = 0, 0\n        for i in reversed(range(30)):\n            if (1 << i) &amp; n: # is the ith bit set?\n                ans += f[i]\n                if last_seen: \n                    ans -= 1\n                    break\n                last_seen = 1\n            else:\n                last_seen = 0\n        return ans+1"}
{"prompt": "def canPlaceFlowers(self, f: List[int], n: int) -> bool:\n        L, i, c, f = len(f)-2, -2, 0, f + [0]\n        while i < L:\n        \ti += 2\n        \tif f[i] == 1: continue\n        \tif f[i+1] == 0: c += 1\n        \telse: i += 1\n        return n <= c\n\t\t\n\t\t\n\t\t\n\t\t\ndef canPlaceFlowers(self, f: List[int], n: int) -> bool:\n    \tL, f, i, c = len(f), [0] + f + [0], 1, 0\n    \twhile i <= L:\n    \t\tif f[i-1:i+2] == [0,0,0]: c, i = c + 1, i + 1\n    \t\ti += 1\n    \treturn n <= c\n\t\t\n\t\t\n\t\t\n\t\t\ndef canPlaceFlowers(self, f: List[int], n: int) -> bool:\n    \tL, f, s, c = len(f), f + [0,1], 0, 1\n    \tfor i in range(L+2):\n    \t\tif f[i] == 1: s, c = s + max(0,c-1)//2, 0\n    \t\telse: c += 1\n    \treturn n <= s\n\t\t\n\t\t\n\t\t\n- Junaid Mansuri\n(LeetCode ID)@hotmail.com"}
{"prompt": "def tree2str(self, t: TreeNode) -> str:\n        sb = [] # init string builder\n        \n        # helper function to create result\n        def helper(node: TreeNode) -> None: \n            if not node:\n                return\n            \n            sb.append(str(node.val))\n            \n            if not node.left and not node.right:\n                # leaf node, stop processing\n                return\n            \n            sb.append('(')          # always wrap left node with parenthesis when right node exist\n            helper(node.left)       # process left node recursively \n            sb.append(')')                         \n\n            if node.right:          # adding parenthesis for the right node only if it is not empty\n                sb.append('(')\n                helper(node.right)\n                sb.append(')') \n        \n        helper(t)\n\n        return ''.join(sb)"}
{"prompt": "def findDuplicate(self, paths: List[str]) -> List[List[str]]:\n        m = defaultdict(list)\n        for p in paths:\n            # 1. split the string by ' '\n            path = p.split()\n            # the first string is the directory path\n            # the rest of them are just file names with content\n            directoryPath, rest = path[0], path[1:]\n            # for each file names with content\n            for f in rest:\n                # we retrieve the file name and the file content\n                fileName, fileContent = f.split('(')[0], f.split('(')[1][:-1]\n                # then group {directoryPath}/{fileName} by file content\n                m[fileContent].append(\"{}/{}\".format(directoryPath, fileName))\n        # return the file list only when the size is greater than 1, meaning they are duplicate files\n        return [m[k] for k in m.keys() if len(m[k]) > 1]"}
{"prompt": "def triangleNumber(self, nums: List[int]) -> int:\n        nums.sort()\n        ans = 0\n        for i in range(len(nums)): \n            lo, hi = 0, i-1\n            while lo < hi: \n                if nums[lo] + nums[hi] > nums[i]:\n                    ans += hi - lo \n                    hi -= 1\n                else: lo += 1\n        return ans"}
{"prompt": "def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:\n        if not root1: return root2\n        if not root2: return root1\n        queue = deque([(root1, root2)])\n        while queue:\n            current_root1, current_root2 = queue.pop()\n            if current_root1.left and current_root2.left: queue.append((current_root1.left, current_root2.left))\n            elif not current_root1.left: current_root1.left = current_root2.left\n            if current_root1.right and current_root2.right: queue.append((current_root1.right, current_root2.right))\n            elif not current_root1.right: current_root1.right = current_root2.right\n            current_root1.val += current_root2.val\n        return root1"}
{"prompt": "def leastInterval(self, tasks: List[str], n: int) -> int:\n        cnt = [0] * 26\n        for i in tasks: cnt[ord(i) - ord('A')] += 1\n        mx, mxcnt = max(cnt), 0\n        for i in cnt: \n            if i == mx: mxcnt += 1\n        return max((mx - 1) * (n + 1) + mxcnt, len(tasks))"}
{"prompt": "def addOneRow(self, root: TreeNode, v: int, d: int, side = \"left\") -> TreeNode:\n        if d == 1:\n            res = TreeNode(v)\n            setattr(res, side, root)\n            return res\n        if root:\n            root.left = self.addOneRow(root.left, v, d - 1)\n            root.right = self.addOneRow(root.right, v, d - 1, 'right')\n        return root"}
{"prompt": "def maximumProduct(self, nums: List[int]) -> int:\n        max1 = max2 = max3 = float(\"-inf\")\n        min1 = min2 = float(\"inf\")\n        \n        for num in nums: \n            if num > max1:\n                max1, max2, max3 = num, max1, max2\n            elif num > max2:\n                max2, max3 = num, max2\n            elif num > max3:\n                max3 = num\n                \n            if num < min1:\n                min1, min2 = num, min1\n            elif num < min2:\n                min2 = num\n        \n        return max(max2*max3, min1*min2) * max1"}
{"prompt": "# A very good description of the dp solution is at\n                        # https://leetcode.com/problems/k-inverse-pairs-array/solution/ \n                        # The code below uses two 1D arrays--dp and tmp--instead if a \n                        # 2D array. tmp replaces dp after each i-iteration.\n    def kInversePairs(self, n: int, k: int) -> int:\n        dp, mod = [1]+[0] * k, 1000000007\n        \n        for i in range(n):\n            tmp, sm = [], 0\n            for j in range(k + 1):\n                sm+= dp[j]\n                if j-i >= 1: sm-= dp[j-i-1]\n                sm%= mod\n                tmp.append(sm)\n            dp = tmp\n            #print(dp)       # <-- uncomment this line to get a sense of dp from the print output\n\t\t\t                 #     try n = 6, k = 4; your answer should be 49.\n        return dp[k]"}
{"prompt": "def scheduleCourse(self, courses: List[List[int]]) -> int:\n        courses.sort(key=lambda c: c[1])\n        A, curr = [], 0\n        for dur, ld in courses:\n            heapq.heappush(A,-dur)\n            curr += dur\n            if curr > ld: curr += heapq.heappop(A)\n        return len(A)"}
{"prompt": "def smallestRange(self, nums: List[List[int]]) -> List[int]:\n        k=len(nums)\n        maxx=-float('inf')\n        ans=[0,float('inf')]\n        heap=[]\n        for i in range(k):\n            heap.append((nums[i][0],i,0))\n            if nums[i][0]>maxx:maxx=nums[i][0]\n        heapq.heapify(heap)\n        while True:\n            val,row,col= heapq.heappop(heap)\n            tmp=maxx-val\n            if tmp<ans[1]-ans[0]:ans=[val,maxx]\n            elif tmp==ans[1]-ans[0] and val<ans[0]:ans=[val,maxx]\n            if col+1==len(nums[row]):break        \n            if nums[row][col+1]>maxx:maxx=nums[row][col+1]\n            heapq.heappush(heap,(nums[row][col+1],row,col+1))\n        return ans"}
{"prompt": "def judgeSquareSum(self, c: int) -> bool:\n        low = 0\n        high = int(sqrt(c))\n        \n        if high**2 == c:\n            return True\n        \n        while low<=high:\n            x = low **2 + high **2\n            if x == c:\n                return True\n            if x > c:\n                high-=1\n            else:\n                low+=1\n        return False"}
{"prompt": "def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\n        helper = lambda log: (int(log[0]), log[1], int(log[2])) # to covert id and time to integer\n        logs = [helper(log.split(':')) for log in logs]         # convert [string] to [(,,)]\n        ans, s = [0] * n, []                                    # initialize answer and stack\n        for (i, status, timestamp) in logs:                     # for each record\n            if status == 'start':                               # if it's start\n                if s: ans[s[-1][0]] += timestamp - s[-1][1]     # if s is not empty, update time spent on previous id (s[-1][0])\n                s.append([i, timestamp])                        # then add to top of stack\n            else:                                               # if it's end\n                ans[i] += timestamp - s.pop()[1] + 1            # update time spend on `i`\n                if s: s[-1][1] = timestamp+1                    # if s is not empty, udpate start time of previous id; \n        return ans"}
{"prompt": "def averageOfLevels(self, root: TreeNode) -> List[float]:\n        \n        if not root:\n            \n            # Quick response for empty tree\n            return []\n        \n        traversal_q = [root]\n        \n        average = []\n        \n        while traversal_q:\n            \n            # compute current level average\n            cur_avg = sum( (node.val for node in traversal_q if node) ) / len(traversal_q)\n            \n            # add to result\n            average.append( cur_avg )\n            \n            # update next level queue\n            next_level_q = [ child for node in traversal_q for child in (node.left, node.right) if child ]\n            \n            # update traversal queue as next level's\n            traversal_q = next_level_q\n            \n        return average"}
{"prompt": "def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\n        n = len(price)\n        @lru_cache(maxsize=None)\n        def dfs(needs):\n            ans = sum([i*j for i, j in zip(price, needs)]) \n            cur = sys.maxsize\n            for s in special:\n                new_needs, ok = [], True\n                for i in range(n):\n                    need, give = needs[i], s[i]\n                    if need < give:  # if over purchase, ignore this combination\n                        ok = False\n                        break\n                    new_needs.append(need-give)    \n                if ok: cur = min(cur, dfs(tuple(new_needs)) + s[-1])\n            return min(ans, cur)\n        return dfs(tuple(needs))"}
{"prompt": "def numDecodings(self, s: str) -> int:\n        non_zero = ['1', '2', '3', '4', '5', '6', '7', '8', '9']\n        first_incl, second_incl = 1, 0\n        first_excl, second_excl = 0, 0\n        \n        if s[0] in non_zero:\n            second_incl = 1\n        if s[0] == '*':\n            second_incl = 9\n            \n        for i in range(1, len(s)):\n            new_incl, new_excl = 0, 0\n            if s[i] == '*':\n                new_incl = 9 * (second_incl + second_excl)\n                \n                if s[i-1] == '1':\n                    # number is of type (1, *)\n                    new_excl = 9 * (first_incl + first_excl)\n                    \n                elif s[i-1] == '2':\n                    # number is of type (2, *)\n                    new_excl = 6 * (first_incl + first_excl)\n                    \n                elif s[i-1] == '*':\n                    # number is of type (*, *)\n                    new_excl = 15 * (first_incl + first_excl)\n            else:\n                if s[i] in non_zero:\n                    new_incl = second_incl + second_excl\n                        \n                if s[i-1] == '*':\n                    # number is of type (*,digit)\n                    if int(s[i]) <= 6:\n                        new_excl = 2 * (first_excl + first_incl)\n                    else:\n                        new_excl = first_incl + first_excl\n                        \n                else:\n                    # number is of type (digit,digit)\n                    val = int(s[i-1:i+1])\n                    if 10 <= val <= 26:\n                        new_excl = first_incl + first_excl\n                    else:\n                        new_excl = 0\n            first_incl, first_excl = second_incl, second_excl\n            second_incl, second_excl = new_incl, new_excl\n        return (second_incl + second_excl) % (10**9 + 7)"}
{"prompt": "def solveEquation(self, equation: str) -> str:\n        def helper(l,r): # left inclusive and right exclusive\n            constant = unknown = 0\n            sign,val = 1,''\n            while l < r:\n                if equation[l].isnumeric():\n                    val += equation[l]\n                elif equation[l] == 'x':\n                    unknown += sign*int(val or '1') # in case the coefficient is 1\n                    val = ''\n                else: # meet a +/-\n                    if val:\n                        constant += sign*int(val)\n                    sign = 1 if equation[l]=='+' else -1\n                    val = ''\n                l += 1\n            if val: # if the last digit is a number\n                constant += sign*i\n            return constant,unknown\n    \n        mid = equation.find('=')\n        constant1,unknown1 = helper(0,mid)\n        constant2,unknown2 = helper(mid+1,len(equation))\n        const,var = constant2-constant1,unknown1-unknown2\n        # print(a,b)\n        if var == 0:\n            if const == 0: return \"Infinite solutions\"\n            else: return \"No solution\"\n        else: return 'x={}'.format(const//var)"}
{"prompt": "def findMaxAverage(self, nums: List[int], k: int) -> float:\n    \tM = d = 0\n    \tfor i in range(len(nums)-k):\n    \t\td += nums[i+k] - nums[i]\n    \t\tif d > M: M = d\n    \treturn (sum(nums[:k])+M)/k\n\t\t\n\t\t\n- Python 3\n- Junaid Mansuri"}
{"prompt": "def findErrorNums(self, nums: List[int]) -> List[int]:\n        c=Counter(nums)\n        l=[0,0]\n        for i in range(1,len(nums)+1):\n            if c[i]==2:\n                l[0]=i\n            if c[i]==0:\n                l[1]=i\n        return l"}
{"prompt": "def findLongestChain(self, pairs: List[List[int]]) -> int:\n        pairs.sort()\n        rt = 1\n        l = pairs[0]\n        for r in range(1,len(pairs)):\n            if l[1] < pairs[r][0]:\n                rt += 1 \n                l = pairs[r]\n            elif pairs[r][1]<l[1]:\n                l = pairs[r]\n        return rt"}
{"prompt": "def countSubstrings(self, s: str) -> int:\n\t    L, r = len(s), 0\n\t    for i in range(L):\n\t    \tfor a,b in [(i,i),(i,i+1)]:\n\t    \t\twhile a >= 0 and b < L and s[a] == s[b]: a -= 1; b += 1\n\t    \t\tr += (b-a)//2\n\t    return r\n\t\t\n\t\t\n- Junaid Mansuri\n(LeetCode ID)@hotmail.com"}
{"prompt": "def replaceWords(self, dictionary: List[str], sentence: str) -> str:\n        d = {w:len(w) for w in dictionary}\n        mini, maxi = min(d.values()), max(d.values())\n        wd = sentence.split()\n        rt = []\n        for s in wd:\n            c = s \n            for k in range(mini,min(maxi,len(s))+1):\n                ss = s[:k]\n                if ss in d:\n                    c = ss \n                    break \n            rt.append(c)\n        return \" \".join(rt)"}
{"prompt": "def predictPartyVictory(self, senate: str) -> str:\n        n = len(senate)\n        s, banned = set(), [False] * n\n        ban_d = ban_r = 0\n        while len(s) != 1:\n            s = set()\n            for i, p in enumerate(senate):\n                if banned[i]: continue\n                if p == 'R':\n                    if ban_r > 0:           # current R being banned\n                        ban_r -= 1\n                        banned[i] = True\n                    else:                   # if current R is valid, it will ban D\n                        ban_d += 1\n                        s.add('R')\n                else:        \n                    if ban_d > 0:           # current D being banned\n                        ban_d -= 1\n                        banned[i] = True\n                    else:                   # if current D is valid, it will ban R\n                        ban_r += 1\n                        s.add('D')\n        return 'Radiant' if s.pop() == 'R' else 'Dire'"}
{"prompt": "def minSteps(self, n: int) -> int:\n        \n        dp = [float('inf')] * (n+1)\t\n\t\t## Intialize a dp array to store the solutions of sub problems i.e. number of steps needed\n\t\n        dp[1] = 0\n\t\t## Intially first element of dp array with 0 as 'A' is already present and we haven't consumed any steps yet. \n\t\t## As the value of n is from [1,3000] and initally 'A' is already present so we don't need to bother about the dp[0]\n        \n        divisors = []\n\t\t## This is to store the divisors of N\n\t\t\n        for i in range(1, n//2 + 1):\n            if n % i == 0:\n                divisors.append(i)\n\t\t## We have stored all the divisors. For n = 10, divisors = [1,2,5]\n        \n        for j in divisors:\n            dp[j] += 1\n\t\t\t##To copy the current number of A's, we add one step\n\t\t\t\n            for i in range(j+1, n+1):\n                if i % j == 0:\n\t\t\t\t## We can only form the string length which is divisible by j \n                    dp[i] = min(dp[i], dp[i-j] + 1)\n\t\t\t\t\t## Compare with previous number of steps and update with the minimum\n        return dp[-1]\n\t\t#Return last value of dp i.e. N"}
{"prompt": "def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:\n        \n        seen = collections.defaultdict(int)\n        res = []\n        \n        def helper(node):\n            if not node:\n                return\n            sub = tuple([helper(node.left), node.val, helper(node.right)])\n            if sub in seen and seen[sub] == 1:\n                res.append(node)\n            seen[sub] += 1\n            return sub\n        \n        helper(root)\n        return res"}
{"prompt": "def findTarget(self, root: TreeNode, k: int) -> bool:\n        queue = [root]\n        unique_set = set()\n        \n        while len(queue) > 0:\n            current = queue.pop()\n            if k - current.val in unique_set: return True\n            unique_set.add(current.val)\n            if current.left: queue.append(current.left)\n            if current.right: queue.append(current.right)\n        \n        return False"}
{"prompt": "def constructMaximumBinaryTree(self, nums: List[int]) -> TreeNode:\n        \n        # base case\n        if not nums:\n            return None\n        \n        max_val = max(nums)\n        max_idx = nums.index(max_val)\n        root = TreeNode(max_val)\n        \n        root.left = self.constructMaximumBinaryTree(nums[:max_idx])\n        root.right = self.constructMaximumBinaryTree(nums[max_idx+1:])\n        \n        return root"}
{"prompt": "def printTree(self, root: TreeNode) -> List[List[str]]:\n        height = 0\n        def dfs(node, h):                               # Find height\n            nonlocal height\n            height = max(height, h)\n            if node.left:\n                dfs(node.left, h+1)\n            if node.right:    \n                dfs(node.right, h+1)\n        dfs(root, 0)\n        n = 2 ** (height + 1) - 1                       # Get `n`\n        offset = (n - 1) // 2                           # Column for root node\n        ans = [[''] * n for _ in range(height + 1)]\n        q = [(root, 0, offset)]\n        for i in range(height+1):                       # BFS\n            tmp_q = []\n            while q:\n                cur, r, c = q.pop()\n                ans[r][c] = str(cur.val)\n                if cur.left:\n                    tmp_q.append((cur.left, r+1, c-2 ** (height - r - 1)))\n                if cur.right:    \n                    tmp_q.append((cur.right, r+1, c+2 ** (height - r - 1)))\n            q = tmp_q\n        return ans"}
{"prompt": "def judgeCircle(self, moves: str) -> bool:\n        return moves.count('L') == moves.count('R') and moves.count('U') == moves.count('D')\n\n\n- Python 3\n- Junaid Mansuri"}
{"prompt": "def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:\n\t\t# first binary search where the value 'x' should be in the sorted array\n        n = len(arr)\n        low, high = 0, n - 1\n        while low <= high:\n            mid = low + (high - low) // 2\n            if arr[mid] == x:\n                start, end = mid - 1, mid + 1\n                k -= 1\n                break\n            elif arr[mid] < x:\n                low = mid + 1\n            else:\n                high = mid - 1\n                \n        if low > high:\n            start = high\n            end = low\n        #  after we found where 'x' should be in the sorted array we expand to the left and to the right to find the next values until k (using two pointers start, end)\n        while k > 0:\n            if start == -1:\n                end += 1\n            elif end == n:\n                start -= 1\n            else:\n                if abs(arr[start] - x) <= abs(arr[end] - x):\n                    start -= 1\n                else:\n                    end += 1\n            k -= 1\n        return arr[start + 1:end]"}
{"prompt": "def isPossible(self, nums: List[int]) -> bool:\n\t\t\tlen1 = len2 = absorber = 0\n\t\t\tprev_num = nums[0] - 1\n\t\t\tfor streak_len, streak_num in Solution.get_streaks(nums):\n\t\t\t\tif streak_num == prev_num + 1:\n\t\t\t\t\tspillage = streak_len - len1 - len2\n\t\t\t\t\tif spillage < 0:\n\t\t\t\t\t\treturn False\n\t\t\t\t\tabsorber = min(absorber, spillage)\n\t\t\t\t\tlen1, len2, absorber = spillage - absorber, len1, absorber + len2\n\t\t\t\telse:\n\t\t\t\t\tif len1 or len2:\n\t\t\t\t\t\treturn False\n\t\t\t\t\tabsorber = 0\n\t\t\t\tprev_num = streak_num\n\t\t\treturn len1 == len2 == 0\n\n\t\t@staticmethod\n\t\tdef get_streaks(nums: List[int]):\n\t\t\tstreak_num = nums[0]\n\t\t\tstreak_len = 0\n\t\t\tfor num in nums:\n\t\t\t\tif num == streak_num:\n\t\t\t\t\tstreak_len += 1\n\t\t\t\telse:\n\t\t\t\t\tyield streak_len, streak_num\n\t\t\t\t\tstreak_num = num\n\t\t\t\t\tstreak_len = 1\n\t\t\tyield streak_len, streak_num"}
{"prompt": "def imageSmoother(self, M: List[List[int]]) -> List[List[int]]:\n        row, col = len(M), len(M[0])\n        res = [[0]*col for i in range(row)]\n        dirs = [[0,0],[0,1],[0,-1],[1,0],[-1,0],[1,1],[-1,-1],[-1,1],[1,-1]]\n        for i in range(row):\n            for j in range(col):\n                temp = [M[i+m][j+n] for m,n in dirs if 0<=i+m<row and 0<=j+n<col]\n                res[i][j] = sum(temp)//len(temp)\n        return res"}
{"prompt": "def widthOfBinaryTree(self, root: TreeNode) -> int:\n        Q = collections.deque()\n        Q.append((root,0))\n        ans = 0\n        while Q:\n            length = len(Q)\n            _, start = Q[0]\n            for i in range(length):\n                node, index = Q.popleft()\n                if node.left:\n                    Q.append((node.left, 2*index))\n                if node.right:\n                    Q.append((node.right, 2*index+1))\n            ans = max(ans, index-start+1)\n        return ans"}
{"prompt": "def strangePrinter(self, s: str) -> int:\n        s = \"\".join(ch for i, ch in enumerate(s) if i == 0 or s[i-1] != ch)\n        \n        @cache\n        def fn(lo, hi): \n            \"\"\"Return min ops to print s[lo:hi].\"\"\"\n            if lo == hi: return 0\n            ans = 1 + fn(lo+1, hi)\n            for mid in range(lo+1, hi): \n                if s[lo] == s[mid]: \n                    ans = min(ans, fn(lo, mid) + fn(mid+1, hi))\n            return ans \n        \n        return fn(0, len(s))"}
{"prompt": "def checkPossibility(self, nums: List[int]) -> bool:\n        cnt_violations=0        \n        for i in range(1, len(nums)):                       \n            if nums[i]<nums[i-1]:\n                if cnt_violations==1:\n                    return False\n                cnt_violations+=1\n                if i>=2 and nums[i-2]>nums[i]:\n                    nums[i]=nums[i-1]                       \n        return True"}
{"prompt": "def constructArray(self, n: int, k: int) -> List[int]:\n        lo, hi = 1, n \n        ans = []\n        while lo <= hi: \n            if k&amp;1: \n                ans.append(lo)\n                lo += 1\n            else: \n                ans.append(hi)\n                hi -= 1\n            if k > 1: k -= 1\n        return ans"}
{"prompt": "def findKthNumber(self, m: int, n: int, k: int) -> int:\n\t\t# special cases: k == 1,  k == m * n\n        if k == 1: \n            return 1\n        if k == m * n: \n            return m * n\n\t\t# make the matrix a tall one - height >= width \n\t\t# because later I will loop along the width. This will reduce the time\n        if n >= m: \n            m, n = n, m\n        \n\t\t# set the left, right boundaries and the ranks (the largest ranks for the values)\n\t\t# e.g. in a 3 * 3 table, number 2 shows up twice, taking up ranks from 2 to 3\n\t\t# so the largest rank here is 3 for number 2. \n        left = 1\n        # left_rank = 1\n        right = m * n\n        # right_rank = m * n\n        \n\t\t# binary search loop\n        while right - left > 1: \n            mid = (left + right) // 2\n\t\t\t# mid_rank is the largest rank of the number\n            mid_rank = 0\n\t\t\t\n\t\t\t# find the number of columns whose maximum < mid\n\t\t\t# (mid - 1) is to prevent counting the column with maximum == mid.\n            num_cols = (mid - 1) // m\n            residual = mid - num_cols * m\n            mid_rank += num_cols * m\n            \n\t\t\t# flag to track if mid is a valid value in the table\n            flag = 0\n            for i in range(num_cols + 1, n + 1): \n                if i == mid: \n                    mid_rank += 1\n                    break\n                else: \n                    mid_rank += mid // i\n                    if mid % i == 0: \n                        flag = 1\n            if flag == 1: \n\t\t\t\t# mid is a valid number in the table\n\t\t\t\t# if mid_rank == k: mid's largest rank is k and mid is the kth number\n\t\t\t\t# if mid_rank < k: kth number > mid, so left = mid\n\t\t\t\t# if mid_rank > k: mid's largest rank > k but mid still can be the kth number but kth number can be no larger than mid, so right = mid\n                if mid_rank == k: \n                    return mid\n                elif mid_rank > k: \n                    right = mid\n                else: \n                    left = mid\n            else: \n\t\t\t\t# mid is not a valid number in the table\n\t\t\t\t# if mid_rank == k, it means there are k values in the table smaller than mid\n\t\t\t\t# so there is a number smaller than mid ranking the kth. \n\t\t\t\t# mid_rank > k or mid_rank < k:  similar operation as above\n                if mid_rank >= k: \n                    right = mid\n                else: \n                    left = mid\n        \n\t\t# In case the while loop breaks out without returning\n\t\t# let's assume when right - left == 2 and mid == left + 1. The solution must be among the three. \n\t\t# right with its largest rank > k\n\t\t# left with its largest rank < k\n\t\t# Scenario 1. if mid is a valid number in the table\n\t\t## 1a. if mid_rank < k: right has its rank from mid_rank + 1 (<= k) till right_rank (> k)\n\t\t## 1b. if mid_rank > k: right = mid. Now right (== mid) has its rank from left_rank + 1 (<= k) till mid_rank (> k)\n\t\t## in both cases, right is the solution\n\t\t# Scenario 2. if mid is not a valid number in the table then we can just ignore mid and imply the solution is right. \n\t\t## But step by step, as mid is not in the table, mid_rank == left_rank, so left = mid. \n\t\t## So right has its rank from mid_rank + 1 (i.e. left_rank + 1) (<= k) till right_rank (> k). right is the solution. \n        return right"}
{"prompt": "def trimBST(self, root: TreeNode, low: int, high: int) -> TreeNode:\n\t\tif not root: return root\n\t\tif root.val < low: return self.trimBST(root.right, low, high)\n\t\tif root.val > high: return self.trimBST(root.left, low, high)\n\t\troot.left = self.trimBST(root.left, low, high)\n\t\troot.right = self.trimBST(root.right, low, high)\n\t\treturn root"}
{"prompt": "def maximumSwap(self, num: int) -> int:\n        s = list(str(num))\n        n = len(s)\n        for i in range(n-1):                                # find index where s[i] < s[i+1], meaning a chance to flip\n            if s[i] < s[i+1]: break\n        else: return num                                    # if nothing find, return num\n        max_idx, max_val = i+1, s[i+1]                      # keep going right, find the maximum value index\n        for j in range(i+1, n):\n            if max_val <= s[j]: max_idx, max_val = j, s[j]\n        left_idx = i                                        # going right from i, find most left value that is less than max_val\n        for j in range(i, -1, -1):    \n            if s[j] < max_val: left_idx = j\n        s[max_idx], s[left_idx] = s[left_idx], s[max_idx]   # swap maximum after i and most left less than max\n        return int(''.join(s))                              # re-create the integer"}
{"prompt": "def findSecondMinimumValue(self, root: TreeNode) -> int:\n\t\tdef inorderTraversal(root):\n\t\t\tif not root:\n\t\t\t\treturn []\n\t\t\telse:\n\t\t\t\treturn inorderTraversal(root.left) + [root.val] + inorderTraversal(root.right)\n\t\tr = set(inorderTraversal(root))\n\t\tif len(r)>=2:\n\t\t\treturn sorted(list(r))[1]\n\t\telse:\n\t\t\treturn -1"}
{"prompt": "def flipLights(self, n: int, m: int) -> int:\n        \n        def fn(n, m): \n            \"\"\"Return number of different status.\"\"\"\n            if m * n == 0: return 1\n            return fn(n-1, m-1) + fn(n-1, m)\n        \n        return fn(min(n, 3), min(m, 3))"}
{"prompt": "def findNumberOfLIS(self, nums: List[int]) -> int:\n        dp = [1] * len(nums)\n        ct = [1] * len(nums)\n        maxLen, maxCt = 0, 0\n        \n        # same as the LIS code, iterate\n        # over all the elements once and then\n        # from 0 -> i again to compute LISs\n        for i in range(len(nums)):\n            for j in range(i):\n                # If it's a valid LIS\n                if nums[i] > nums[j]:\n                    # and if the length\n                    # of LIS at i wrt j\n                    # is going to be increased\n                    # update the length dp\n                    # and since this is just one\n                    # continous LIS, count of i\n                    # will become same as that of j\n                    if dp[j]+1 > dp[i]:\n                        dp[i] = dp[j] + 1\n                        ct[i] = ct[j]\n                    # if on the other hand, the\n                    # length of the LIS at i becomes\n                    # the same as it was, it means\n                    # there's another LIS of this same\n                    # length, in this case, add the LIS\n                    # count of j to i, because the current\n                    # LIS count at i consists of ways to get\n                    # to this LIS from another path, and now\n                    # we're at a new path, so sum thse up\n                    # there's no point\n                    # in updating the length LIS here.\n                    elif dp[i] == dp[j] + 1:\n                        ct[i] += ct[j]\n            \n            # at any point, keep track\n            # of the maxLen and maxCt\n            # we'll use it to compute our result\n            if dp[i] > maxLen:\n                maxLen = dp[i]\n                \n        # now, we have the maxLength\n        # of the given nums, we can iterate\n        # over all 3 arrays (hypothetically)\n        # and just add up the count of all those\n        # LIS which are the longest (maxLen)\n        # and that's the result\n        for i in range(len(nums)):\n            if maxLen == dp[i]:\n                maxCt += ct[i]\n    \n \n        return maxCt"}
{"prompt": "def findLengthOfLCIS(self, nums: List[int]) -> int:\n        counter=1\n        temp=1\n        for i in range(0,len(nums)-1):\n            if nums[i]<nums[i+1]:\n                temp+=1\n                if temp>counter:\n                    counter=temp\n            else:\n                temp=1\n        return counter"}
{"prompt": "def cutOffTree(self, forest: List[List[int]]) -> int:\n        forest.append([0] * len(forest[0]))\n        for row in forest: row.append(0)\n        def bfs(end, start):\n            if end == start: return 0\n            visited, queue = set(), {start}\n            visited.add(start)\n            step = 0\n            while queue:\n                s = set()\n                step += 1\n                for p in queue:                    \n                    for dr, dc in ((-1, 0), (1, 0), (0, 1), (0, -1)):\n                        r, c = p[0] + dr, p[1] + dc\n                        if not forest[r][c] or (r, c) in visited: continue\n                        if (r, c) == end: return step\n                        visited.add((r, c))\n                        s.add((r, c))\n                queue = s\n\n        trees = [(height, r, c) for r, row in enumerate(forest) for c, height in enumerate(row) if forest[r][c] > 1]\n        # check\n        queue = [(0, 0)]\n        reached = set()\n        reached.add((0, 0))\n        while queue:\n            r, c = queue.pop()\n            for dr, dc in ((-1, 0), (1, 0), (0, -1), (0, 1)):\n                row, col = r + dr, c + dc\n                if forest[row][col] and (row, col) not in reached:\n                    queue.append((row, col))\n                    reached.add((row,col))\n        if not all([(i, j) in reached for (height, i, j) in trees]): return -1\n        trees.sort()\n        return sum([bfs((I,J),(i,j)) for (_, i, j), (_, I, J) in zip([(0, 0, 0)] + trees, trees)])"}
{"prompt": "def checkValidString(self, s: str) -> bool:\n        \n        # store the indices of '('\n        stk = []\n        \n        # store the indices of '*'\n        star = []\n        \n        \n        for idx, char in enumerate(s):\n            \n            if char == '(':\n                stk.append( idx )\n                \n            elif char == ')':\n                \n                if stk:\n                    stk.pop()\n                elif star:\n                    star.pop()\n                else:\n                    return False\n            \n            else:\n                star.append( idx )\n        \n        \n        # cancel ( and * with valid positions, i.e., '(' must be on the left hand side of '*'\n        while stk and star:\n            if stk[-1] > star[-1]:\n                return False\n        \n            stk.pop()\n            star.pop()\n        \n        \n        # Accept when stack is empty, which means all braces are paired\n        # Reject, otherwise.\n        return len(stk) == 0"}
{"prompt": "def validPalindrome(self, s: str) -> bool:\n            p1=0\n            p2=len(s)-1\n            while p1<=p2:\n                if s[p1]!=s[p2]:\n                    string1=s[:p1]+s[p1+1:]\n                    string2=s[:p2]+s[p2+1:]\n                    return string1==string1[::-1] or string2==string2[::-1]\n                p1+=1\n                p2-=1\n            return True"}
{"prompt": "def calPoints(self, s: List[str]) -> int:\n    \tp = []\n    \tfor i in s:\n    \t\tif i == 'C': p.pop()\n    \t\telif i == 'D': p.append(2*p[-1])\n    \t\telif i == '+': p.append(p[-1]+p[-2])\n    \t\telse: p.append(int(i))\n    \treturn sum(p)"}
{"prompt": "def findRedundantConnection(self, edges):\n        self.parent = dict()\n        \n        for e in edges:\n            \n            f0 = self.find(e[0])\n            f1 = self.find(e[1])\n            if f0 == f1:\n                return e\n            \n            self.parent[f0] = f1\n            \n    def find(self, x):\n        if x not in self.parent:\n            return x\n    \n        return self.find(self.parent[x])"}
{"prompt": "def repeatedStringMatch(self, A: str, B: str) -> int:\n    \tif set(B).issubset(set(A)) == False: return -1\n    \tfor i in range(1,int(len(B)/len(A))+3):\n    \t\tif B in A*i: return i\n    \treturn -1\n\t\t\n\t- Python3\n\t- Junaid Mansuri"}
{"prompt": "def longestUnivaluePath(self, root: TreeNode) -> int:\n        \n        def dfs(node): \n            \"\"\"Return longest univalue branch and longest univalue path (post-order traversal).\"\"\"\n            if not node: return 0, 0\n            (lx, llup), (rx, rlup) = dfs(node.left), dfs(node.right) \n            if not node.left or node.left.val != node.val: lx = 0\n            if not node.right or node.right.val != node.val: rx = 0 \n            return 1 + max(lx, rx), max(llup, rlup, 1 + lx + rx)\n        \n        return max(0, dfs(root)[-1]-1)"}
{"prompt": "def knightProbability(self, n: int, k: int, row0: int, col0: int) -> float:\n\t\n\t\t# precalculate possible moves\n        adj_list = defaultdict(list)\n        d = ((-2, -1), (-2, 1), (-1, 2), (1, 2), (2, 1), (2, -1), (1, -2), (-1, -2))\n        for row in range(n):\n            for col in range(n):\n                for dx, dy in d:\n                    pos = (row + dx, col + dy)\n                    if 0 <= pos[0] < n and 0 <= pos[1] < n:\n                        adj_list[(row, col)].append(pos)\n\n        @cache\n        def get_leafs_num(pos, h):\n            if h == k:\n                return 1\n            \n            res = 0\n            for next_pos in adj_list[pos]:\n                res += get_leafs_num(next_pos, h + 1)\n                \n            return res            \n            \n        leafs_num = get_leafs_num((row0, col0), 0)\n\n        return leafs_num / 8**k"}
{"prompt": "def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:\n        prefix = [0]\n        for x in nums: prefix.append(prefix[-1] + x)\n        \n        @cache\n        def fn(i, n): \n            \"\"\"Return max sum of 3 non-overlapping subarrays.\"\"\"\n            if n == 0: return []\n            if i+k >= len(prefix): return []\n            return max([i] + fn(i+k, n-1), fn(i+1, n), key=lambda x: sum(prefix[xx+k] - prefix[xx] for xx in x))\n        \n        return fn(0, 3)"}
{"prompt": "def getImportance(self, employees, id):\n        \"\"\"\n        :type employees: Employee\n        :type id: int\n        :rtype: int\n        \"\"\"\n        id_to_emp = {employee.id: employee for employee in employees}\n        importance = 0\n        stack = [id_to_emp[id]]\n        while stack:\n            cur_emp = stack.pop()\n            importance += cur_emp.importance\n            stack.extend([id_to_emp[new_emp] for new_emp in cur_emp.subordinates])\n        return importance"}
{"prompt": "def minStickers(self, stickers: List[str], target: str) -> int:\n        freqs = [Counter(x) for x in stickers]\n        \n        @cache\n        def fn(x):\n            \"\"\"Return min sticks to give x.\"\"\"\n            if not x: return 0 \n            ans = inf\n            freq = Counter(x)\n            for cnt in freqs: \n                if x[0] in cnt: \n                    xx = \"\".join(k*v for k, v in (freq - cnt).items())\n                    ans = min(ans, 1 + fn(xx))\n            return ans \n        \n        ans = fn(target)\n        return ans if ans < inf else -1"}
{"prompt": "def topKFrequent(self, words: List[str], k: int) -> List[str]:\n        #Have a dict of word and its freq\n        counts = collections.Counter(words)\n        \n        #get a array wchich will have a tuple of word and count\n        heap = [(-count, word) for word, count in counts.items()]\n        \n        #as default heap structure in python min heap and we want max heap\n        # to get top frequent word, we will do a make the counter negative\n        #so that the topmost element will come up (i.e -8 < -2 so in min heap -8 will come up wich is actually 8)\n        \n        heapq.heapify(heap) #creating heap in place\n        #by deualt it will sort by fre then word\n        \n        return [heapq.heappop(heap)[1] for _ in range(k)]"}
{"prompt": "def hasAlternatingBits(self, n: int) -> bool:\n        s = bin(n).replace('0b','')\n        for i in range(len(s)-1):\n            if s[i] == s[i+1]:\n                return False\n        return True"}
{"prompt": "def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        if not grid:\n            return 0\n        \n        maxArea = 0\n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: # run dfs only when we find a land\n                    maxArea = max(maxArea, self.dfs(grid, i, j))\n                    \n        return maxArea\n    \n                    \n    def dfs(self, grid, i, j):\n\t\t# conditions for out of bound and when we encounter water\n        if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j] != 1:\n            return 0\n        \n        maxArea = 1\n        grid[i][j] = '#'  # this will act as visited set\n        maxArea += self.dfs(grid, i+1, j)\n        maxArea += self.dfs(grid, i-1, j)\n        maxArea += self.dfs(grid, i, j+1)\n        maxArea += self.dfs(grid, i, j-1)\n        \n        return maxArea"}
{"prompt": "def countBinarySubstrings(self, s: str) -> int:\n        stack = [[], []]\n        latest = int(s[0])\n        stack[latest].append(latest)\n        result = 0\n        for i in range(1,len(s)):\n            v = int(s[i])\n            if v != latest:\n                stack[v].clear()\n                latest = v\n            stack[v].append(v)\n            if len(stack[1-v]) > 0:\n                stack[1-v].pop()\n                result += 1\n        return result"}
{"prompt": "def findShortestSubArray(self, nums: List[int]) -> int:\n    \tC = {}\n    \tfor i, n in enumerate(nums):\n    \t\tif n in C: C[n].append(i)\n    \t\telse: C[n] = [i]\n    \tM = max([len(i) for i in C.values()])\n    \treturn min([i[-1]-i[0] for i in C.values() if len(i) == M]) + 1\n\t\t\n\t\t\n- Junaid Mansuri"}
{"prompt": "def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:\n        if k==1:\n            return True\n        total = sum(nums)\n        n = len(nums)\n        if total%k!=0:\n            return False\n        nums.sort(reverse=True)\n        average = total//k\n        if nums[0]>average:\n            return False\n        \n        visited = [False]*n\n        def dfs(cur, begin, k):\n            if k==0:\n                return True\n            if cur>average:\n                return False\n            elif cur==average:\n                return dfs(0, 0, k-1)\n            for i in range(begin, n):\n                if not visited[i]:\n                    visited[i] = True\n                    if dfs(cur + nums[i], i+1, k):\n                        return True\n                    visited[i] = False\n            return False\n        \n        return dfs(0, 0, k)"}
{"prompt": "def fallingSquares(self, positions):\n            height, pos, max_h,res = [0],[0],0,[]\n            for left, side in positions:\n                i = bisect.bisect_right(pos, left)\n                j = bisect.bisect_left(pos, left + side)\n                high = max(height[i - 1:j] or [0]) + side \n                pos[i:j] = [left, left + side]\n                height[i:j] = [high, height[j - 1]]\n                max_h = max(max_h, high)\n                res.append(max_h)\n            return res"}
{"prompt": "def searchBST(self, root: TreeNode, val: int) -> TreeNode:\n        if not root:\n            return\n        if root.val==val:\n            return root\n        if root.val<val:\n            return self.searchBST(root.right,val)\n        else:\n            return self.searchBST(root.left,val)"}
{"prompt": "def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\n        if not root: return TreeNode(val)\n            \n        cur, next = None, root\n        while next:\n            cur = next\n            next = cur.left if val < cur.val else cur.right\n        \n        if val < cur.val: \n            cur.left = TreeNode(val)\n        else: \n            cur.right = TreeNode(val)\n            \n        return root"}
{"prompt": "def search(self, nums: List[int], target: int) -> int:\n        left = 0\n        right = len(nums)-1\n        \n        while left<=right:\n            mid = (left+right)//2\n            if nums[mid]==target:\n                return mid\n            elif nums[mid]>target:\n                right = mid-1\n            else:\n                left = mid+1\n        \n        return -1"}
{"prompt": "# Linked List Solution\nclass MyHashSet(object):\n    \n    def __init__(self):\n        self.keyRange = 769\n        self.bucketArray = [LinkedList() for i in range(self.keyRange)]\n        \n    def _hash(self, key):\n        return key % self.keyRange\n    \n    def add(self, key):\n        bucketIndex = self._hash(key)\n        self.bucketArray[bucketIndex].append(key)\n        \n    def remove(self, key):\n        bucketIndex = self._hash(key)\n        self.bucketArray[bucketIndex].deleteNodeKeyAll(key)\n        # while self.bucketArray[bucketIndex].search(key):\n        #     self.bucketArray[bucketIndex].deleteNodeKeyOne(key)\n        \n    def contains(self, key):\n        bucketIndex = self._hash(key)\n        return self.bucketArray[bucketIndex].search(key)\n    \n# ---------------------------------------------------------\n## Define a linked list\n\nclass Node:\n    \n    def __init__(self, val, next = None):\n        self.val = val\n        self.next = next\n        \nclass LinkedList:\n    \n    def __init__(self):\n        self.head = None\n\n# ---------------------------------------------------------\n## Insert a new node\n\n### Insert the new node at the front of the linked list\n    def push(self, new_val):\n        new_node = Node(new_val)\n        new_node.next = self.head\n        self.head = new_node\n        \n### Insert the new node at the end of the linked list\n    def append(self, new_val):\n        new_node = Node(new_val)\n        if self.head is None:\n            self.head = new_node\n            return\n        # Traverse till the end of the linked list\n        last = self.head\n        while last.next:\n            last = last.next\n        last.next = new_node\n\n### Insert the new node after a given node\n    def insertAfter(self, new_val, prev_node):\n        if prev_node is None:\n            print(\"Please enter the node which is the previous node of the inserted node.\")\n            return\n        new_node = Node(new_val)\n        new_node.next = prev_node.next\n        prev_node.next = new_node\n        \n# ---------------------------------------------------------\n## Delete a node\n\n### Delete a node by value\n# Iterative Method\n    def deleteNodeKeyOne(self, key): # delete a single node\n        temp = self.head\n        if temp is None:\n            return\n        if temp.val == key:\n            self.head = temp.next\n            temp = None\n            return\n        while temp is not None:\n            if temp.val == key:\n                break\n            prev = temp\n            temp = temp.next\n        if temp is None:\n            return\n        prev.next = temp.next\n        temp = None\n        \n    def deleteNodeKeyAll(self, key): # delete all the nodes with value key\n        temp = self.head\n        if temp is None:\n            return\n        while temp.val == key:\n            deletedNode = temp\n            self.head = temp.next\n            temp = self.head\n            deletedNode = None\n            if temp is None:\n                return\n        nxt = temp.next\n        while nxt is not None:\n            if nxt.val == key:\n                deletedNode = nxt\n                temp.next = nxt.next\n                deletedNode = None\n            temp = nxt\n            nxt = nxt.next\n\n### Delete a node by position and return the value of the deleted node\n    def deleteNodePosition(self, position):\n        if self.head is None:\n            return\n        if position == 0:\n            temp = self.head\n            self.head = self.head.next\n            temp = None\n            return\n        idx = 0\n        current = self.head\n        prev = self.head\n        nxt = self.head\n        while current is not None:\n            if idx == position:\n                nxt = current.next\n                break\n            prev = current\n            current = current.next\n            idx += 1\n        prev.next = nxt\n        current = None\n        \n# ---------------------------------------------------------\n# Print a linked list\n    def printList(self):\n        temp = self.head\n        while temp:\n            print (\" %d\" %(temp.val))\n            temp = temp.next\n\n# ---------------------------------------------------------\n## Search an element in a linked list\n    def search(self, x):\n        current = self.head\n        while current is not None:\n            if current.val == x:\n                return True\n            current = current.next\n        return False"}
{"prompt": "def toLowerCase(self, s: str) -> str:\n        # Instead of using .lower(), let's implement with ASCII\n        # ord() returns the ascii value of a passed character\n        \n        # Uncomment the line below to see the ASCII value of some important characters\n        # print(ord('a'), ord('z'), ord('A'), ord('Z'))\n        \n        # Notice 'a'=97, and 'A'=65\n        # This can be used to tell whether a character is upper/lower case, and can help us convert between them\n        \n        # First, make the string a list so we can change each char individually\n        s = list(s)\n        \n        # Then, loop through the characters, and if their ascii value is <= 90 and >= 65, they must be upper case\n        # Use the difference (97 - 65 = 32) to convert it from upper to lower, then use chr() to convert from ascii to char\n        #   - ord('A') + 32 = 97 = ord('a')\n        for i in range(len(s)):\n            if ord(s[i]) <= 90 and ord(s[i]) >= 65:\n                s[i] = chr(ord(s[i])+32)\n        return ''.join(s)"}
{"prompt": "def __init__(self, n: int, blacklist: List[int]):\n        self.hashmap={}\n        for b in blacklist:\n            self.hashmap[b]=-1\n        self.length=n-len(blacklist)\n        flag=n-1\n        for b in blacklist:\n            if b<self.length: \n                while flag in self.hashmap:\n                    flag-=1\n                self.hashmap[b]=flag\n                flag-=1\n            \n    def pick(self) -> int:\n        seed=random.randrange(self.length)\n        return self.hashmap.get(seed,seed)\n        \n\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(n, blacklist)\n# param_1 = obj.pick()"}
{"prompt": "def minimumDeleteSum(self, s1: str, s2: str) -> int:\n    \n    def lcs(s,p):\n        m,n = len(s),len(p)\n        dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n        for i in range(m):\n            for j in range(n):\n                if s[i]==p[j]:\n                    dp[i+1][j+1] = dp[i][j]+ord(s[i])\n                else:\n                    dp[i+1][j+1] = max(dp[i+1][j],dp[i][j+1])\n                    \n        return dp[-1][-1]\n    \n    common = lcs(s1,s2)\n    total,res = 0,0\n    for c in s1:\n        total+=ord(c)\n    for c in s2:\n        total+=ord(c)\n    \n    res = total - common*2\n    return res"}
{"prompt": "def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:\n        \n        if k <= 1:\n            # Quick response for invalid k on product of positive numbers\n            return 0\n        \n        else:\n            left_sentry = 0\n\n            num_of_subarray = 0\n            product_of_subarry = 1\n\n            # update right bound of sliding window\n            for right_sentry in range( len(nums) ):\n\n                product_of_subarry *= nums[right_sentry]\n\n                # update left bound of sliding window\n                while product_of_subarry >= k:\n                    product_of_subarry //= nums[left_sentry]\n                    left_sentry += 1\n\n                # Note:\n                # window size = right_sentry - left_sentry + 1\n\n                # update number of subarrary with product < k\n                num_of_subarray += right_sentry - left_sentry + 1\n\n            return num_of_subarray"}
{"prompt": "def maxProfit(self, prices: List[int]) -> int:\n        buy, sell = inf, 0\n        for x in prices:\n            buy = min(buy, x)\n            sell = max(sell, x - buy)\n        return sell"}
{"prompt": "def isOneBitCharacter(self, bits):\n        i, n, numBits = 0, len(bits), 0\n        while i < n:\n            bit = bits[i]\n            if bit == 1:\n                i += 2\n                numBits = 2\n            else:\n                i += 1\n                numBits = 1\n        return numBits == 1"}
{"prompt": "# DP Approach - Similar to 1143. Longest Common Subsequence\n    def findLength(self, nums1: List[int], nums2: List[int]) -> int:\n        n, m = len(nums1), len(nums2)\n        # dp[i][j] means the length of repeated subarray of nums1[:i] and nums2[:j]\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        ans = 0\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                # if both character is same\n                if nums1[i - 1] == nums2[j - 1]:\n                    # then we add 1 to the previous state, which is dp[i - 1][j - 1]\n                    # in other word, we extend the repeated subarray by 1\n                    # e.g. a = [1], b = [1], length of repeated array is 1\n                    #      a = [1,2], b = [1,2], length of repeated array is the previous result + 1 = 2\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                    # record the max ans here\n                    ans = max(ans, dp[i][j])\n                # else:\n                    # if you are looking for longest common sequence,\n                    # then you put dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); here\n                    # however, this problem is looking for subarray,\n                    # since both character is not equal, which means we need to break it here\n                    # hence, set dp[i][j] to 0\n        return ans"}
{"prompt": "def smallestDistancePair(self, nums: List[int], k: int) -> int:\n\n\t\tdef getPairs(diff):\n\t\t\tl = 0\n\t\t\tcount = 0\n\n\t\t\tfor r in range(len(nums)):\n\t\t\t\twhile nums[r] - nums[l] > diff:\n\t\t\t\t\tl += 1\n\t\t\t\tcount += r - l\n\n\t\t\treturn count\n\n\n\t\tnums.sort()\n\t\tl, r = 0, nums[-1] - nums[0]\n\n\t\twhile l < r:\n\t\t\tmid = (l + r) // 2\n\t\t\tres = getPairs(mid)\n\n\t\t\tif res >= k:\n\t\t\t\tr = mid\n\t\t\telse:\n\t\t\t\tl = mid + 1\n\n\t\treturn l"}
{"prompt": "def longestWord(self, words: List[str]) -> str:\n        words.sort()                  # for smallest lexicographical order\n        visited = {\"\"}                # hashset to keep a track of visited words\n        res = ''\n        \n        for word in words:\n            if word[:-1] in visited:     # check previous word ie. word[:len(word)-1] visited or not\n                visited.add(word)        # add this word to the set\n                if len(word) > len(res): # current word have greater lenght and lexicographically smaller\n                    res = word           # update res\n        \n        return res\n    \n    \n    \n# Time: O(n log(n))   # for sorting the words\n# Space: O(n)         # for making the set visited"}
{"prompt": "def dfs(self, graph, node, visit):\n        visit.add(node)\n        for nei in graph[node]:\n            if nei not in visit:\n                self.dfs(graph, nei, visit)\n        self.res.append(node)\n    \n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\n        graph = collections.defaultdict(set)\n        for account in accounts:\n            for email in account[1:]:\n                graph[account[1]].add(email)\n                graph[email].add(account[1])\n        #print(graph.items())\n        \n        visit = set()\n        ans = []\n        for account in accounts:\n            name = account[0]\n            for email in account[1:]:\n                if email not in visit:\n                    self.res = []\n                    self.dfs(graph, email, visit)\n                    ans.append([name]+sorted(self.res))\n        return ans"}
{"prompt": "def removeComments(self, source: List[str]) -> List[str]:\n        ans, inComment = [], False\n        new_str = \"\"\n        for c in source:\n            if not inComment: new_str = \"\"\n            i, n = 0, len(c)\n            # inComment, we find */\n            while i < n:\n                if inComment:\n                    if c[i:i + 2] == '*/' and i + 1 < n:\n                        i += 2\n                        inComment = False\n                        continue\n                    i += 1\n                # not in Comment, we find /* // and common character\n                else:\n                    if c[i:i + 2] == '/*' and i + 1 < n:\n                        i += 2\n                        inComment = True\n                        continue\n                    if c[i:i + 2] == '//' and i + 1 < n:\n                        break\n                    new_str += c[i]\n                    i += 1\n            if new_str and not inComment:\n                ans.append(new_str)\n                    \n\n        return ans"}
{"prompt": "def findMiddleIndex(self, nums: List[int]) -> int:\n        left = 0 # nums[0] + nums[1] + ... + nums[middleIndex-1]\n        right = sum(nums) # nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1]\n\n        for i, num in enumerate(nums): # we can use normal for loop as well.\n            right -= num # as we are trying to find out pivot index so iteratively we`ll reduce the value of right to find the pivot index\n            if left == right: # comparing the values for finding out the pivot index.\n                return i # if there is any return the index whixh will be our required index.\n            left += num # we have to add the num iteratively. \n\n        return -1"}
{"prompt": "def splitListToParts(self, head: ListNode, k: int) -> List[ListNode]:\n        size = self.get_size(head)\n        min_len, one_more = divmod(size, k)\n        res = []\n        current = ListNode()\n        current.next = head\n        for i in range(k):\n            ans = current\n            for _ in range(min_len + int(i < one_more)):\n                current = current.next\n            res.append(ans.next)\n            ans.next = None\n        return res\n\n    def get_size(self, head: ListNode) -> int:\n        size = 0\n        while head is not None:\n            size += 1\n            head = head.next\n        return size"}
{"prompt": "def countOfAtoms(self, formula: str) -> str:\n        # constant declarations\n        upper=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n        lower=upper.lower()\n        digits = \"0123456789\"\n        \n        # variables\n        count=defaultdict(int)\n        element_name = None\n        element_name_parse_start=False\n        element_count =\"\"\n        bracket_stacks = [[]]\n        buffer = []\n        \n        # function to parse out the complete number if a digit is seen, \n        # the function takes the character, that was seen as a digit and \n        # the generator object to get the remaining (yet to be read) part of formula\n        def parseout_number(ch,gen):\n            nonlocal buffer\n            num=\"\"\n            try:\n                while ch in digits:\n                    num += ch\n                    ch = next(gen)\n                # after number is parsed out and a non-number character is seen, \n                # add that non-number character to the buffer to be read next, dont miss parsing it\n                buffer.append(ch)\n            except StopIteration:\n                # while iterating to find the end digit of the number, we have reached the end of the formula, \n                # meaning the digit ch and subsequent characters were numbers and were the last thing in the formula\n\t\t\t\t# the code, outside of try-catch handles all the possible scenerios of parsing the number out, \n\t\t\t\t# so do nothing here. move along\n                pass\n            # if we saw a number, return it as integer, else return empty string\n            if num != \"\":\n                return int(num)\n            else:\n                return \"\"\n        \n        #generator expression\n        formula_chars = (ch for ch in formula)\n        \n        # iterate over all characters\n        for char in formula_chars:\n            \n            # add the character emitted by generator into buffer for processing\n            buffer.append(char)\n            \n            # process what ever is in the buffer queue\n            while buffer:\n                ch = buffer.pop(0)\n                \n                # if the character is an upper case character\n                # set the a flag to indicate start of a new element name\n                # check if the previous elementname was added to the processing_stack (bracket_stacks)\n                # if not then add it, noting one atom for that element\n                # set the character to element_name variable\n                if ch in upper:\n                    element_name_parse_start=True\n                    if element_name is not None and element_count == \"\":\n                        bracket_stacks[-1].append([element_name,1])\n                    element_name = ch\n                # if character is lowercase, just concat it to the element_name\n                elif ch in lower:\n                    element_name += ch\n                # if character is a numerical digit, then parse that number out completely as integer\n                # set the flag to indicate the reading the element name is done\n                # store the element name and it's corresponding count into the processing_stack\n                # reset the variables element_name and element_count, ready for next element\n                elif ch in digits:\n                    element_name_parse_start=False\n                    element_count = parseout_number(ch,formula_chars)\n                    bracket_stacks[-1].append([element_name,element_count])\n                    element_count = \"\"\n                    element_name = None\n                # if open bracket is seen, check if reading the element_name flag is still True\n                # if it is then that element has one atom only\n                # add it to the processing stack\n                # set the flag to indicate that reading the 'element_name' is done and \n                # add another processing stack top the top of the 'bracket_stacks'\n                # this new processing stack will have the atom details within the bracket\n                # finally, reset all other variables to ensure \n\t\t\t\t# clean slate for the new child 'processing-stack' before exiting the code-block\n                elif ch == \"(\":\n                    if element_name_parse_start:\n                        bracket_stacks[-1].append([element_name,1])\n                    element_name_parse_start=False\n                    element_count = \"\"\n                    bracket_stacks.append([]) # new processing stack\n                    element_name = None\n                \n                # if a bracket is closed\n                # make sure we account for one atom of element, if a number was not seen before closing the bracket\n                # set the flag to indicate we are done reading element_name\n                # check what is the next character after the bracket close char. \n\t\t\t\t# if it's a digit, then parse that number out \n                # that number is the multiplier for the current processing stack\n                # which means we will need to multiply every atom/element count by the multiplier\n                # at this point the current processing stack \n\t\t\t\t# which was created as part of opening the bracket is processed\n                # so, merge what we found into the parent processing stack by \n                # extending the parent processing stack with the results of the child stack\n                elif ch == \")\":\n                    if element_name_parse_start:\n                        bracket_stacks[-1].append([element_name,1])\n                    element_name = None\n                    element_name_parse_start=False\n                    braket_multiplier = \"\"\n                    try:\n                        next_ch= next(formula_chars)\n                        braket_multiplier = parseout_number(next_ch,formula_chars)\n                    except StopIteration:\n                        pass\n                    \n                    if braket_multiplier == \"\":\n                        braket_multiplier = 1\n\t\t\t\t\t# pop the child processing - stack to be processed\n                    process_this = bracket_stacks.pop()\n                    \n\t\t\t\t\t#processing\n                    for idx,_ in enumerate(process_this):\n                        process_this[idx][1] = process_this[idx][1]*braket_multiplier\n\t\t\t\t\t\n\t\t\t\t\t#merging processed child stack with the parent stack\n                    bracket_stacks[-1].extend(process_this)\n        \n        # if the new element name seen flag is set then process that \n        # atom by adding it's element-name and atom count to the current processing stack\n        if element_name_parse_start:\n            if element_name is not None:\n                if element_count != \"\":\n                    bracket_stacks[-1].append([element_name,int(element_count)])\n                else:\n                    bracket_stacks[-1].append([element_name,1])\n        \n        # pop the top-level processing-stack, this should contain a 'flattened' version of the atoms and their counts\n        # note that the counts of elements are not aggregated yet, \n        # eg:If Oxygen was seen within a bracket and also seen outside that bracket, \n        # then we'll have two entries for Oxygen. We'll aggregate them next...\n        count_pairs = bracket_stacks.pop()\n        \n        # aggregate all the 'flattened' data in 'count_pairs' variable, using a dictionary\n        for element_name,element_count in count_pairs:\n            count[element_name]+= element_count\n        \n        # preparing the output string...\n        # create a list meant to hold the 'words' of the output string, based on the description\n        output=[]\n        \n        # fetch the keylist\n        elements_list = list(count.keys())\n        \n        #sort it\n        elements_list.sort()\n        \n        # for each element in the sorted keylist, if the element has more \n        # than 1 atom, append the atom and it's count\n        # if element has only 1 atom only append the atom name, \n        # but don't append the atom's count (which is 1)\n        for element in elements_list:\n            if count[element] > 1:\n                output.append(element)\n                output.append(str(count[element]))\n            else:\n                output.append(element)\n        \n        # output will now have an list of words representation of what we need. turn the list into a string and return it\n        return \"\".join(output)"}
{"prompt": "def selfDividingNumbers(self, left: int, right: int) -> List[int]:\n\t\tresult = []\n\n\t\tfor i in range(left, right+ 1):\n\t\t\tif \"0\" in str(i): continue\n\t\t\tval = i\n\t\t\twhile val > 0:\n\t\t\t\tn = val % 10\n\t\t\t\tif i % n != 0:\n\t\t\t\t\tval = -1\n\t\t\t\tval = val // 10\n\n\t\t\tif val != -1: result.append(i)\n\n\t\treturn result"}
{"prompt": "# Binary Search Tree Solution -> If exact matching of intervals found then return False\n#                                Else you can add this interval to that particular node's left or right\nclass Node:\n    def __init__(self, s, e):\n        self.s = s\n        self.e = e\n        self.left = None\n        self.right = None\nclass MyCalendar:\n    def __init__(self):\n        self.head = None\n        \n    def insert(self, s, e, node):\n        if s >= node.e:\n            if node.right: return self.insert(s, e, node.right)\n            else: \n                nn = Node(s, e)\n                node.right = nn\n                return True\n        elif e <= node.s:\n            if node.left: return self.insert(s, e, node.left)\n            else:\n                nn = Node(s, e)\n                node.left = nn\n                return True\n        else: return False\n        \n    def book(self, s: int, e: int) -> bool:\n        if self.head == None:\n            nn = Node(s, e)\n            self.head = nn\n            return True\n        return self.insert(s, e, self.head)"}
{"prompt": "def countPalindromicSubsequences(self, s:str) -> int:\n        \n        @cache\n        def fn(ch, i, j):\n            if i > j:\n                return 0\n            \n            if i == j and s[i] == ch:\n                return 1\n            \n            if s[i] == s[j] == ch:\n                return 2 + fn('a', i+1, j-1) + fn('b', i+1, j-1) + fn('c', i+1, j-1) + fn('d', i+1, j-1)\n            elif s[i] != ch:\n                return fn(ch, i+1, j)\n            elif s[j] != ch:\n                return fn(ch, i, j-1)\n        \n        \n        n = len(s)\n        return (fn('a', 0, n-1) + fn('b', 0, n-1) + fn('c', 0, n-1) + fn('d', 0, n-1)) % (10**9+7)"}
{"prompt": "def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:\n        \n        h, w = len(image), len(image[0])\n        \n\t\t\n        def dfs( r, c, src_color):\n            \n            if r < 0 or c < 0 or r >= h or c >= w or image[r][c] == newColor or image[r][c] != src_color:\n                # Reject for invalid coordination, repeated traversal, or different color\n                return\n            \n            # update color\n            image[r][c] = newColor\n            \n            \n            # DFS to 4-connected neighbors\n            dfs( r-1, c, src_color )\n            dfs( r+1, c, src_color )\n            dfs( r, c-1, src_color )\n            dfs( r, c+1, src_color )\n            \n        # ---------------------------------------------------------------------------\n        \n        dfs(sr, sc, src_color = image[sr][sc] )\n        \n        return image"}
{"prompt": "def asteroidCollision(self, asteroids: List[int]) -> List[int]:\n        stack = []\n        for a in asteroids:\n            if a > 0:\n                stack.append(a)\n            else:\n                while stack and stack[-1] > 0 and stack[-1] + a < 0:\n                    stack.pop()\n                if not stack or stack[-1] < 0:\n                    stack.append(a)\n                elif stack[-1] + a == 0:\n                    stack.pop()\n        return stack"}
{"prompt": "def evaluate(self, expression: str) -> int:\n        stack = []\n        parenEnd = {}\n        \n        # Get the end parenthesis location \n        for idx, ch in enumerate(expression):\n            if ch == '(':\n                stack.append(idx)\n            if ch == ')':\n                parenEnd[stack.pop()] = idx\n\n        # Parses the expression into a list, each new sublist is a set of parenthesis\n        # Example: \n        # Input: \"(let x 2 (mult x (let x 3 y 4 (add x y))))\"\n        # Output: ['let', 'x', '2', ['mult', 'x', ['let', 'x', '3', 'y', '4', ['add', 'x', 'y']]]]\n        def parse(lo, hi):\n            arr = []\n            word = []\n\n            i = lo\n            while i < hi:\n                if expression[i] == '(':\n                    arr.append(parse(i + 1, parenEnd[i]))\n                    i = parenEnd[i]\n                elif expression[i] == ' ' or expression[i] == ')' and word != []:\n                    if ''.join(word) != '':\n                        arr.append(''.join(word))\n                    word = []\n                    i += 1\n                elif expression[i] != ')':\n                    word.append(expression[i])\n                    i += 1\n                else:\n                    i += 1\n\n\n            if word != []:\n                arr.append(''.join(word))\n\n            return arr\n\n        # Change string expression into the list expression\n        expressionList = parse(1, len(expression) - 1)\n\n        # Eval expression with starting scope (variables)\n        return self.genEval(expressionList, {})\n    \n    def genEval(self, expression, scope):\n        if type(expression) != list:\n            # If expression is just a variable or int\n            try:\n                return int(expression)\n            except:\n                return scope[expression]\n        else:\n            if expression[0] == 'let':\n                # Remove \"let\" from expression list\n                expression = expression[1:]\n                \n                # This loop updates the scope (variables)\n                while len(expression) > 2:\n                    scope = self.letEval(expression, scope.copy())\n                    expression = expression[2:]\n                    \n                # Return the last value\n                return self.genEval(expression[0], scope.copy())\n                \n            if expression[0] == 'add':\n                return self.addEval(expression, scope.copy())\n                \n            if expression[0] == 'mult':\n                return self.multEval(expression, scope.copy())\n\n\n    \n    def letEval(self, expression, scope):\n        scope[expression[0]] = self.genEval(expression[1], scope)\n        return scope\n    \n    def addEval(self, expression, scope):\n        return self.genEval(expression[1], scope) + self.genEval(expression[2], scope)\n    \n    def multEval(self, expression, scope):\n        return self.genEval(expression[1], scope) * self.genEval(expression[2], scope)"}
{"prompt": "def monotoneIncreasingDigits(self, N: int) -> int:\n        nums = [int(x) for x in str(N)] # digits \n        stack = []\n        for i, x in enumerate(nums): \n            while stack and stack[-1] > x: x = stack.pop() - 1\n            stack.append(x) \n            if len(stack) <= i: break \n        return int(\"\".join(map(str, stack)).ljust(len(nums), \"9\")) # right padding with \"9\""}
{"prompt": "def dailyTemperatures(self, temperatures: List[int]) -> List[int]:\n        result = [0] * len(temperatures) # having list with 0`s elements of same lenght as temperature array.\n        stack = [] # taking empty stack. \n        for index, temp in enumerate(temperatures): # Traversing through provided list. \n            while stack and temperatures[stack[-1]] < temp: # stack should not be empty and checking previous temp with current temp. \n                # the above while loop and taking stack for saving index is very common practice in monotonic stack questions. Suggestion: understand it properly. \n                prev_temp = stack.pop() # stack.pop() will provide index of prev temp, taking in separate var as we are using it more then on place. \n                result[prev_temp] = index - prev_temp #at the index of prev_temp and i - prev_temp by this we`ll get how many step we moved to have greater temp. \n            stack.append(index) # in case stack is empty we`ll push index in it. \n\n        return result # returing the list of number of days to wait."}
{"prompt": "def deleteAndEarn(self, nums: List[int]) -> int:\n        mp = {}\n        for x in nums: mp[x] = x + mp.get(x, 0)\n        \n        @lru_cache(None)\n        def fn(i): \n            \"\"\"Return maximum points one can earn from nums[i:].\"\"\"\n            if i >= len(nums): return 0 \n            if nums[i] + 1 not in mp: return mp[nums[i]] + fn(i+1)\n            return max(mp[nums[i]] + fn(i+2), fn(i+1))\n        \n        nums = sorted(set(nums))\n        return fn(0)"}
{"prompt": "def cherryPickup(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        \n        @lru_cache(None)\n        def fn(t, i, ii): \n            \"\"\"Return maximum cherries collected at kth step when two robots are at ith and iith row\"\"\"\n            j, jj = t - i, t - ii #columns\n            if not (0 <=  i < n and 0 <=  j < n) or t <  i or grid[ i][ j] == -1: return -inf #robot 1 not at proper location\n            if not (0 <= ii < n and 0 <= jj < n) or t < ii or grid[ii][jj] == -1: return -inf #robot 2 not at proper location\n            if t == 0: return grid[0][0] #starting from 0,0\n            return grid[i][j] + (i != ii)*grid[ii][jj] + max(fn(t-1, x, y) for x in (i-1, i) for y in (ii-1, ii))\n            \n        return max(0, fn(2*n-2, n-1, n-1))"}
{"prompt": "def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:        \n        adj_list = defaultdict(list)\n        \n        for x,y,w in times:\n            adj_list[x].append((w, y))\n        \n        visited=set()\n        heap = [(0, k)]\n        while heap:\n            travel_time, node = heapq.heappop(heap)\n            visited.add(node)\n            \n            if len(visited)==n:\n                return travel_time\n            \n            for time, adjacent_node in adj_list[node]:\n                if adjacent_node not in visited:\n                    heapq.heappush(heap, (travel_time+time, adjacent_node))\n                \n        return -1"}
{"prompt": "def nextGreatestLetter(self, letters, target):\n        \"\"\"\n        :type letters: List[str]\n        :type target: str\n        :rtype: str\n        \"\"\"\n        \n        # if the number is out of bound\n        if target >= letters[-1] or target < letters[0]:\n            return letters[0]\n        \n        low = 0\n        high = len(letters)-1\n        while low <= high:\n            mid = (high+low)//2\n            \n            if  target >= letters[mid]: # in binary search this would be only greater than\n                low = mid+1\n            \n            if target < letters[mid]:\n                high = mid-1\n                \n        return letters[low]"}
{"prompt": "def minCostClimbingStairs(self, cost: List[int]) -> int:\n\t\tcur = 0 \n\t\tdp0 = cost[0]\n\t\tif len(cost) >= 2:\n\t\t\tdp1 = cost[1]\n\n\t\tfor i in range(2, len(cost)):\n\t\t\tcur = cost[i] + min(dp0, dp1)\n\t\t\tdp0 = dp1\n\t\t\tdp1 = cur\n\n\t\treturn min(dp0, dp1)"}
{"prompt": "def dominantIndex(self, nums: List[int]) -> int:\n        if len(nums) is 1:\n            return 0\n        dom = max(nums)\n        i = nums.index(dom)\n        nums.remove(dom)\n        if max(nums) * 2 <= dom:\n            return i\n        return -1"}
{"prompt": "def shortestCompletingWord(self, P: str, words: List[str]) -> str:\n        alphs=\"\"\n        res=\"\"        \n        for p in P:\n                if p.isalpha():\n                        alphs+=p.lower()\n        for word in words:                \n                if all(alphs.count(alphs[i]) <= word.count(alphs[i]) for i in range(len(alphs))):\n                        if res==\"\" or len(res)>len(word):\n                                res=word\n        \n        return res"}
{"prompt": "def containVirus(self, mat: List[List[int]]) -> int:\n        m,n = len(mat),len(mat[0])\n\n        def dfs(i,j,visited,nextInfected):  # return no. of walls require to quarantined dfs area\n            if 0<=i<m and 0<=j<n and (i,j) not in visited:\n                if mat[i][j]==2: # Already quarantined cell\n                    return 0\n                if mat[i][j]==0:\n                    nextInfected.add((i,j)) # add cell which will be infected next day\n                    return 1   # require one wall to quarantined cell from one side\n                    \n                else:\n                    visited.add((i,j))\n                    return dfs(i-1,j,visited,nextInfected) + dfs(i+1,j,visited,nextInfected) + dfs(i,j-1,visited,nextInfected) + dfs(i,j+1,visited,nextInfected)  # traverse all four direction\n            else:\n                return 0\n\t\t\t\t\n        ans = 0 \n        while True:   # this loop running \"how many days we should installing the walls\" times\n            # For every day check which area infect more cells\n            visited = set()  # Using in dfs\n            All_nextinfect  = set()\n            stop , walls = set(),0   # here stop store the indices of maximum no. of cells in which we stop spreading of virus this day\n            \n            for i in range(m):\n                for j in range(n):\n                    if mat[i][j]==1 and (i,j) not in visited:\n                        nextInfected = set()\n                        a = dfs(i,j,visited,nextInfected)\n                        \n                        if len(stop)<len(nextInfected):\n                            All_nextinfect  = All_nextinfect | stop # leave previous saved area from virus\n                            stop = nextInfected  # pick new area which we want to save\n                            walls = a  # require walls\n                            p,q = i,j  # starting position(indices) of this area\n                        else:\n                            All_nextinfect  = All_nextinfect | nextInfected   \n                            \n            if not stop : # if our job is done i.e. No cell will be infect Later\n                break\n            ans += walls  # add new walls installed this day\n            \n            # change each cell value to 2 which will be covered by quarantined area\n            def fun(p,q):\n                if 0<=p<m and 0<=q<n and mat[p][q]==1:\n                    mat[p][q]=2\n                    fun(p+1,q)\n                    fun(p-1,q)\n                    fun(p,q-1)\n                    fun(p,q+1)\n            fun(p,q) # start dfs from start point of quarantined area\n            \n            for a,b in All_nextinfect: # set new infected cell value = 1 for iterating next day\n                mat[a][b] = 1\n\n        return ans   # Final answer"}
{"prompt": "def openLock(self, deadends: List[str], end: str) -> int:\n        if end in deadends or \"0000\" in deadends:\n            return -1\n        if end == \"0000\":\n            return 0\n        start, end, deadends = 0, int(end), {int(deadend) for deadend in deadends}\n\n        def distance(cur: int, target: int) -> int:\n            diff = 0\n            for _ in range(4):\n                a, b = cur % 10, target % 10\n                d = abs(a - b)\n                diff += min(d, 10 - d)\n                cur, target = cur // 10, target // 10\n            return diff\n\n\t\tdef turn_knob(cur: int, idx: int) -> Tuple[int, int]:\n\t\t\tindex = 10 ** idx\n\t\t\tdigit = cur // index % 10\n\t\t\tup = cur - 9 * index if digit == 9 else cur + index\n\t\t\tdown = cur - index if digit else cur + 9 * index\n\t\t\treturn up, down\n\n        def process(\n            this_q: List[int], this_v: Dict[int, int], other_v: Dict[int, int], target: int\n        ) -> int:\n            _, cur = heappop(this_q)\n            step = this_v[cur]\n            for i in range(4):\n                up, down = turn_knob(cur, i)\n                if up in other_v:\n                    return step + other_v[up] + 1\n                if down in other_v:\n                    return step + other_v[down] + 1\n                if up not in deadends and up not in this_v:\n                    this_v[up] = step + 1\n                    this_q.append((distance(up, target), up))\n                if down not in deadends and down not in this_v:\n                    this_v[down] = step + 1\n                    this_q.append((distance(down, target), down))\n            heapify(this_q)\n            return None\n\n        s_q, s_v = [(distance(start, end), start)], {start: 0}\n        e_q, e_v = [(distance(end, start), end)], {end: 0}\n        while s_q and e_q:\n            s = process(s_q, s_v, e_v, end)\n            if s: return s\n            e = process(e_q, e_v, s_v, start)\n            if e: return e\n        return -1"}
{"prompt": "def crackSafe(self, n: int, k: int) -> str:\n        def dfs(path, visitedCombinations, targetNumVisited, combos):\n            # Base Case. We've visited all possible combinations\n            if len(visitedCombinations) == targetNumVisited:\n                combos.append(''.join([str(x) for x in path]))\n                return True\n            # This if/else is necessary to prevent Python from picking up the first element if n = 1\n            if n > 1:\n                lastDigits = ''.join([str(x) for x in path[-(n-1):]])\n            else:\n                lastDigits = ''\n            for i in range(k):\n                path.append(i)\n                newPwd = f'{lastDigits}{i}'\n                # We have not reached the minimum pwd length. Continue recursion\n                if len(newPwd) != n: \n                    if dfs(path, visitedCombinations, targetNumVisited, combos):\n                        return True\n                if len(newPwd) == n and newPwd not in visitedCombinations:\n                    visitedCombinations[newPwd] = 1\n                    if dfs(path, visitedCombinations, targetNumVisited, combos):\n                        return True\n                    del visitedCombinations[newPwd]\n                path.pop()\n            return False\n                          \n        \n        # Empty visited Combinations hash set\n        visitedCombinations = {}\n        combos = []\n        dfs([], visitedCombinations, k**n, combos)\n        return combos[0]"}
{"prompt": "def reachNumber(self, target: int) -> int:\n        target = abs(target)\n        step = 0\n        far = 0\n        while far < target or far%2 != target%2:\n            step += 1\n            far +=step\n        \n        return step"}
{"prompt": "def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\n        mp = {}\n        for x, y, z in allowed: mp.setdefault((x, y), set()).add(z)\n            \n        def fn(row): \n            \"\"\"Return list of rows built from given row.\"\"\"\n            ans = [\"\"]\n            for x, y in zip(row, row[1:]):\n                if (x, y) not in mp: return []\n                ans = [xx + zz for xx in ans for zz in mp[x, y]]\n            return ans \n        \n        # dfs \n        stack = [bottom]\n        while stack: \n            row = stack.pop()\n            if len(row) == 1: return True \n            stack.extend(fn(row))\n        return False"}
{"prompt": "def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key = lambda x:x[1])\n        size = 0\n        prev_start = -1\n        prev_end = -1\n\n        for curr_start, curr_end in intervals:\n            if prev_start == -1 or prev_end < curr_start: #if intervals do not overlap\n                size += 2\n                prev_start = curr_end-1\n                prev_end = curr_end\n\n            elif prev_start < curr_start: #if intervals overlap\n                if prev_end != curr_end:\n                    prev_start = prev_end\n                    prev_end = curr_end\n                    \n                else:\n                    prev_start = curr_end-1\n                    prev_end = curr_end\n\n                size += 1\n\n        return size"}
{"prompt": "def makeLargestSpecial(self, s: str) -> str:\n    \n    l = 0\n    balance = 0\n    sublist = []\n    for r in range(len(s)):\n        balance += 1 if s[r]=='1' else -1\n        if balance==0:\n            sublist.append(\"1\" + self.makeLargestSpecial(s[l+1:r])+ \"0\")\n            l = r+1\n    \n    sublist.sort(reverse=True)\n    return ''.join(sublist)"}
{"prompt": "def isPrime(self,x):\n        flag=0\n        if x==1:\n            return False\n        for i in range(2,x):\n            if x%i==0:\n                flag=1\n                break\n        if flag==1:\n            return False\n        return True\n        \n    def countPrimeSetBits(self, left: int, right: int) -> int:\n        arr_dict={}\n        lst=list(range(left,right+1))\n        for i in lst:\n            if i not in arr_dict:\n                arr_dict[i]=bin(i).replace(\"0b\",\"\")\n        arr=list(arr_dict.values())\n        count=0\n        for i in arr:\n            if self.isPrime(i.count('1')):\n                # print(i)\n                count+=1\n        return count"}
{"prompt": "def partitionLabels(self, s: str) -> List[int]:\n        L = len(s)\n        last = {s[i]: i for i in range(L)} # last appearance of the letter\n        i, ans = 0, []\n        while i < L:\n            end, j = last[s[i]], i + 1\n            while j < end: # validation of the part [i, end]\n                if last[s[j]] > end:\n                    end = last[s[j]] # extend the part\n                j += 1\n           \n            ans.append(end - i + 1)\n            i = end + 1\n            \n        return ans"}
{"prompt": "def orderOfLargestPlusSign(self, N: int, mines: List[List[int]]) -> int:\n        mat = [[1]*N for _ in range(N)]\n        for x, y in mines: mat[x][y] = 0                   # create matrix with mine\n            \n        up = [[0]*N for _ in range(N)]                     # count 1s above mat[i][j] if mat[i][j] is 1\n        for i in range(N):\n            for j in range(N):\n                if mat[i][j]: \n                    up[i][j] = 1\n                    if i > 0: up[i][j] += up[i-1][j] \n                \n        down = [[0]*N for _ in range(N)]                   # count 1s below mat[i][j] if mat[i][j] is 1\n        for i in range(N-1, -1, -1):\n            for j in range(N):\n                if mat[i][j]: \n                    down[i][j] = 1\n                    if i < N-1: down[i][j] += down[i+1][j] \n                    \n        left = [[0]*N for _ in range(N)]                   # count 1s on the left side of mat[i][j] if mat[i][j] is 1\n        for i in range(N):\n            for j in range(N):\n                if mat[i][j]:\n                    left[i][j] = 1\n                    if j > 0: left[i][j] += left[i][j-1]\n                    \n        right = [[0]*N for _ in range(N)]                  # count 1s on the right side of mat[i][j] if mat[i][j] is 1\n        for i in range(N):\n            for j in range(N-1, -1, -1):\n                if mat[i][j]:\n                    right[i][j] = 1\n                    if j < N-1: right[i][j] += right[i][j+1]\n         \n\t\t# find the largest + sign by using cached directions information\n        return max(min([up[i][j], down[i][j], left[i][j], right[i][j]]) for i in range(N) for j in range(N))"}
{"prompt": "def minSwapsCouples(self, row: List[int]) -> int:\n        loc = {x: i for i, x in enumerate(row)}\n        ans = 0\n        for i in range(0, len(row), 2): \n            p = row[i] - 1 if row[i]&amp;1 else row[i]+1\n            if row[i+1] != p: \n                ans += 1\n                ii = loc[p]\n                loc[row[i+1]], loc[row[ii]] = loc[row[ii]], loc[row[i+1]] # swap mappings\n                row[i+1], row[ii] = row[ii], row[i+1] # swap values \n        return ans"}
{"prompt": "def isToeplitzMatrix(self, matrix: List[List[int]])->bool:\n        r_len, c_len = len(matrix),len(matrix[0])\n        \n        for r in range (1, r_len):\n            for c in range (1, c_len):\n                if matrix[r][c]!=matrix[r-1][c-1]:\n                    return False\n        \n        return True"}
{"prompt": "def reorganizeString(self, S: str) -> str:\n        counter = collections.Counter(S)\n        i, res, n = 0, [None] * len(S), len(S)\n        for k in sorted(counter, key = counter.get, reverse = True):\n            if counter[k] > n // 2 + (n % 2): return \"\"\n            for j in range(counter[k]):\n                if i >= n: i = 1\n                res[i] = k; i += 2\n        return \"\".join(res)"}
{"prompt": "def maxChunksToSorted(self, nums: List[int]) -> int:\n    \n    st = []\n    for n in nums:\n        if len(st)==0 or st[-1]<=n:\n            st.append(n)\n        else:\n            ma = st[-1]\n            while st and st[-1]>n:\n                ma = max(ma,st.pop())\n            st.append(ma)\n    \n    return len(st)"}
{"prompt": "def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        \n        for num in arr:\n            lagest = num\n            while stack and num < stack[-1]:\n                lagest = max(lagest, stack.pop())\n\n            stack.append(lagest)\n        \n        return len(stack)"}
{"prompt": "def numJewelsInStones(self, J: str, S: str) -> int:\n    \treturn sum(i in J for i in S)\n\n\n\ndef numJewelsInStones(self, J: str, S: str) -> int:\n    \treturn sum(S.count(i) for i in J)\n\n\n\nfrom collections import Counter\n\ndef numJewelsInStones(self, J: str, S: str) -> int:\n    \treturn sum(Counter(S)[i] for i in J)\n\t\t\n\t\t\n\n- Junaid Mansuri\n(LeetCode ID)@hotmail.com"}
{"prompt": "def slidingPuzzle(self, board: List[List[int]]) -> int:\n        def isSolved(board):\n            if board[-1] != 0: return False\n            for i in range(5):\n                if board[i] != i + 1: return False\n            return True\n        \n        swap = {\n            0: [1, 3],\n            1: [0, 2, 4],\n            2: [1, 5],\n            3: [0, 4],\n            4: [1, 3, 5],\n            5: [2, 4],\n        }\n\n        q = [board[0] + board[1]]\n        steps = 0\n        seen = set()\n        while (len(q)):\n            new_q = []\n            for board in q:\n                if tuple(board) in seen: continue\n                seen.add(tuple(board))\n                if isSolved(board): return steps\n\n                zeroIdx = board.index(0)\n                for swapIdx in swap[zeroIdx]:\n                    copy = board.copy()\n                    copy[zeroIdx], copy[swapIdx] = copy[swapIdx], copy[zeroIdx]\n                    new_q.append(copy)\n            steps += 1\n            q = new_q\n\n        return -1"}
{"prompt": "def isIdealPermutation(self, A: List[int]) -> bool:\n        for i, a in enumerate(A):\n            if (abs(a - i) > 1):\n                return False\n        \n        return True"}
{"prompt": "def canTransform(self, S, E):\n        L, R, X = 0, 0, 0\n        for i, j in zip(S, E):\n            L += (j == 'L')\n            R += (i == 'R')\n            if i == 'R' and L: return False\n            if j == 'L' and R: return False\n            L -= (i == 'L')\n            R -= (j == 'R')\n            if L < 0 or R < 0: return False\n            X += (i == 'X') - (j == 'X')\n        return X == 0"}
{"prompt": "# O(max(n^2, m)) time, h --> the highest elevation in the grid\n    # O(n^2) space,\n    # Approach: BFS, Priority queue\n    # I wld advise to do task scheduler question, it's pretty similar\n    # except that u apply bfs to traverse the grid 4 directionally\n    def swimInWater(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        if n == 1:\n            return 0\n        \n        def getNeighbours(coord: Tuple) -> List[Tuple]:\n            i, j = coord\n            n = len(grid)\n            neighbours = []\n            \n            if i < n-1:\n                neighbours.append((i+1, j))\n            if i > 0:\n                neighbours.append((i-1, j))\n            if j < n-1:\n                neighbours.append((i, j+1))\n            if j > 0:\n                neighbours.append((i, j-1))\n                \n            return neighbours\n        \n        qu = deque()\n        waiting_qu = []\n        vstd = set()\n        waiting_qu.append([grid[0][0], (0, 0)])\n        vstd.add((0, 0))\n        time = 0\n        \n        while waiting_qu:\n            time +=1\n            while waiting_qu and waiting_qu[0][0] <= time:\n                qu.append(heapq.heappop(waiting_qu)[1])\n            \n            while qu:\n                cell = qu.popleft()\n                if cell == (n-1, n-1):\n                    return time\n                nbrs = getNeighbours(cell)\n                for nb in nbrs:\n                    if nb in vstd:  continue\n                    x, y = nb\n                    elevation = grid[x][y]\n                    vstd.add(nb)\n                    if elevation > time:\n                        heapq.heappush(waiting_qu, [elevation, nb])\n                    else:\n                        qu.append(nb)\n        \n        return -1"}
{"prompt": "def kthGrammar(self, N: int, K: int) -> int:\n        if N == 1: \n            return 0\n        half = 2**(N - 2) \n        \n        if K > half:\n            return 1 if self.kthGrammar(N - 1, K - half) == 0 else 0\n        else:\n            return self.kthGrammar(N - 1, K)"}
{"prompt": "def reachingPoints(self, sx: int, sy: int, tx: int, ty: int) -> bool:\n        if sx > tx or sy > ty: return False\n        if sx == tx: return (ty-sy)%sx == 0 # only change y\n        if sy == ty: return (tx-sx)%sy == 0\n        if tx > ty: \n            return self.reachingPoints(sx, sy, tx%ty, ty) # make sure tx%ty < ty\n        elif tx < ty: \n            return self.reachingPoints(sx, sy, tx, ty%tx)\n        else:\n            return False"}
{"prompt": "def numRabbits(self, answers: List[int]) -> int:\n        return sum((key+1) * math.ceil(freq / (key+1)) if key+1 < freq else key+1 for key, freq in collections.Counter(answers).items())"}
{"prompt": "def movesToChessboard(self, board: List[List[int]]) -> int:\n        n = len(board)\n        \n        def fn(vals): \n            \"\"\"Return min moves to transform to chessboard.\"\"\"\n            total = odd = 0 \n            for i, x in enumerate(vals): \n                if vals[0] == x: \n                    total += 1\n                    if i&amp;1: odd += 1\n                elif vals[0] ^ x != (1 << n) - 1: return inf\n            ans = inf \n            if len(vals) <= 2*total <= len(vals)+1: ans = min(ans, odd)\n            if len(vals)-1 <= 2*total <= len(vals): ans = min(ans, total - odd)\n            return ans \n        \n        rows, cols = [0]*n, [0]*n\n        for i in range(n): \n            for j in range(n): \n                if board[i][j]: \n                    rows[i] ^= 1 << j \n                    cols[j] ^= 1 << i\n        ans = fn(rows) + fn(cols)\n        return ans if ans < inf else -1"}
{"prompt": "def minDiffInBST(self, root: Optional[TreeNode]) -> int:\n        \n        # list with two element\n        # the first for the previous element\n        # the second for the min value\n        pre_mn = [-float(\"inf\"), float(\"inf\")]\n        \n        def dfs(tree):\n            \n            if not tree:\n                return\n            \n            # Keep going to the left\n            dfs(tree.left)\n            \n            # if we can't go further, update min and pre\n            pre_mn[1] = min(pre_mn[1], abs(tree.val) - pre_mn[0])\n            pre_mn[0] = tree.val\n            \n            # keep traversing in-order\n            dfs(tree.right)\n        \n        dfs(root)\n        \n        # return min (the second element in the list)\n        return pre_mn[1]"}
{"prompt": "def letterCasePermutation(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: List[str]\n        \"\"\"\n        def backtrack(sub=\"\", i=0):\n            if len(sub) == len(S):\n                res.append(sub)\n            else:\n                if S[i].isalpha():\n                    backtrack(sub + S[i].swapcase(), i + 1)\n                backtrack(sub + S[i], i + 1)\n                \n        res = []\n        backtrack()\n        return res"}
{"prompt": "def isBipartite(self, graph: list[list[int]]) -> bool:\n\t\n        vis = [False for n in range(0, len(graph))]\n        \n        while sum(vis) != len(graph): # Since graph isn't required to be connected this process needs to be repeated\n\n            ind = vis.index(False) # Find the first entry in the visited list that is false\n            vis[ind] = True\n            grp = {ind:True} # initialize first node as part of group 1\n            q = [ind] # Add current index to queue\n            \n            while q: # Go to each node in the graph\n                u = q.pop(0)\n\n                for v in graph[u]: # Go to each vertice connected to the current node\n\n                    if vis[v] == True: #  If visited check that it is in the opposite group of the current node\n                        if grp[u] == grp[v]:\n                            return False # If a single edge does not lead to a group change return false\n\n                    else: # If not visited put v in opposite group of u, set to visited, and append to q\n                        vis[v] = True\n                        grp[v] = not grp[u]\n                        q.append(v)\n        \n        return True"}
{"prompt": "def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\n\t\tif len(arr) > 2:\n\t\t\tres = []  # list for storing the list: [prime fraction of arr[i]/arr[j], arr[i], arr[j]]\n\n\t\t\tfor i in range(len(arr)):\n\t\t\t\tfor j in range(i + 1, len(arr)):\n\t\t\t\t\t# creating and adding the sublist to res\n\t\t\t\t\ttmp = [arr[i] / arr[j], arr[i], arr[j]]\n\t\t\t\t\tres.append(tmp)\n\n\t\t\t# sorting res on the basis of value of arr[i] \n\t\t\tres.sort(key=lambda x: x[0])\n\n\t\t\t# creating and returning the required list\n\t\t\treturn [res[k - 1][1], res[k - 1][2]]\n\t\telse:\n\t\t\treturn arr"}
{"prompt": "def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        #Make graph\n        adj_list = {i:[] for i in range(n)}\n        for frm, to, price in flights:\n            adj_list[frm].append((to, price))\n        \n        best_visited = [2**31]*n # Initialized to maximum\n        \n        prior_queue = [ (0, -1, src) ]  # weight, steps, node\n\n        while prior_queue:\n            cost, steps, node = heapq.heappop(prior_queue)\n            \n            if best_visited[node] <= steps:  # Have seen the node already, and the current steps are more than last time\n                continue\n\n            if steps > k:  # More than k stops, invalid\n                continue\n\n            if node==dst:  # reach the destination # as priority_queue is a minHeap so this cost is the most minimum cost.\n                return cost\n            \n            best_visited[node] = steps # Update steps\n\n            for neighb, weight in adj_list[node]:\n                heapq.heappush(prior_queue, (cost + weight, steps + 1, neighb))\n\n        return -1\n\t\t\n# Time: O(n * len(flights) * log(n))\n# Space: O(n)"}
{"prompt": "def rotatedDigits(self, N: int) -> int:\n        count = 0\n        for x in range(1, N+1):\n            x = str(x)\n            if '3' in x or '4' in x or '7' in x:\n                continue\n            if '2' in x or '5' in x or '6' in x or '9' in x:\n                count+=1\n        return count"}
{"prompt": "def escapeGhosts(self, ghosts: List[List[int]], target: List[int]) -> bool:\n        t_x, t_y = target\n        m_x, m_y = abs(t_x), abs(t_y)\n        for x, y in ghosts:\n            manhattan = abs(t_x - x) + abs(t_y - y)\n            if manhattan <= m_x + m_y:\n                return False\n        return True"}
{"prompt": "def numTilings(self, n):\n        dp = [1, 2, 5] + [0] * n\n        for i in range(3, n):\n            dp[i] = (dp[i - 1] * 2 + dp[i - 3]) % 1000000007\n        return dp[n - 1]"}
{"prompt": "def customSortString(self, order: str, s: str) -> str:\n\n        rank = [26]*26\n        \n        for i in range(len(order)):\n            rank[ord(order[i]) - ord('a')] = i\n\n        return \"\".join(sorted(list(s), key= lambda x: rank[ord(x) - ord('a')]))"}
{"prompt": "def numMatchingSubseq(self, s: str, words: List[str]) -> int:\n    \n    def is_sub(word):\n        index=-1\n        for ch in word:\n            index=s.find(ch,index+1)\n            if index==-1:\n                return False\n        return True\n    \n    c=0\n    for word in words:\n        if is_sub(word):\n            c+=1\n    \n    return c"}
{"prompt": "def preimageSizeFZF(self, k: int) -> int:\n        lo, hi = 0, 1 << 32\n        while lo <= hi: \n            mid = lo + hi >> 1\n            x, y = mid, 0 \n            while x: \n                x //= 5\n                y += x\n            if y < k: lo = mid + 1\n            elif y > k: hi = mid - 1\n            else: return 5\n        return 0"}
{"prompt": "def validTicTacToe(self, board: List[str]) -> bool:\n                                            # The two criteria for a valid board are:\n                                            #   1) num of Xs - num of Os is 0 or 1\n                                            #   2) X is not a winner if the # of moves is even, and\n                                            #      O is not a winner if the # of moves is odd.\n\n        d = {'X': 1, 'O': -1, ' ': 0}               # transform the 1x3 str array to a 1x9 int array\n        s = [d[ch] for ch in ''.join(board)]        # Ex: [\"XOX\",\" X \",\"   \"] --> [1,-1,1,0,1,0,0,0,0]\n        sm = sum(s)\n\n        if sm>>1: return False                                      # <-- criterion 1\n        \n        n = -3 if sm == 1 else 3                                    # <-- criterion 2.\n        if n in {s[0]+s[1]+s[2], s[3]+s[4]+s[5], s[6]+s[7]+s[8], \n                 s[0]+s[3]+s[6], s[1]+s[4]+s[7], s[2]+s[5]+s[8],         # the elements of the set are \n                 s[0]+s[4]+s[8], s[2]+s[4]+s[6]}: return False           # the rows, cols, and diags\n        \n        return True                                                 # <-- both criteria are true"}
{"prompt": "def numSubarrayBoundedMax(self, nums: List[int], left: int, right: int) -> int:\n        start,end = -1, -1\n        res = 0\n        for i in range(len(nums)):\n            if nums[i] > right:\n                start = end = i\n                continue\n                \n            if nums[i] >= left:\n                end = i\n                \n            res += end - start\n        return res"}
{"prompt": "def rotateString(self, s: str, goal: str) -> bool:\n        return len(s) == len(goal) and s in goal+goal"}
{"prompt": "def allPathsSourceTarget(self, graph: List[List[int]]) -> List[List[int]]:\n            q = [[0]]\n            result = []\n            target = len(graph) - 1\n            \n            while q:\n                temp = q.pop(0)\n                \n                if temp[-1] == target:\n                    result.append(temp)\n                else:\n                    for neighbor in graph[temp[-1]]:\n                        q.append(temp + [neighbor])\n            \n            return result"}
{"prompt": "def bestRotation(self, nums: List[int]) -> int:\n        diff = [0]*(len(nums) + 1)\n        for i, x in enumerate(nums): \n            diff[i+1] += 1\n            if x <= i: diff[0] += 1\n            diff[(i-x)%len(nums) + 1] -= 1\n        \n        ans = prefix = 0 \n        mx = -inf \n        for i, x in enumerate(diff): \n            prefix += x\n            if prefix > mx: mx, ans = prefix, i\n        return ans"}
{"prompt": "def champagneTower(self, poured: int, query_row: int, query_glass: int) -> float:\n        dp = [[0 for _ in range(x)] for x in range(1, query_row + 2)]\n        dp[0][0] = poured\n        \n        for i in range(query_row):\n            for j in range(len(dp[i])):\n                temp = (dp[i][j] - 1) / 2.0\n                if temp>0:\n                    dp[i+1][j] += temp\n                    dp[i+1][j+1] += temp\n        \n        return dp[query_row][query_glass] if dp[query_row][query_glass] <= 1 else 1"}
{"prompt": "def minSwap(self, A: List[int], B: List[int]) -> int:\n        ans = sm = lg = mx = 0\n        for x, y in zip(A, B): \n            if mx < min(x, y): # prev max < current min\n                ans += min(sm, lg) # update answer &amp; reset \n                sm = lg = 0 \n            mx = max(x, y)\n            if x < y: sm += 1 # count \"x < y\"\n            elif x > y: lg += 1 # count \"x > y\"\n        return ans + min(sm, lg)"}
{"prompt": "def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        n=len(graph)\n        status=[0]*(n)\n        res=[]\n        \n        def dfs(i):# this function will check is there any loop, cycle and i is a part of that loop,cycle \n            if status[i]==\"visited\": #if this node is already visited, loop detected return true\n                return True\n            if status[i]==\"safe\": #if this node is previously visited and marked safe no need to repeat it ,return False no loop possible from it\n                return False\n            status[i]=\"visited\" # so we have visited this node\n            for j in graph[i]:\n                if  dfs(j):# if loop detected return True\n                    return True\n            status[i]=\"safe\" # if we reached till here means no loop detected from node i so this node is safe\n            return False # no loop possible return false\n       \n    \n        for i in range(n):\n            if not dfs(i): #if no loop detected this node is safe \n                res.append(i)\n        return res"}
{"prompt": "\"\"\"\n\tTime:   O(n)\n\tMemory: O(n)\n\t\"\"\"\n\n\tMORSE = {\n\t\t'a': '.-',   'b': '-...', 'c': '-.-.', 'd': '-..',  'e': '.',    'f': '..-.', 'g': '--.',\n\t\t'h': '....', 'i': '..',   'j': '.---', 'k': '-.-',  'l': '.-..', 'm': '--',   'n': '-.',\n\t\t'o': '---',  'p': '.--.', 'q': '--.-', 'r': '.-.',  's': '...',  't': '-',    'u': '..-',\n\t\t'v': '...-', 'w': '.--',  'x': '-..-', 'y': '-.--', 'z': '--..',\n\t}\n\n\tdef uniqueMorseRepresentations(self, words: List[str]) -> int:\n\t\treturn len(set(map(self.encode, words)))\n\n\t@classmethod\n\tdef encode(cls, word: str) -> str:\n\t\treturn ''.join(map(cls.MORSE.get, word))"}
{"prompt": "def splitArraySameAverage(self, A):\n        if len(A)==1: return False\n        global_avg = sum(A)/float(len(A))\n        for lenB in range(1, len(A)/2+1):\n            if int(lenB*global_avg) == lenB*global_avg:\n                if self.exist(lenB*global_avg, lenB, A):\n                    return True\n        return False\n            \n    def exist(self, tosum, item_count, arr):\n        if item_count==0:\n            return False if tosum else True\n        if item_count > len(arr) or not arr: \n            return False\n        if any([self.exist(tosum-arr[0], item_count-1, arr[1:]),\n               self.exist(tosum, item_count, arr[1:])]):\n            return True\n        return False"}
{"prompt": "def numberOfLines(self, widths: List[int], s: str) -> List[int]:\n        count = ans =  wi = 0\n        s = list(s)\n        while s:\n            val = ord(s[0]) - 97\n            \n            if(widths[val] + wi > 100):\n                wi = 0\n                count += 1\n            \n            wi += widths[val]\n            \n            s.pop(0)\n        return([count + 1 , wi])"}
{"prompt": "def maxIncreaseKeepingSkyline(self, G: List[List[int]]) -> int:\n        M, N, R, C = len(G), len(G[0]), [max(r) for r in G], [max(c) for c in zip(*G)]\n        return sum(min(R[i],C[j]) - G[i][j] for i,j in itertools.product(range(M),range(N)))\n\t\t\n\t\t\n- Junaid Mansuri\n- Chicago, IL"}
{"prompt": "def soupServings(self, n: int) -> float:\n        @cache                                 # cache the result for input (a, b)\n        def dfs(a, b):\n            if a <= 0 and b > 0: return 1      # set criteria probability\n            elif a <= 0 and b <= 0: return 0.5\n            elif a > 0 and b <= 0: return 0\n            return (dfs(a-4, b) + dfs(a-3, b-1) + dfs(a-2, b-2) + dfs(a-1, b-3)) * 0.25 # dfs\n        if n > 4275: return 1                  # observe the distribution you will find `a` tends to be easier to get used up than `b`\n        n /= 25                                # reduce the input scale\n        return dfs(n, n)                       # both soup have `n` ml"}
{"prompt": "def expressiveWords(self, s: str, words: List[str]) -> int:\n        \n        def summarize(word):\n            res = []\n            \n            n = len(word)\n            i, j = 0, 0\n            while i<=j and j <= n-1:\n                while j <= n-1 and word[j] == word[i]:\n                    j += 1\n                res.append(word[i])\n                res.append(j-i)\n                i = j\n            return res\n        \n        t = 0 \n        start = summarize(s)\n        n = len(start)//2\n        def compare(w):\n            r = summarize(w)\n        \n            if len(r) != len(start):\n                return False \n            for i in range(0, 2*n, 2):\n                if start[i] != r[i]:\n                    return False\n                elif start[i] == r[i]:\n                    if start[i+1] < r[i+1]:\n                        return False\n                    elif start[i+1] == r[i+1]:\n                        pass \n                    elif start[i+1] < 3:\n                        return False\n            return True\n\n        for w in words:\n            if compare(w):\n                t += 1\n        return t"}
{"prompt": "def xorGame(self, nums):\n        #create a variable 0 \n        x = 0 \n        #iterate over the elements in the nums\n        for i in nums:\n            #do xor of all the elements\n            x ^= i \n        #Alice wins in two situations :\n        #1.if the xor is already 0 (x == 0 )\n        #2.if the length of nums is even because if alice got chance with even length and xor != 0 he will select a number so that he will leave the odd number of same integer \n        #if nums == [a,a,a,b] then alice erase b so bob must erase from [a,a,a] so he will lose if he erase any number \n        return x == 0 or len(nums)%2 == 0 \n        #in other situations bob will win"}
{"prompt": "def subdomainVisits(self, cpdomains: List[str]) -> List[str]:\n        d = defaultdict(int)\n        for s in cpdomains:\n            cnt, s = s.split()\n            cnt = int(cnt)\n            d[s] += cnt\n            pos = s.find('.') + 1\n            while pos > 0:\n                d[s[pos:]] += cnt\n                pos = s.find('.', pos) + 1\n        for x, i in d.items():\n            yield f'{i} {x}'"}
{"prompt": "def largestTriangleArea(self, points: List[List[int]]) -> float:        \n       \n        area = 0\n        n = len(points)\n        for i in range(n):\n            x1,y1 = points[i]\n            for j in range(i+1,n):\n                x2,y2 = points[j]\n                for k in range(j+1,n):\n                    x3,y3 = points[k]\n                    curr = abs(0.5*(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)))\n                    if curr>area:\n                        area = curr\n        return area"}
{"prompt": "def largestSumOfAverages(self, nums: List[int], k: int) -> float:\n        \n        @lru_cache(maxsize=None)\n        def maxAvgSum(index: int, partitions_left: int) -> int:\n            if partitions_left == 1:\n                return sum(nums[index:]) / (len(nums) - index)\n\n            max_sum: float = 0.0\n            for i in range(index, len(nums) - (partitions_left - 1)):\n                cur_sum: float = sum(nums[index:i + 1])/(i + 1 - index)\n                cur_sum += maxAvgSum(i + 1, partitions_left - 1)\n                max_sum = max(cur_sum, max_sum)\n            return max_sum\n    \n        return maxAvgSum(0, k)"}
{"prompt": "def pruneTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        if root==None:\n            return None\n        _l = self.pruneTree(root.left)\n        _r = self.pruneTree(root.right)\n        if root.val == 0 and _l == None and _r == None:\n            return None\n        else:\n            root.left = _l\n            root.right = _r\n        return root"}
{"prompt": "def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:\n        m = defaultdict(set)\n        for i, route in enumerate(routes):\n            for node in route:\n                m[node].add(i)\n        ans = -1\n        vis = set()\n        queue = deque()\n        queue.append(source)\n        while queue:\n            l = len(queue)\n            ans += 1\n            for _ in range(l):\n                cur = queue.popleft()\n                if cur == target:\n                    return ans\n                for bus in m[cur]:\n                    if bus not in vis:\n                        vis.add(bus)\n                        queue.extend(routes[bus])\n        return -1"}
{"prompt": "def ambiguousCoordinates(self, s: str) -> List[str]:\n        s = s.strip(\"(\").strip(\")\")\n        \n        def fn(s): \n            \"\"\"Return valid numbers from s.\"\"\"\n            if len(s) == 1: return [s]\n            if s.startswith(\"0\") and s.endswith(\"0\"): return []\n            if s.startswith(\"0\"): return [s[:1] + \".\" + s[1:]]\n            if s.endswith(\"0\"): return [s]\n            return [s[:i] + \".\" + s[i:] for i in range(1, len(s))] + [s]\n        \n        ans = []\n        for i in range(1, len(s)): \n            for x in fn(s[:i]):\n                for y in fn(s[i:]): \n                    ans.append(f\"({x}, {y})\")\n        return ans"}
{"prompt": "def numComponents(self, head: ListNode, G: List[int]) -> int:\n        Gs = set(G)\n        ans = 0\n        while head: \n            if head.val in Gs and (head.next is None or head.next.val not in Gs): ans += 1\n            head = head.next \n        return ans"}
{"prompt": "def racecar(self, target: int) -> int:\n    \n    q = deque()\n    q.append((0,0,1))\n    while q:\n        m,p,s = q.popleft()\n        if p==target:\n            return m\n        rev = -1 if s>0 else 1\n\t\t\n        q.append((m+1,p+s,s*2))\n        \n        if (p+s<target and s<0) or (p+s>target and s>0):        # If you are back to the target and speed is reverse or if you are ahead of target and speed is positive then reverse the speed\n            q.append((m+1,p,rev))\n    \n    return -1"}
{"prompt": "def getSplit(self, s):\n        result = []\n        strS = ''\n        for i in s.lower():\n            if i not in \"!?',;. \": strS += i\n            else:\n                if len(strS) > 0: result.append(strS)\n                strS = ''\n        if len(strS) > 0: result.append(strS)\n        return result\n\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\n        paragraph = self.getSplit(paragraph)\n        freq = {}\n        for s in paragraph:\n            if s not in banned:\n                if s in freq: freq[s] += 1\n                else: freq[s] = 1\n                \n        m = max(freq.values())\n        for k in freq:\n            if freq[k] == m: return k"}
{"prompt": "def minimumLengthEncoding(self, words: List[str]) -> int:\n        words.sort(key=len, reverse=True)\n        res = []\n        for suffix in words:\n            if not any(word.endswith(suffix) for word in res):  # check that this word is not actually a suffix\n                res.append(suffix)\n        return sum(len(word)+1 for word in res)  # append hash '#' symbol to each word that is not a suffix"}
{"prompt": "def shortestToChar(self, s: str, c: str) -> List[int]:\n        L = []\n        for idx, value in enumerate(s):\n            if value == c:\n                L.append(idx)\n        \n        distance = []\n        i = 0\n        for idx, value in enumerate(s):\n            if value == c:\n                distance.append(0)\n                i += 1\n            elif idx < L[0]:\n                distance.append(L[0] - idx)\n            elif idx > L[-1]:\n                distance.append(idx - L[-1])\n            else:\n                distance.append(min((L[i] - idx), (idx - L[i-1])))                    \n        return distance"}
{"prompt": "def flipgame(self, fronts: List[int], backs: List[int]) -> int:\n        \"\"\"\n        O(n) time complexity: n is length of fronts\n        O(n) space complexity\n        \"\"\"\n        same = {x for i, x in enumerate(fronts) if x == backs[i]}\n        res = 9999\n        for i in range(len(fronts)):\n            if fronts[i] not in same: res = min(res, fronts[i])\n            if backs[i] not in same: res = min(res, backs[i])\n        return res % 9999"}
{"prompt": "def numFactoredBinaryTrees(self, arr: List[int]) -> int:\n        total_nums = len(arr)\n        moduler = 1000000007\n        count_product_dict = {num: 1 for num in arr}\n        arr.sort()\n\n        for i in range(1, total_nums):\n            for j in range(i):\n                quotient = arr[i] // arr[j]\n                if quotient < 2 or math.sqrt(arr[i]) > arr[i- 1]:\n                    break\n                if arr[i] % arr[j] == 0:\n                    count_product_dict[arr[i]] += count_product_dict[arr[j]] * count_product_dict.get(quotient, 0)\n                    count_product_dict[arr[i]] %= moduler\n                    \n        return sum(count_product_dict.values()) % moduler"}
{"prompt": "def toGoatLatin(self, sentence: str) -> str:\n        new = sentence.split() # Breaks up the input into individual sentences\n        count = 1 # Starting at 1 since we only have one \"a\" to begin with.\n        \n        for x in range(len(new)):\n            if new[x][0].casefold() in 'aeiou': # Checks if the first value of x is a vowel. The casefold, can be replaced with lower, lowers the case. Can also just be removed and have \"in 'aeiouAEIOU'\n                new[x] = new[x] + 'ma' + 'a'*count # Brings it together with the count multiplying number of \"a\"'s as needed.\n                count += 1\n            elif new[x].casefold() not in 'aeiou': # Same comment as above.\n                new[x] = new[x][1:] + new[x][0] + 'ma' + 'a'*count # Just moves the first value to the end then does the a.\n                count += 1\n        \n        return \" \".join(x for x in new) # Converts the list back into a string."}
{"prompt": "def numFriendRequests(self, ages: List[int]) -> int:\n        ages.sort()                                   # sort the `ages`\n        ans = 0\n        n = len(ages)\n        for idx, age in enumerate(ages):              # for each age\n            lb = age                                  # lower bound\n            ub = (age - 7) * 2                        # upper bound\n            i = bisect.bisect_left(ages, lb)          # binary search lower bound\n            j = bisect.bisect_left(ages, ub)          # binary search upper bound\n            if j - i <= 0: continue\n            ans += j - i                              # count number of potential friends\n            if lb <= age < ub:                        # ignore itself\n                ans -= 1\n        return ans"}
{"prompt": "#Time-Complexity: O(n + nlogn + n + mlog(n)) -> O((n+m) *logn)\n    #Space-Complexity: O(n)\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        #Approach: First of all, linearly traverse each and every corresponding index\n        #position of first two input arrays: difficulty and profit to group each\n        #item by 1-d array and put it in separate 2-d array. Then, sort the 2-d array\n        #by increasing difficulty of the job! Then, for each worker, perform binary\n        #search and consistently update the max profit the current worker can work and\n        #earn! Add this value to answer variable, which is cumulative for all workers!\n        #this will be the result returned at the end!\n        arr = []\n        for i in range(len(difficulty)):\n            arr.append([difficulty[i], profit[i]])\n        #sort by difficulty!\n        arr.sort(key = lambda x: x[0])\n        #then, I need to update the maximum profit up to each and every item!\n        maximum = float(-inf)\n        for j in range(len(arr)):\n            maximum = max(maximum, arr[j][1])\n            arr[j][1] = maximum\n        ans = 0\n        #iterate through each and every worker!\n        for w in worker:\n            bestProfit = 0\n            #define search space to perform binary search!\n            L, R = 0, len(arr) - 1\n            #as long as search space has at least one element to consider or one job,\n            #continue iterations of binary search!\n            while L <= R:\n                mid = (L + R) // 2\n                mid_e = arr[mid]\n                #check if current job has difficulty that is manageable!\n                if(mid_e[0] <= w):\n                    bestProfit = max(bestProfit, mid_e[1])\n                    #we still need to search right and try higher difficulty\n                    #jobs that might yield higher profit!\n                    L = mid + 1\n                    continue\n                else:\n                    R = mid - 1\n                    continue\n            #once we break from while loop and end binary search, we should have\n            #found bestProfit for current worker performing task that is manageable!\n            ans += bestProfit\n        return ans"}
{"prompt": "def largestIsland(self, grid: List[List[int]]) -> int:\n        N = len(grid)\n        DIRECTIONS = [(-1, 0), (0, -1), (0, 1), (1, 0)]\n        \n\t\taddress = {}\n        def dfs(row, column, island_id):\n            queue = deque([(row, column, island_id)])\n            visited.add((row, column))\n            area = 1\n            while queue: \n                row, column, island_id = queue.pop()\n                address[(row, column)] = island_id\n                for direction in DIRECTIONS:\n                    r, c = row + direction[0], column + direction[1]\n                    if r in range(N) and c in range(N) and grid[r][c] == 1 and (r, c) not in visited:\n                        queue.append((r, c, island_id))\n                        visited.add((r, c))\n                        area += 1\n            return area\n        \n        visited = set()\n        area = {}\n        island_id = 0\n        for row in range(N):\n            for column in range(N):\n                if grid[row][column] == 1 and (row, column) not in visited:\n                    area[island_id] = dfs(row, column, island_id)\n                    island_id += 1\n                    \n        if len(address.keys()) == N**2: return N**2   \n        \n        largest_area = 1\n        for row in range(N):\n            for column in range(N):\n                if grid[row][column] == 1: continue\n                neighbours = set()\n                large_area = 1\n                for direction in DIRECTIONS:\n                    r, c = row + direction[0], column + direction[1]\n                    if r in range(N) and c in range(N) and grid[r][c] == 1 and address[(r, c)] not in neighbours:\n                        neighbours.add(address[(r, c)])\n                        large_area += area[address[(r, c)]]\n                largest_area = max(largest_area, large_area)\n                \n        return largest_area"}
{"prompt": "def uniqueLetterString(self, s: str) -> int:\n        r=0\n        for i in range(len(s)):\n            for j in range(i, len(s)):\n                ss=s[i:j+1]\n                unique=sum([ 1 for (i,v) in Counter(ss).items() if v == 1 ])\n                r+=unique\n        return r"}
{"prompt": "def consecutiveNumbersSum(self, n: int) -> int:\n        csum=0\n        result=0\n        for i in range(1,n+1):\n            csum+=i-1\n            if csum>=n:\n                break\n            if (n-csum)%i==0:\n                result+=1\n        return result"}
{"prompt": "def largeGroupPositions(self, s):\n        s += \" \"\n        \n        streak, char, out = 0, s[0], []\n        \n        for i,c in enumerate(s):\n            if c != char:\n                if streak >= 3:\n                    out.append([i-streak, i-1])\n                \n                streak, char = 0, s[i]\n                \n            streak += 1\n        \n        return out"}
{"prompt": "def maskPII(self, s: str) -> str:\n        if '@' in s: return f'{s[0].lower()}*****{s[s.index(\"@\")-1].lower()+\"\".join([x.lower() for x in s[s.index(\"@\"):]])}'\n        s=''.join([x for x in s if x not in '()- +'])\n        return ('' if len(s)<=10 else '+'+'*'*(len(s)-10)+'-')+f'***-***-{s[-4:]}'"}
{"prompt": "def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        Simple &amp; striaghtforward without using inbuilt functions.\n     \n        In actual the run time is very less as we are iterating only n/2 time\n        for each image list.\n        Time complexity : O(n * n/2) == O(n^2) \n        Space complexity : O(1)\n        \"\"\"\n        \n        for im in image: #Iterate through each im list in the image list.\n            i, j = 0, len(im)-1    #Maintain two pointers one at start and one at end.\n            while i <= j:          #Iterate while first pointer is less than or equal to second pointer.\n                im[i], im[j] = im[j]^1, im[i]^1   #swap element at both pointer &amp; complement them at the same time.\n                i +=1              #increment first pointer to move forward\n                j -=1              #decrement second pointer to move backward\n            \n        return image         # return same list\n    \n    \n        \"\"\"\n        Using inbuilt functions\n        \"\"\"\n        # for im in range(len(image)):\n        #     image[im] = list(map(lambda a : abs(a-1), reversed(image[im])))\n        # return image\n    \n        \"\"\"\n        One liner\n        \"\"\"\n        return [[i^1 for i in im[::-1]] for im in image]"}
{"prompt": "def findReplaceString(self, s: str, indices: List[int], sources: List[str], targets: List[str]) -> str:\n        # iterate from the greater index to the smallest\n        for i, src, tg in sorted(list(zip(indices, sources, targets)), reverse=True):    \n            # if found the pattern matches with the source, replace with the target accordingly\n            if s[i:i+len(src)] == src: s = s[:i] + tg + s[i+len(src):]            \n        return s"}
{"prompt": "def sumOfDistancesInTree(self, n: int, edges: List[List[int]]) -> List[int]:\n        graph = {}\n        for u, v in edges: \n            graph.setdefault(u, []).append(v)\n            graph.setdefault(v, []).append(u)\n        \n        size = [0]*n\n        \n        def fn(x, par): \n            \"\"\"Return size and sum of distances in sub-tree.\"\"\"\n            c = s = 0\n            for xx in graph.get(x, []): \n                if xx != par: \n                    cc, ss = fn(xx, x)\n                    c, s = c + cc, s + ss + cc\n            size[x] = c + 1\n            return c + 1, s\n        \n        ans = [0]*n\n        ans[0] = fn(0, -1)[1]\n        \n        stack = [0]\n        while stack: \n            x = stack.pop()\n            for xx in graph.get(x, []): \n                if not ans[xx]: \n                    ans[xx] = ans[x] + n - 2*size[xx]\n                    stack.append(xx)\n        return ans"}
{"prompt": "def largestOverlap(self, img1: List[List[int]], img2: List[List[int]]) -> int:\n        n = len(img1)\n        bestOverlap = 0\n\n        def helper(dr, dc):\n            overlap = 0\n            for r in range(n):\n                for c in range(n):\n                    nr, nc = r + dr, c + dc\n                    if nr in range(n) and nc in range(n) and img1[nr][nc] == 1 and img2[r][c] == 1:\n                        overlap += 1\n\n            return overlap\n\n        for r in range(-n, n):\n            for c in range(-n, n):\n                bestOverlap = max(helper(r, c), bestOverlap)\n\n        return bestOverlap"}
{"prompt": "def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:\n        [A,B,C,D], [E,F,G,H] = rec1, rec2\n        return F<D and E<C and B<H and A<G\n\t\t\n\t\t\n- Python 3\n- Junaid Mansuri"}
{"prompt": "def new21Game(self, N: int, K: int, W: int) -> float:\n        \n        @lru_cache(None)\n        def fn(n): \n            \"\"\"Return prob of of points between K and N given current point n.\"\"\"\n            if N < n: return 0\n            if K <= n: return 1\n            if n+1 < K: return (1+W)/W*fn(n+1) - 1/W*fn(n+W+1)\n            return 1/W*sum(fn(n+i) for i in range(1, W+1))\n        \n        return fn(0)"}
{"prompt": "def pushDominoes(self, dominoes: str) -> str:\n        dominoes = 'L' + dominoes + 'R'\n        res = []\n        left = 0\n        \n        for right in range(1, len(dominoes)):\n            if dominoes[right] == '.': \n                continue\n                \n            middle = right - left - 1\n            if left: \n                res.append(dominoes[left])\n            if dominoes[left] == dominoes[right]: \n                res.append(dominoes[left] * middle)\n            elif dominoes[left] == 'L' and dominoes[right] == 'R':\n                res.append('.' * middle)\n            else: \n                res.append('R' * (middle // 2) + '.' * (middle % 2) + 'L' * (middle // 2))\n            left = right\n            \n        return ''.join(res)"}
{"prompt": "def numSimilarGroups(self, strs: List[str]) -> int:\n        N = len(strs)\n        parent = [i for i in range(N)]\n        depth = [1 for _ in range(N)]\n\n        def find(idx):\n            if idx != parent[idx]:\n                return find(parent[idx])\n            return idx\n        \n        def union(idx1, idx2):\n            p1 = find(idx1)\n            p2 = find(idx2)\n            if p1 == p2: return\n            if depth[p1] < depth[p2]:\n                parent[p1] = p2\n            elif depth[p2] < depth[p1]:\n                parent[p2] = p1\n            else:\n                parent[p2] = p1\n                depth[p1] += 1\n\n        def similar(w1, w2):\n            dif_idx = -1\n            for idx in range(len(w1)):\n                if w1[idx] != w2[idx]:\n                    if dif_idx < 0:\n                        dif_idx = idx\n                    else:\n                        if w1[dif_idx] != w2[idx]: return False\n                        if w2[dif_idx] != w1[idx]: return False\n                        if w1[idx+1:] != w2[idx+1:]: return False\n                        return True\n            return True\n                    \n        for idx in range(1, N):\n            for pid in range(0, idx):\n                if similar(strs[pid], strs[idx]):\n                    union(pid, idx)\n\n        return len([i for i, p in enumerate(parent) if i==p])"}
{"prompt": "def numMagicSquaresInside(self, G: List[List[int]]) -> int:\n    \tM, N, S, t = len(G)-2, len(G[0])-2, {(8,1,6,3,5,7,4,9,2),(6,1,8,7,5,3,2,9,4),(2,7,6,9,5,1,4,3,8),(6,7,2,1,5,9,8,3,4)}, range(3)\n    \treturn sum((lambda x: x in S or x[::-1] in S)(tuple(sum([G[i+k][j:j+3] for k in t],[]))) for i,j in itertools.product(range(M),range(N)))"}
{"prompt": "def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\n        visited_rooms = set()\n        stack = [0] # for rooms that we need to visit and we start from room [0]\n        \n        while stack: \n            room = stack.pop() \n            visited_rooms.add(room)\n            for key in rooms[room]:\n                if key not in visited_rooms:\n                    stack.append(key)\n        return len(visited_rooms) == len(rooms)"}
{"prompt": "def splitIntoFibonacci(self, num: str) -> List[int]:\n        def dfs(i):\n            if i>=len(num):\n                return len(ans)>2           \n            n = 0\n            for j in range(i, len(num)):\n                n = n*10 + int(num[j]) \n                if n>2**31: # if number exceeds the range mentioned\n                    return False\n                # if len < 2 we know more elements need to be appended\n                # as size>=3 if size is already greater we check for fibonacci\n                # as last + secondLast == curr\n                if len(ans)<2 or (ans[-1]+ans[-2]==n):\n                    ans.append(n)\n                    if dfs(j+1):\n                        return True\n                    ans.pop()\n                if i==j and num[j]=='0': # if trailing 0 is present\n                    return False\n        \n        if len(num)<=2: return []\n        ans = []\n        if dfs(0): return ans\n        return []"}
{"prompt": "def findSecretWord(self, words: List[str], master: 'Master') -> None:        \n        k = 1 # for tracing the number of loops\n        matches = 0\n        blacklists = [[] for i in range(6)]\n        \n        while matches != 6:\n            n = len(words)\n            r = random.randint(0, n - 1)\n            matches = master.guess(words[r])\n            key = words[r]\n            # print(k, n, r, matches, key)\n            \n            words.pop(r)\n            \n            if matches == 0:\n                for i in range(6):\n                    blacklists[i].append(key[i])\n                # print(blacklists)\n            \n            elif matches > 0 and matches < 6:\n                candidates = []\n                for i in range(n - 1):\n                    count = 0\n                    for j in range(6):\n                        if words[i][j] not in blacklists[j] and words[i][j] == key[j]:\n                            count += 1\n                    if count >= matches:\n                        candidates.append(words[i])\n                            \n                words = candidates.copy()\n                # print(words)\n            \n            k += 1"}
{"prompt": "def backspaceCompare(self, S: str, T: str) -> bool:\n    \ta, A = [collections.deque(), collections.deque()], [S,T]\n    \tfor i in range(2):\n\t    \tfor j in A[i]:\n   \t\t \t\tif j != '#': a[i].append(j)\n   \t\t \t\telif a[i]: a[i].pop()\n    \treturn a[0] == a[1]"}
{"prompt": "def longestMountain(self, arr: List[int]) -> int:\n        increasing = False\n        increased = False\n        mx = -math.inf\n        curr = -math.inf\n        for i in range(1, len(arr)):\n            if arr[i] > arr[i-1]:\n                if increasing:\n                    curr += 1\n                    increased = True\n                else:\n                    mx = max(curr, mx)\n                    curr = 2\n                    increased = True\n                    increasing = True\n            elif arr[i] < arr[i-1]:\n                if increasing:\n                    increasing = False\n                curr += 1\n            else:\n                if increased and not increasing:\n                    mx = max(mx, curr)\n                curr = -math.inf\n                increased = False\n                increasing = False\n        if not increasing and increased:\n            mx = max(mx, curr)\n        return 0 if mx == -math.inf else mx"}
{"prompt": "def isNStraightHand(self, hand: List[int], groupSize: int) -> bool:\n        counter = Counter(hand)\n        while counter:\n            n = groupSize\n            start = min(counter.keys())\n            while n:\n                if start not in counter:\n                    return False\n                counter[start] -= 1\n                if not counter[start]:\n                    del counter[start]\n                start += 1\n                n -= 1\n        return True"}
{"prompt": "def shortestPathLength(self, graph: List[List[int]]) -> int:\n\n\t\tlength = len(graph)\n\n\t\tresult = 0\n\n\t\tvisited_node = []\n\n\t\tqueue = []  \n\n\t\tfor i in range(length):\n\t\t\tvisited_node.append(set([1<<i]))\n\t\t\tqueue.append([i,1<<i])\n\n\t\twhile queue:\n\n\t\t\tresult = result + 1\n\n\t\t\tnew_queue = []\n\n\t\t\tfor node, value in queue:\n\n\t\t\t\tfor neigbour_node in graph[node]:\n\n\t\t\t\t\tmid_node = (1<<neigbour_node)|value\n\n\t\t\t\t\tif mid_node not in visited_node[neigbour_node]:\n\n\t\t\t\t\t\tif mid_node+1 == 1<<length:\n\n\t\t\t\t\t\t\treturn result\n\n\t\t\t\t\t\tvisited_node[neigbour_node].add(mid_node)\n\n\t\t\t\t\t\tnew_queue.append([neigbour_node, mid_node])\n\n\t\t\tqueue = new_queue\n\n\t\treturn 0"}
{"prompt": "def shiftingLetters(self, S: str, shifts: List[int]) -> str:\n        \n        final_shift = list(accumulate(shifts[::-1]))[::-1]\n        \n        s_list = list(S)\n        \n        for x in range(len(s_list)):\n            midval = ord(s_list[x]) + final_shift[x]%26\n            if midval > 122:\n                midval = midval - 26\n            \n            s_list[x] = chr(midval)\n        \n        return ''.join(s_list)"}
{"prompt": "def maxDistToClosest(self, seats: List[int]) -> int:\n        #initialization, starting index is 0, result is res\n        left,res,index = -1,0,0\n        while index != len(seats):\n            # only right is 1\n            if left == -1 and seats[index] == 1:\n                res = max(res,index)\n                left = index\n                index+=1\n                continue\n            # only left is 1\n            if index == len(seats)-1 and seats[index] == 0:\n                res = max(res,index-left)\n                index+=1\n                continue\n            # left and right both 1, sitting in the middle\n            if seats[index] == 1:\n                res = max(res,(index-left)//2)\n                left = index\n            index+=1\n        return res"}
{"prompt": "def rectangleArea(self, rectangles: List[List[int]]) -> int:\n        line = []\n        for x1, y1, x2, y2 in rectangles: \n            line.append((y1, x1, x2, 1))\n            line.append((y2, x1, x2, 0))\n        \n        ans = yy = val = 0\n        seg = []\n        for y, x1, x2, tf in sorted(line): \n            ans += val * (y - yy)\n            yy = y \n            if tf: insort(seg, (x1, x2))\n            else: seg.remove((x1, x2))\n            val = 0 \n            prev = -inf \n            for x1, x2 in seg: \n                val += max(0, x2 - max(x1, prev))\n                prev = max(prev, x2)\n        return ans % 1_000_000_007"}
{"prompt": "def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:\n        richer_count = [0 for _ in range(len(quiet))]\n        graph = defaultdict(list)\n        answer = [idx for idx in range(len(quiet))]\n        \n        ## create the graph so that we go from the richer to the poorer\n        for rich, poor in richer:\n            graph[rich].append(poor)\n            richer_count[poor] += 1\n            \n        ## we include the richest ones.\n        queue = collections.deque([])\n        for person, rich_count in enumerate(richer_count):\n            if not rich_count:\n                queue.append(person)\n                \n        while queue:\n            person = queue.popleft()\n            ## pointer to the quietest person\n            quieter_person = answer[person]\n            \n            for poorer in graph[person]:\n                ## pointer to the quietest person richer than me\n                quieter_richer = answer[poorer]\n                ## on the answer we are storing the pointer to the quietest one. so for the next poorer we are going to store the pointer which contains the quietest\n                answer[poorer] = min(quieter_person, quieter_richer, key = lambda prsn : quiet[prsn])\n                richer_count[poorer] -= 1\n                if not richer_count[poorer]:\n                    queue.append(poorer)\n        return answer"}
{"prompt": "def peakIndexInMountainArray(self, arr: List[int]) -> int:\n        return (arr.index(max(arr)))"}
{"prompt": "def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        ans = prev = 0\n        for pp, ss in sorted(zip(position, speed), reverse=True): \n            tt = (target - pp)/ss # time to arrive at target \n            if prev < tt: \n                ans += 1\n                prev = tt\n        return ans"}
{"prompt": "# DFS\n    def kSimilarity(self, A: str, B: str) -> int:\n        N = len(A)\n        def dfs(A, B, pos):\n            if A == B:\n                return 0\n            \n            while A[pos] == B[pos]:\n                pos += 1\n                \n            minCnt = float('inf')\n            for i in range(pos + 1, N):\n                if B[i] == A[pos] and B[i] != A[i]:\n                    B[i], B[pos] = B[pos], B[i]\n                    tmp = dfs(A, B, pos + 1) + 1\n                    minCnt = min(tmp, minCnt)\n                    B[i], B[pos] = B[pos], B[i]\n                    \n            return minCnt\n        \n        return dfs(list(A), list(B), 0)\n\n    # DFS with memorization\n    def kSimilarity1(self, A: str, B: str) -> int:\n        N = len(A)\n        def dfs(A, B, pos):\n            sB = ''.join(B)\n            if sB in map:\n                return map[sB]\n            \n            if A == B:\n                return 0\n            \n            while A[pos] == B[pos]:\n                pos += 1\n                \n            minCnt = float('inf')\n            for i in range(pos + 1, N):\n                if B[i] == A[pos] and B[i] != A[i]:\n                    B[i], B[pos] = B[pos], B[i]\n                    tmp = dfs(A, B, pos + 1) + 1\n                    minCnt = min(tmp, minCnt)\n                    B[i], B[pos] = B[pos], B[i]\n                    \n            map[sB] = minCnt\n            return minCnt\n                    \n        map = collections.defaultdict()\n        return dfs(list(A), list(B), 0)\n    \n    # BFS\n    def kSimilarity2(self, A: str, B: str) -> int:\n        N = len(B)\n        q = collections.deque([B])\n        visited = set(B)\n        \n        cnt = 0\n        pos = 0\n        while q:\n            qSize = len(q)\n            \n            for _ in range(qSize):\n                cur = q.popleft()\n                if cur == A:\n                    return cnt\n                \n                pos = 0\n                while cur[pos] == A[pos]:\n                    pos += 1\n                \n                lCur = list(cur)\n                for i in range(pos + 1, N):\n                    if lCur[i] == A[pos] and lCur[i] != A[i]:\n                        lCur[i], lCur[pos] = lCur[pos], lCur[i]\n                        \n                        sCur = ''.join(lCur)\n                        if sCur not in visited:\n                            q.append(sCur)\n                            \n                        visited.add(sCur)\n                        lCur[i], lCur[pos] = lCur[pos], lCur[i]\n            cnt += 1\n            \n        return cnt"}
{"prompt": "def scoreOfParentheses(self, s: str) -> int:\n        stk = [0]   # temp value to help us\n\n        for char in s:\n            if char == '(':\n                stk.append(0)   # new parent: current sum = 0\n            else:\n                # An expression will be closed\n                # Find its value: either 1 for empty () or 2 * its sub-expressions\n                # we can calc both with a simple max()\n                value = max(2 * stk.pop(), 1)\n\n                # Add the expression sum to its parent current sum\n                #  Assume we have expression E that is (CHD)\n                # where C, H, D are valid-subexpressions with values 5, 10, 4\n                # then E is (5+10+4) = (19) = 38\n                # Every time we finish an expression, we add its value to its parent\n                # get the parent and update its sum with a finished sub-expression\n                stk[-1] += value\n\n        return stk.pop()\n\t\t```"}
{"prompt": "def mincostToHireWorkers(self, quality: List[int], wage: List[int], k: int) -> float:\n        ans, rsm = inf, 0\n        pq = [] # max-heap \n        for q, w in sorted(zip(quality, wage), key=lambda x: x[1]/x[0]): \n            rsm += q \n            heappush(pq, -q)\n            if len(pq) > k: rsm += heappop(pq)\n            if len(pq) == k: ans = min(ans, rsm * w/q)\n        return ans"}
{"prompt": "def mirrorReflection(self, p: int, q: int) -> int:\n\n        L = lcm(p,q)\n\n        if (L//q)%2 == 0:\n            return 2\n\n        return (L//p)%2"}
{"prompt": "def buddyStrings(self, s: str, goal: str) -> bool:\n\n        freq1=[0]*26\n        freq2=[0]*26\n        diff =0\n\n        if(len(s)!=len(goal)):\n            return False\n        for i in range(len(s)):\n            if(s[i]!=goal[i]):\n                diff+=1\n            freq1[ord(s[i])-ord('a')]+=1\n            freq2[ord(goal[i])-ord('a')]+=1\n        unique= True\n        for idx in range(len(freq1)):\n            if(freq1[idx]!=freq2[idx]):\n                return False\n            if(freq1[idx]>1):\n                unique = False\n        if(diff==2 or (unique==False and diff==0)):\n            return True"}
{"prompt": "def lemonadeChange(self, bills: List[int]) -> bool:\n        change5=0\n        change10=0\n        change20=0\n        for i in range(len(bills)):\n            if bills[i]==5:\n                change5+=1\n            elif bills[i]==10:\n                change10+=1\n                change5-=1\n            elif bills[i]==20:\n                if change10>0 :\n                    change5-=1\n                    change10-=1\n                else:\n                    change5-=3\n                change20+=1\n            if change5<0 or change10<0 or change20<0:\n                return False\n        return True"}
{"prompt": "def matrixScore(self, A: List[List[int]]) -> int:\n        m, n = len(A), len(A[0])\n        for i in range(m):\n            if A[i][0] == 0: \n                for j in range(n): A[i][j] ^= 1 \n        \n        for j in range(n): \n            cnt = sum(A[i][j] for i in range(m))\n            if cnt < m - cnt: \n                for i in range(m): A[i][j] ^= 1\n        \n        return sum(int(\"\".join(map(str, A[i])), 2) for i in range(m))"}
{"prompt": "def shortestSubarray(self, nums: List[int], k: int) -> int:\n        loc = {0: -1}\n        stack = [0] # increasing stack\n        ans, prefix = inf, 0\n        for i, x in enumerate(nums): \n            prefix += x\n            ii = bisect_right(stack, prefix - k)\n            if ii: ans = min(ans, i - loc[stack[ii-1]])\n            loc[prefix] = i\n            while stack and stack[-1] >= prefix: stack.pop()\n            stack.append(prefix)\n        return ans if ans < inf else -1"}
{"prompt": "def distanceK(self, root: TreeNode, target: TreeNode, k: int) -> List[int]:\n    \n        graph=defaultdict(list)\n        #create undirected graph\n        stack=[root]\n        while stack:\n            node=stack.pop()\n            if node==target:\n                targetVal=node.val\n            if node.left:\n                graph[node.val].append(node.left.val)\n                graph[node.left.val].append(node.val)\n                stack.append(node.left)\n            if node.right:\n                graph[node.val].append(node.right.val)\n                graph[node.right.val].append(node.val)\n                stack.append(node.right)\n        \n        #start BFS\n        q=deque([(targetVal,0)]) #startNode distance=0\n        seen=set()\n        seen.add(targetVal)\n        res=[]\n        while q:\n            node,depth=q.popleft()\n            if depth==k: \n                res.append(node)\n            if depth>k: break #no need to continue\n\n            for neigh in graph[node]:\n                if neigh not in seen:\n                    q.append((neigh,depth+1))\n                    seen.add(neigh)\n        return res"}
{"prompt": "def shortestPathAllKeys(self, grid: List[str]) -> int:\n        m, n = len(grid), len(grid[0])\n        \n        ii = jj = total = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == \"@\": ii, jj = i, j\n                elif grid[i][j].islower(): total += 1\n        \n        ans = 0\n        seen = {(ii, jj, 0)}\n        queue = [(ii, jj, 0)]\n        while queue: \n            newq = []\n            for i, j, keys in queue: \n                if keys == (1 << total) - 1: return ans \n                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \n                    if 0 <= ii < m and 0 <= jj < n and grid[ii][jj] != \"#\": \n                        kk = keys \n                        if grid[ii][jj].islower(): kk |= 1 << ord(grid[ii][jj]) - 97\n                        if (ii, jj, kk) in seen or grid[ii][jj].isupper() and not kk &amp; (1 << ord(grid[ii][jj])-65): continue \n                        newq.append((ii, jj, kk))\n                        seen.add((ii, jj, kk))\n            ans += 1\n            queue = newq\n        return -1"}
{"prompt": "def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:\n        \n        @lru_cache(None)\n        def fn(node):\n            \"\"\"Return height of tree rooted at node.\"\"\"\n            if not node: return 0\n            return 1 + max(fn(node.left), fn(node.right))\n        \n        node = root\n        while node: \n            left, right = fn(node.left), fn(node.right)\n            if left == right: return node\n            elif left > right: node = node.left\n            else: node = node.right"}
{"prompt": "def primePalindrome(self, N: int) -> int:\n        def isPrime(N):\n            return N > 1 and all(N % d for d in range(2, int(N**0.5)+1))\n        \n        # N must be a palindrome with odd number of digits.\n        # The return value will have odd number of digits too.\n        def nextPalindrome(N):\n            if N in [999, 99999, 9999999]:\n                return (N + 1) * 10 + 1\n            n = str(N // 10 ** (len(str(N))//2) + 1)\n            return int(n + n[-2::-1])\n        \n        if N <= 11: \n            while not isPrime(N):\n                N += 1\n            return N\n        \n        if (digits := len(str(N))) % 2 == 0:\n            N = 10 ** digits + 1\n        else:\n            n = str(N // 10 ** (len(str(N))//2))\n            if (p := int(n + n[-2::-1])) >= N:\n                N = p\n            else:\n                N = nextPalindrome(p)\n                \n        while not isPrime(N):\n            N = nextPalindrome(N)\n        return N"}
{"prompt": "def transpose(self, matrix: List[List[int]]) -> List[List[int]]:\n        m,n=len(matrix),len(matrix[0])\n        ans = [[None] * m for _ in range(n)]\n        for i in range(m):\n            for j in range(n):\n                ans[j][i]=matrix[i][j]\n        \n        return ans"}
{"prompt": "def binaryGap(self, n: int) -> int:\n        if(bin(n).count('1'))==1:\n            return 0\n        c=0\n        x=bin(n)[2:]\n        for i in range(len(x)):\n            if(x[i]=='1'):\n                j=i+1\n                while j<len(x):\n                    if(x[j]=='1'):\n                        c=max(j-i,c)\n                        break\n                    j+=1\n        return c"}
{"prompt": "def reorderedPowerOf2(self, n: int) -> bool:\n        for i in range(32):\n            if Counter(str(n))==Counter(str(2**i)):\n                return True\n        return False"}
{"prompt": "def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\n        sorted_a = sorted(A, reverse=True)                                         # descending order\n        sorted_b = sorted(enumerate(B), key=lambda x: (x[1], x[0]), reverse=True)  # descending order with original index\n        n, j = len(B), 0\n        ans = [-1] * n\n        for i, (ori_idx, val) in enumerate(sorted_b):                 # A greedily tries to cover value in B as large as possible\n            if sorted_a[j] > val: ans[ori_idx], j = sorted_a[j], j+1\n        for i in range(n):                                            # assign rest value in A to ans\n            if ans[i] == -1: ans[i], j = sorted_a[j], j+1\n        return ans"}
{"prompt": "# Here's the plan:\n                         # \n                         # 1) We only need to be concerned with two quantities: the dist traveled (pos)\n                         #    and the fuel acquired (fuel). We have to refuel before pos > fuel.\n                         # \n                         # 2) Because  we have an infinite capacity tank, we only have to plan where to acquire\n                         #    fuel before pos > fuel, and common sense says to stop at the station within range\n                         #    with the most fuel.\n                         # \n                         # 3) And that's a job for a heap. we heappush the stations that are within range of present\n                         #    fuel, and heappop the best choice if and when we need fuel.\n                         #  \n                         # 4) We are finished when a) we have acquired sufficient fuel such that fuel >= target \n                         #    (return # of fuelings), or b) fuel < target and the heap is empty (return -1).\n                       \n    def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:\n\n        fuel, heap, count = startFuel, [], 0            # <-- initialize some stuff\n        \n        stations.append([target, 0])                    # <-- this handles the \"stations = []\" test\n\n        while stations:\n            if fuel >= target: return count             # <-- 4)            \n\n            while stations and stations[0][0] <= fuel:  # <-- 3)\n                _, liters = stations.pop(0)\n                heappush(heap,-liters)\n\n            if not heap: return -1                      # <-- 4)\n            fuel-= heappop(heap)\n\n            count+= 1"}
{"prompt": "def __init__(self):\n        self.n = []\n        \n    def dfs(self, root):\n        if root:\n\t\t\t# checking if the node is leaf\n            if not root.left and not root.right:  \n\t\t\t\t# appends the leaf nodes to the list - self.n \n                self.n.append(root.val)  \n\t\t\t\t\n            self.dfs(root.left)\n            self.dfs(root.right)\n            \n    def leafSimilar(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:\n        self.dfs(root1)\n        a = self.n\n        self.n = []\n        self.dfs(root2)\n        \n        if a == self.n:\n            return True\n        else:\n            return False"}
{"prompt": "def lenLongestFibSubseq(self, arr: List[int]) -> int:\n        arrset=set(arr)\n        res=0\n        for i in range(len(arr)):\n            for j in range(i+1,len(arr)):\n                a,b,l=arr[i],arr[j],2\n                while(a+b in arrset):\n                    a,b,l=b,a+b,l+1\n                res=max(res,l)\n        return res if res>=3 else 0"}
{"prompt": "def robotSim(self, c: List[int], b: List[List[int]]) -> int:\n        x, y, d, b, M = 0, 0, 0, set([tuple(i) for i in b]), 0\n        for i in c:\n            if i < 0: d = (d + 2*i + 3)%4\n            else:\n                if d in [1,3]:\n                    for x in range(x, x+(i+1)*(2-d), 2-d):\n                        if (x+(2-d), y) in b: break\n                else:\n                    for y in range(y, y+(i+1)*(1-d), 1-d):\n                        if (x, y+(1-d)) in b: break\n            M = max(M, x**2 + y**2)\n        return M\n\t\t\n\t\t\n- Junaid Mansuri\n(LeetCode ID)@hotmail.com"}
{"prompt": "def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        k = 1\n        while True:\n            total_time = 0\n            for i in piles:\n                total_time += ceil(i / k)\n            if total_time > h:\n                k += 1\n            else:\n                return k"}
{"prompt": "def middleNode(self, head: ListNode) -> ListNode:\n        \n        slow, fast = head, head\n        \n        while fast:\n            \n            fast = fast.next\n            if fast:\n                fast = fast.next\n            else:\n                # fast has reached the end of linked list\n                # slow is on the middle point now\n                break\n        \n            slow = slow.next\n        \n        return slow"}
{"prompt": "def stoneGame(self, piles: List[int]) -> bool:\n        \n\t\t# Alex always win finally, no matter which step he takes first.\n        return True"}
{"prompt": "def nthMagicalNumber(self, n: int, a: int, b: int) -> int:\n\t    # inclusion-exclusion principle\n        ab = lcm(a,b)\n        lo, hi = 0, n*min(a, b)\n        while lo < hi: \n            mid = lo + hi >> 1\n            if mid//a + mid//b - mid//ab < n: lo = mid + 1\n            else: hi = mid \n        return lo % 1_000_000_007"}
{"prompt": "def profitableSchemes(self, n: int, minProfit: int, group: List[int], profit: List[int]) -> int:\n        # A[i][j][k] = # schemes using subset of first i crimes, using <= j people, with total profit >= k \n        A = [[[0 for k in range(minProfit + 1)] for j in range(n + 1)] for i in range(len(profit) + 1)]\n        # if using first 0 crimes, only one way, and that if minProfit <= 0\n        for j in range(n + 1):\n            A[0][j][0] = 1\n        for i in range(1, len(profit) + 1):\n            for j in range(n + 1):\n                for k in range(minProfit + 1):\n                    # we are here calculating A[j][j][k]\n                    # two cases, either we use i'th crime or not. \n                    # but if i'th crime requires more than j people, we con't use it\n                    if group[i-1] > j:\n                        A[i][j][k] = A[i-1][j][k]\n                    else:\n                        # if i'th crime gets profit greater than k, then we have no restriction \n                        # on the rest of the groups\n                        if profit[i-1] > k:\n                            A[i][j][k] = (A[i-1][j][k] + A[i-1][j-group[i-1]][0]) % (10**9 + 7)\n                        else:\n                            A[i][j][k] = (A[i-1][j][k] + A[i-1][j-group[i-1]][k-profit[i-1]]) % (10**9 + 7)\n        return A[len(profit)][n][minProfit]"}
{"prompt": "def decodeAtIndex(self, s: str, k: int) -> str:\n        lens = [0]\n        \n        for c in s:\n            if c.isalpha():\n                lens.append(lens[-1] + 1)\n            else:\n                lens.append(lens[-1] * int(c))\n                \n        for idx in range(len(s), 0, -1):\n            k %= lens[idx]\n            if k == 0 and s[idx - 1].isalpha():\n                return s[idx - 1]\n        \n        return"}
{"prompt": "def numRescueBoats(self, people: List[int], limit: int) -> int:\n        people.sort()\n        lo = 0\n        hi = len(people)-1\n        boats = 0\n        while lo <= hi:\n            if people[lo] + people[hi] <= limit:\n                lo += 1\n                hi -= 1\n            else:\n                hi -= 1\n            boats += 1\n        return boats"}
{"prompt": "def reachableNodes(self, edges: List[List[int]], maxMoves: int, n: int) -> int:\n        graph = collections.defaultdict(dict)\n        for s, e, n in edges: # n: subnodes in edge\n            graph[s][e] = n\n            graph[e][s] = n\n        \n        seen = set() # (start, end, step)\n        q = collections.deque()\n        for n in graph[0]:\n            q.append((0, n, 0))\n        \n        res = 1\n        move = maxMoves\n        while q:\n            for _ in range(len(q)):\n                start, end, step = q.popleft()\n                seen.add((start, end, step))\n                seen.add((end, start, graph[end][start]-step+1))\n                \n                if step == graph[start][end] + 1: #check if reached next node\n                    for n in graph[end]:\n                        if (end, n, 1) not in seen:\n                            q.append((end, n, 1))\n                            res += 1\n                            \n                else:\n                    if (start, end, step+1) not in seen and (end, start, graph[end][start]-step) not in seen:\n                        q.append((start, end, step+1))\n                        res += 1\n                    \n            move -= 1  \n            if move == 0:\n                break\n\n        return res"}
{"prompt": "def projectionArea(self, grid: List[List[int]]) -> int:\n        p = len(grid)\n        x, y, c = [], [0]*p, 0\n        for i in range(p):\n            x.append(0)\n            for j in range(p):\n                n = grid[i][j]\n                if n > 0:\n                    c += 1\n                if x[i] < n:\n                    x[i] = n\n                if y[j] < n:\n                    y[j] = n\n\n        return (sum(x)+sum(y)+c)"}
{"prompt": "def uncommonFromSentences(self, A: str, B: str) -> List[str]:\n        uncommon = []\n        \n        def find_uncommon(s , t):\n            ans = []\n            for i in s:\n                if(s.count(i) == 1 and i not in t):\n                    ans.append(i)\n            \n            return ans\n        \n        return find_uncommon(A.split() , B.split()) + find_uncommon(B.split() , A.split())"}
{"prompt": "def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\n        ans = []\n        left, right = cStart, cStart+1\n        top, bottom = rStart, rStart+1\n        current = 1\n        move = 0\n        while current <= rows*cols:\n            # fill top\n            for i in range(left+move, right+1):\n                if self.inbound(top, i, rows, cols):\n                    ans.append([top, i])\n                    current += 1\n            left -= 1\n            # fill right\n            for i in range(top+1, bottom+1):\n                if self.inbound(i, right, rows, cols):\n                    ans.append([i, right])\n                    current += 1\n            top -= 1\n            # fill bottom\n            for i in range(right-1, left-1, -1):\n                if self.inbound(bottom, i, rows, cols):\n                    ans.append([bottom, i])\n                    current += 1\n            right += 1\n            # fill left\n            for i in range(bottom-1, top-1, -1):\n                if self.inbound(i, left, rows, cols):\n                    ans.append([i, left])\n                    current += 1\n            bottom += 1\n            move = 1\n        return ans\n    def inbound(self, r, c, rows, cols):\n        return 0<=r<rows and 0<=c<cols"}
{"prompt": "def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        dislike = [[] for _ in range(n)]\n        for a, b in dislikes:\n            dislike[a-1].append(b-1)\n            dislike[b-1].append(a-1)\n\n        groups = [0] * n\n        for p in range(n):\n            if groups[p] == 0:\n                groups[p] = 1\n                q = deque([p])\n                while q: # bfs\n                    a = q.pop()\n                    for b in dislike[a]:\n                        if groups[b] == 0:\n                            groups[b] = 1 if groups[a] == 2 else 2\n                            q.appendleft(b)\n                        elif groups[a] == groups[b]:\n                            return False\n        return True"}
{"prompt": "def superEggDrop(self, k: int, n: int) -> int:\n        \n        @cache\n        def fn(n, k):\n            \"\"\"Return min moves given n floors and k eggs.\"\"\"\n            if k == 1: return n\n            if n == 0: return 0 \n            lo, hi = 1, n + 1\n            while lo < hi: \n                mid = lo + hi >> 1\n                if fn(mid-1, k-1) < fn(n-mid, k): lo = mid + 1\n                else: hi = mid \n            return 1 + max(fn(lo-1, k-1), fn(n-lo, k))\n        \n        return fn(n, k)"}
{"prompt": "def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:\n        difference = (sum(A) - sum(B)) / 2\n        A = set(A)\n        for candy in set(B):\n            if difference + candy in A:\n                return [difference + candy, candy]"}
{"prompt": "def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\n        mp = {x: i for i, x in enumerate(inorder)} # relative position \n\t\troot = None\n\t    stack = []\n        for x in preorder: \n            if not root: root = node = TreeNode(x)\n            elif mp[x] < mp[stack[-1].val]: stack[-1].left = node = TreeNode(x)\n            else: \n                while stack and mp[stack[-1].val] < mp[x]: node = stack.pop() # retrace \n                node.right = node = TreeNode(x)\n            stack.append(node)\n        return root"}
{"prompt": "def findAndReplacePattern(self, words: List[str], pattern: str) -> List[str]:\n        \n        def helper( s ):\n            \n            # dictionary\n            # key   : character\n            # value : serial number in string type\n            char_index_dict = dict()\n            \n            # given each unique character a serial number\n            for character in s:\n                \n                if character not in char_index_dict:\n                    char_index_dict[character] = str( len(char_index_dict) )\n            \n            \n            # gererate corresponding pattern string\n            return ''.join( map(char_index_dict.get, s) )\n\n        #--------------------------------------------------------    \n            \n        pattern_string = helper(pattern)\n        \n        return [ word for word in words if helper(word) == pattern_string ]"}
{"prompt": "def sumSubseqWidths(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        nums.sort()\n\n        dp = [0] * n\n\n        p = 2\n        temp = nums[0]\n\n        for i in range(1, n):\n            dp[i] = ((dp[i-1] + ((p-1)*nums[i])%MOD)%MOD - temp)%MOD\n            p = (2*p)%MOD\n            temp = ((2*temp)%MOD + nums[i])%MOD\n        \n        return dp[n-1]"}
{"prompt": "def surfaceArea(self, grid: List[List[int]]) -> int:\n        \n        l = len(grid)\n        area=0\n        for row in range(l):\n            for col in range(l):\n                if grid[row][col]:\n                    area += (grid[row][col]*4) +2 #surface area of each block if blocks werent connected\n                if row: #row>0\n                    area -= min(grid[row][col],grid[row-1][col])*2 #subtracting as area is common among two blocks\n                if col: #col>0\n                    area -= min(grid[row][col],grid[row][col-1])*2 #subtracting as area is common among two blocks\n        return area"}
{"prompt": "def numSpecialEquivGroups(self, A: List[str]) -> int:\n        \n        signature = set()\n        \n        # Use pair of sorted even substring and odd substring as unique key\n        \n        for idx, s in enumerate(A):\n            signature.add( ''.join( sorted( s[::2] ) ) + ''.join( sorted( s[1::2] ) )  )\n        \n        return len( signature )"}
{"prompt": "def allPossibleFBT(self, N: int) -> List[TreeNode]:\n\t\t# Any full binary trees should contain odd number of nodes\n\t\t# therefore, if N is even, return 0\n\t\tif N % 2 == 0:\n\t\t\treturn []\n\t\t# for all odd n that are less than N, store all FBTs\n        trees_all = collections.defaultdict(list)\n\t\t\n\t\t#when there is one node, only one tree is available\n        trees_all[1] = [TreeNode(0)]\n        for n in range(3, N+1, 2):\n            for k in range(1, n, 2):\n                # trees with k nodes on the left\n                # trees with n - k - 1 nodes on the right\n\t\t\t\t# consider all potential pairs\n                for tree1, tree2 in itertools.product(trees_all[k],\n\t\t\t\t\t\t\t\t\t\t\t\t\t  trees_all[n-k-1]):\n                    tree = TreeNode(0)\n                    tree.left = tree1\n                    tree.right = tree2\n                    trees_all[n].append(tree)\n                    \n        return trees_all[N]"}
{"prompt": "def isMonotonic(self, A: List[int]) -> bool:\n        if A[-1] < A[0]: \n            A = A[::-1]\n        \n        for i in range(1, len(A)):\n            if A[i] < A[i-1]:\n                return False\n        return True"}
{"prompt": "def increasingBST(self, root: TreeNode) -> TreeNode:\n        \n        prev_node = None\n        \n        def helper( node: TreeNode):\n                           \n            if node.right:\n                helper( node.right )\n\n            # prev_novde always points to next larger element for current node\n            nonlocal prev_node\n\n            # update right link points to next larger element\n            node.right = prev_node\n\n            # break the left link of next larger element\n            if prev_node:\n                prev_node.left = None\n\n            # update previous node as current node\n            prev_node = node\n\n            if node.left:\n                helper( node.left)\n                \n        # ---------------------------------------\n        helper( root )\n        \n        return prev_node"}
{"prompt": "def subarrayBitwiseORs(self, arr: List[int]) -> int:\n        \n        \n        ans=set(arr)\n        \n        # each element is a subarry\n        \n        \n        one = set()\n        \n        # to get the ans for the subarray of  size >1\n        # starting from 0th element to the ending element\n        \n        \n        one.add(arr[0])\n        \n        for i in  range(1,len(arr)):\n            \n            two=set()\n            \n            for j in one:\n                \n                two.add(j |  arr[i])\n                \n                # subarray from the element in one set to the current ele(i th one)\n                \n                ans.add(j| arr[i])\n                \n            \n            two.add(arr[i])\n            \n            # adding curr element to set two so that from next iteration we can take sub array starting from curr element \n            \n            one = two\n            \n        return len(ans)"}
{"prompt": "def orderlyQueue(self, s: str, k: int) -> str:\n        if k > 1:\n            return \"\".join(sorted(s))\n        \n        res = s\n        for i in range(0,len(s)):\n            s = s[1:] + s[0]\n            res = min(res,s)\n                \n        return res"}
{"prompt": "def atMostNGivenDigitSet(self, digits: List[str], n: int) -> int:\n        digits = set(int(d) for d in digits)\n        dLen = len(digits)\n        nStr = str(n)\n        nLen = len(nStr)\n        \n        res = sum(dLen**i for i in range(1, nLen)) # lower dimensions\n        \n        def helper(firstDigit, slots):\n            if slots == 1:\n                return sum(d <= firstDigit for d in digits)\n\n            return sum(d < firstDigit for d in digits) * dLen**(slots - 1)\n        \n        for i in range(nLen):\n            curDigit = int(nStr[i])\n\n            res += helper(curDigit, nLen - i)\n            \n            if not curDigit in digits: # makes no sense to continue\n                break\n    \n        return res"}
{"prompt": "def numPermsDISequence(self, s: str) -> int:\n        \n        @cache \n        def fn(i, x): \n            \"\"\"Return number of valid permutation given x numbers smaller than previous one.\"\"\"\n            if i == len(s): return 1 \n            if s[i] == \"D\": \n                if x == 0: return 0 # cannot decrease\n                return fn(i, x-1) + fn(i+1, x-1)\n            else: \n                if x == len(s)-i: return 0 # cannot increase \n                return fn(i, x+1) + fn(i+1, x)\n        \n        return sum(fn(0, x) for x in range(len(s)+1)) % 1_000_000_007"}
{"prompt": "def totalFruit(self, fruits: List[int]) -> int:\n        fruit_types = Counter()\n        distinct = 0\n        max_fruits = 0\n        \n        left = right = 0\n        while right < len(fruits):\n            # check if it is a new fruit, and update the counter\n            if fruit_types[fruits[right]] == 0:\n                distinct += 1\n            fruit_types[fruits[right]] += 1\n            \n            # too many different fruits, so start shrinking window\n            while distinct > 2:\n                fruit_types[fruits[left]] -= 1\n                if fruit_types[fruits[left]] == 0:\n                    distinct -= 1\n                left += 1\n            \n            # set max_fruits to the max window size\n            max_fruits = max(max_fruits, right-left+1)\n            right += 1\n        \n        return max_fruits"}
{"prompt": "def sortArrayByParity(self, A: List[int]) -> List[int]:\n        i, j = 0, len(A) - 1\n        while i < j:\n        \tif A[i] % 2 == 1 and A[j] % 2 == 0: A[i], A[j] = A[j], A[i]\n        \ti, j = i + 1 - A[i] % 2, j - A[j] % 2\n        return A"}
{"prompt": "nums = []\n    for i in range(1, 10**5):\n        odd = int(str(i)+str(i)[:-1][::-1])**2\n        even = int(str(i)+str(i)[::-1])**2\n            \n        if str(odd) == str(odd)[::-1]:\n            nums.append(odd)\n                \n        if str(even) == str(even)[::-1]:\n            nums.append(even)\n        \n    nums = sorted(list(set(nums)))\n    def superpalindromesInRange(self, left: str, right: str) -> int:\n        output = []\n        for n in self.nums:\n            if int(left) <= n <= int(right):\n                output.append(n)\n                \n        return len(output)"}
{"prompt": "def sumSubarrayMins(self, arr: List[int]) -> int:\n        M = 10 ** 9 + 7\n\n        # right bound for current number as minimum\n\t\tq = []\n        n = len(arr)\n        right = [n-1] * n        \n        \n        for i in range(n):\n            # must put the equal sign to one of the bound (left or right) for duplicate nums (e.g. [71, 55, 82, 55])\n            while q and arr[i] <= arr[q[-1]]:\n                right[q.pop()] = i - 1\n            q.append(i)\n\n        # left bound for current number as minimum\n        q = []\n        left = [0] * n\n        for i in reversed(range(n)):\n            while q and arr[i] < arr[q[-1]]:\n                left[q.pop()] = i + 1\n            q.append(i)\n        \n        # calculate sum for each number\n        ans = 0\n        for i in range(n):\n            l, r =  abs(i - left[i]), abs(i - right[i])\n            # for example:  xx1xxx\n            # left take 0, 1, 2 numbers (3 combs) and right take 0, 1, 2, 3 numbers (4 combs)\n            covered = (l + 1) * (r + 1)\n            ans = (ans + arr[i] * covered) % M\n        \n        return ans"}
{"prompt": "def smallestRangeI(self, A: List[int], K: int) -> int:\n\n        M, m = max(A), min(A)\n        diff, extension = M - m, 2*K\n        \n        if diff <= extension:\n            return 0\n        \n        else:\n            return diff - extension"}
{"prompt": "def snakesAndLadders(self, board: List[List[int]]) -> int:\n        \n        # creating a borad map to loop-up the square value\n        board_map = {}\n        i = 1\n        b_rev = board[::-1]\n        for d, r in enumerate(b_rev):\n\t\t\t# reverse for even rows - here d is taken as direction \n            if d%2 != 0: r = r[::-1] \n            for s in r:\n                board_map[i] = s\n                i += 1\n        \n        # BFS Algorithm\n        q = [(1, 0)] # (curr, moves)\n        v = set()\n        goal = len(board) * len(board) # end square\n        \n        while q:\n            curr, moves = q.pop(0)\n            # win situation\n            if curr == goal: return moves\n            # BFS on next 6 places (rolling a die)\n            for i in range(1, 7):\n                # skip square outside board\n                if curr+i > goal: continue\n                # get value from mapping\n                next_pos = curr+i if board_map[curr+i] == -1 else board_map[curr+i]\n                if next_pos not in v:\n                    v.add(next_pos)\n                    q.append((next_pos, moves+1))\n        \n        return -1"}
{"prompt": "def smallestRangeII(self, A: List[int], K: int) -> int:\n        A.sort()\n        res = A[-1] - A[0]\n        \n        for indx in range(0, len(A) - 1):\n            # assuming that A[indx] is the max val\n            min_val = min(A[0] + K, A[indx + 1] - K)\n            max_val = max(A[indx] + K, A[-1] - K)\n            res = min(res, max_val - min_val)\n\n        return res"}
{"prompt": "def sortArray(self, N: List[int]) -> List[int]:\n        L = len(N)\n        return [N.pop(min(range(L-i), key = lambda x: N[x])) for i in range(L)]"}
{"prompt": "def catMouseGame(self, graph: List[List[int]]) -> int:\n        n = len(graph)\n        \n        @cache\n        def fn(i, m, c): \n            \"\"\"Return \"\"\"\n            if i == 2*n: return 0 # tie \n            if m == 0: return 1 # mouse wins\n            if m == c: return 2 # cat wins \n            if i&amp;1: # cat's turn \n                tie = 0 \n                for cc in graph[c]: \n                    if cc != 0: \n                        x = fn(i+1, m, cc)\n                        if x == 2: return 2 \n                        if x == 0: tie = 1\n                if tie: return 0 \n                return 1\n            else: # mouse's turn \n                tie = 0 \n                for mm in graph[m]: \n                    x = fn(i+1, mm, c)\n                    if x == 1: return 1 \n                    if x == 0: tie = 1\n                if tie: return 0\n                return 2 \n        \n        return fn(0, 1, 2)"}
{"prompt": "def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        x = Counter(deck).values()\n        return reduce(gcd, x) > 1"}
{"prompt": "def partitionDisjoint(self, nums: List[int]) -> int:\n        \"\"\"\n        Intuition(logic) is to find two maximums.\n        One maximum is for left array and other maximum is for right array.\n        \n        But the condition is that, the right maximum should be such that, \n        no element after that right maximum should be less than the left maximum. \n        \n        If there is any element after right maximum which is less than left maximum,\n        that means there is another right maximum possible and therefore in that case assign\n        left maximum to right maximum and keep searching the array for correct right\n        maximum till the end.\n        \"\"\"\n        #start with both left maximum and right maximum with first element.\n        left_max = right_max = nums[0]\n        # our current index\n        partition_ind = 0\n        # Iterate from 1 to end of the array\n        for i in range(1,len(nums)):\n            #update right_max always after comparing with each nums\n            #in order to find our correct right maximum\n            right_max = max(nums[i], right_max)\n            \"\"\"\n\t\t\tif current element is less than left maximum, that means this \n            element must belong to the left subarray. \n              * so our partition index will be updated to current index \n              * and left maximum will be updated to right maximum. \n             Why left maximum updated to right maximum ?\n              Because when we find any element less than left_maximum, that \n              means the right maximum which we had till now is not valid and we have\n              to find the valid right maximum again while iterating through the end of the loop.\n\t\t\t\"\"\"\n            if nums[i] < left_max:\n                left_max = right_max\n                partition_ind = i\n        \n        return partition_ind+1"}
{"prompt": "def wordSubsets(self, words1: List[str], words2: List[str]) -> List[str]:\n        result = []\n        tempDict = Counter()\n        for w in words2:\n            tempDict |= Counter(w)\n        print(tempDict)\n        \n        for w in words1:\n            if not tempDict - Counter(w):\n                result.append(w)\n        return result"}
{"prompt": "def reverseOnlyLetters(self, S: str) -> str:\n    \tS = list(S)\n    \tc = [c for c in S if c.isalpha()]\n    \tfor i in range(-1,-len(S)-1,-1):\n    \t\tif S[i].isalpha(): S[i] = c.pop(0)\n    \treturn \"\".join(S)\n\t\t\n\t\t\n- Python 3\n- Junaid Mansuri"}
{"prompt": "def maxSubarraySumCircular(self, A: List[int]) -> int:\n        \n        array_sum = 0\n        \n        local_min_sum, global_min_sum = 0, float('inf')\n        local_max_sum, global_max_sum = 0, float('-inf')\n        \n        for number in A:\n            \n            local_min_sum = min( local_min_sum + number, number )\n            global_min_sum = min( global_min_sum, local_min_sum )\n            \n            local_max_sum = max( local_max_sum + number, number )\n            global_max_sum = max( global_max_sum, local_max_sum )\n            \n            array_sum += number\n        \n        \n        \n        # global_max_sum denotes the maximum subarray sum without crossing boundary\n        # arry_sum - global_min_sum denotes the maximum subarray sum with crossing boundary\n        \n        if global_max_sum > 0:\n            return max( array_sum - global_min_sum, global_max_sum )\n        else:\n            # corner case handle for all number are negative\n            return global_max_sum"}
{"prompt": "def numMusicPlaylists(self, n: int, goal: int, k: int) -> int:\n        \n        @cache\n        def fn(i, x): \n            \"\"\"Return number starting from ith position with x songs already appeared.\"\"\"\n            if i == goal: return x == n \n            ans = 0 \n            if x < n: ans += (n-x) * fn(i+1, x+1) # a new song\n            if k < x: ans += (x-k) * fn(i+1, x) # an old song\n            return ans % 1_000_000_007\n        \n        return fn(0, 0)"}
{"prompt": "def minAddToMakeValid(self, s: str) -> int:\n        count = 0\n        \n        x = y = 0\n        \n        for i in s:\n            if(i == '('):\n                x += 1\n            else:\n                x -= 1\n            \n            if(x < 0):\n                count += 1\n                x = 0\n            if(y < 0):\n                count += 1\n                y = 0\n        \n        return count + x + y"}
{"prompt": "def sortArrayByParityII(self, nums: List[int]) -> List[int]:\n    \n    odd,even = [],[]\n    for n in nums:\n        if n%2: odd.append(n)\n        else: even.append(n)\n    \n    o,e = 0,0\n    for i in range(len(nums)):\n        if i%2==0:\n            nums[i]=even[e]\n            e+=1\n        else:\n            nums[i]=odd[o]\n            o+=1\n    \n    return nums"}
{"prompt": "def threeSumMulti(self, arr: List[int], target: int) -> int:\n        arr.sort()\n\t\t# the rest of the code here"}
{"prompt": "def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        initial = set(initial)\n        \n        def dfs(i):\n            nodes.add(i)\n            for j, conn in enumerate(graph[i]):\n                if conn and j not in nodes:\n                    dfs(j)\n        \n        maxRemoval, minNode = -1, float('inf')\n        for node in initial:\n            nodes = set()\n            dfs(node)\n            \n            if nodes &amp; initial == {node}:\n                l = len(nodes)\n                if l > maxRemoval or (l == maxRemoval and node < minNode):\n                    minNode = node\n                    maxRemoval = l\n                    \n        return minNode if maxRemoval > -1 else min(initial)"}
{"prompt": "def isLongPressedName(self, name: str, typed: str) -> bool:\n        ni = 0       # index of name\n        ti = 0       # index of typed\n        while ni <= len(name) and ti < len(typed):\n            if ni < len(name) and typed[ti] == name[ni]:\n                ti += 1\n                ni += 1\n            elif typed[ti] == name[ni-1] and ni != 0:\n                ti += 1\n            else:\n                return False\n            \n        return ni == len(name) and ti == len(typed)"}
{"prompt": "def minFlipsMonoIncr(self, s: str) -> int:\n        \"\"\"\n                     0 0 1 1 0\n        oneCount:    0 0 1 2 2\n        zeroCount:   1 1 0 0 1\n        flipCount:   0 0 0 0 1\n        \n        \n                     0 1 0 1 0\n        oneCount:    0 1 1 2 2\n        zeroCount:   1 0 1 1 2\n        flipCount:   0 0 1 1 2\n        \n                     0 0 0 1 1 0 0 0\n        oneCount:    0 0 0 1 2 2 2 2\n        zeroCount:   1 1 1 0 0 1 2 3\n        flipCount:   0 0 0 0 0 1 2 2\n        \"\"\"\n        oneCount = 0\n        zeroCount = 0\n        flipCount = 0\n        for c in s:\n            if c == \"1\":\n                oneCount += 1\n            if c == \"0\":\n                zeroCount += 1\n            flipCount = min(zeroCount,oneCount)\n            zeroCount = flipCount\n        return flipCount"}
{"prompt": "def threeEqualParts(self, arr: List[int]) -> List[int]:\n        # count number of ones\n        ones = sum(arr)\n        if ones % 3 != 0:\n            return [-1, -1]\n        elif ones == 0:  # special case: all zeros\n            return [0, 2]\n        \n        # find the start index of each group of ones\n        c = 0\n        starts = []\n        for i, d in enumerate(arr):\n            if d == 1:\n                if c % (ones // 3) == 0:\n                    starts.append(i)\n                c += 1\n\n        # scan the groups in parallel to compare digits\n        i, j, k = starts\n        while k < len(arr):  # note that the last/rightmost group must include all digits till the end\n            if arr[i] == arr[j] == arr[k]:\n                i += 1\n                j += 1\n                k += 1\n            else:\n                return [-1, -1]\n        return [i-1, j]"}
{"prompt": "# the key observation for me is the fact that we don't need to\n    # really delete the initial in the graph. We can simply ignore\n    # the deleted initial while we are doing BFS. So basically we\n    # do BFS with each deleted value on initial, and we get the\n    # minimal count of the connected graph. Note if two deleted\n    # values give same count of connected graph, then we choose\n    # smaller value. that's why I used a tuple, (BFS(a), a) this \n    # will first compare BFS(a), if they are equal then it compares\n    # a.\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        def BFS(delval):\n            seen, lst = set(), list(initial)\n            while lst:\n                node = lst.pop()\n                if node == delval or node in seen: continue\n                seen.add(node)\n                lst += [i for i, val in enumerate(graph[node]) if val]\n            return len(seen)\n        return min(initial, key=lambda a: (BFS(a), a))"}
{"prompt": "def numUniqueEmails(self, emails: List[str]) -> int:\n        def parse(email):\n            local, domain = email.split('@')\n            local = local.split('+')[0].replace('.',\"\")\n            return f\"{local}@{domain}\"\n        \n        return len(set(map(parse, emails)))"}
{"prompt": "def numSubarraysWithSum(self, A: List[int], S: int) -> int:\n        ans = prefix = 0\n        seen = {0: 1}\n        for x in A:\n            prefix += x\n            ans += seen.get(prefix - S, 0)\n            seen[prefix] = 1 + seen.get(prefix, 0)\n        return ans"}
{"prompt": "def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        \n        r=len(matrix)\n        c=len(matrix[0])\n        \n        for i in range(1,r):\n            for j in range(c):\n                \n                if j==0:\n                    matrix[i][j]+=min(matrix[i-1][j],matrix[i-1][j+1])\n                    \n                elif j==c-1:\n                    matrix[i][j]+=min(matrix[i-1][j],matrix[i-1][j-1])\n                    \n                else:\n                    matrix[i][j]+=min(matrix[i-1][j],matrix[i-1][j-1],matrix[i-1][j+1])\n                    \n        \n        return min(matrix[r-1])"}
{"prompt": "def recurse(self, nums):\n        if len(nums) <= 2: return nums\n        return self.recurse(nums[::2]) + self.recurse(nums[1::2])\n    \n    def beautifulArray(self, n: int) -> List[int]:\n        return self.recurse([i for i in range(1, n+1)])"}
{"prompt": "def shortestBridge(self, A: List[List[int]]) -> int:\n        m, n = len(A), len(A[0])\n        i, j = next((i, j) for i in range(m) for j in range(n) if A[i][j])\n        \n        # dfs \n        stack = [(i, j)]\n        seen = set(stack)\n        while stack: \n            i, j = stack.pop()\n            seen.add((i, j)) # mark as visited \n            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \n                if 0 <= ii < m and 0 <= jj < n and A[ii][jj] and (ii, jj) not in seen: \n                    stack.append((ii, jj))\n                    seen.add((ii, jj))\n        \n        # bfs \n        ans = 0\n        queue = list(seen)\n        while queue:\n            newq = []\n            for i, j in queue: \n                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \n                    if 0 <= ii < m and 0 <= jj < n and (ii, jj) not in seen: \n                        if A[ii][jj] == 1: return ans \n                        newq.append((ii, jj))\n                        seen.add((ii, jj))\n            queue = newq\n            ans += 1"}
{"prompt": "def knightDialer(self, n: int) -> int:\n        arr = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n        \n        \n        for _ in range(n-1):\n            dp = [0 for _ in range(10)]\n            dp[0] = arr[5] + arr[7]\n            dp[1] = arr[6] + arr[8]\n            dp[2] = arr[3] + arr[7]\n            dp[3] = arr[2] + arr[8] + arr[9]\n            dp[4] = 0\n            dp[5] = arr[0] + arr[6] + arr[9]\n            dp[6] = arr[1] + arr[5]\n            dp[7] = arr[0] + arr[2]\n            dp[8] = arr[1] + arr[3]\n            dp[9] = arr[3] + arr[5]\n            arr = dp\n        return sum(arr) % (10**9+7)"}
{"prompt": "def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        N,M = len(target),len(stamp)\n        move = 0\n        maxmove = 10*N\n        ans = []\n        def check(string):\n            for i in range(M):\n                if string[i] == stamp[i] or string[i] == '?':\n                    continue\n                else:\n                    return False\n            return True\n        \n        while move < maxmove:\n            premove = move\n            for i in range(N-M+1):\n                if check(target[i:i+M]):\n                    move += 1\n                    ans.append(i)\n                    target = target[:i] + \"?\"*M + target[i+M:]\n                    if target == \"?\"*N : return ans[::-1]\n            if premove == move:return []\n        return []"}
{"prompt": "def reorderLogFiles(self, logs: List[str]) -> List[str]:\n        l = []\n        d = []\n        for i in logs:\n            if i.split()[1].isdigit():\n                d.append(i)\n            else:\n                l.append(i)\n        l.sort(key = lambda x : x.split()[0])\n        l.sort(key = lambda x : x.split()[1:])\n        return l + d"}
{"prompt": "def rangeSumBST(self, root: Optional[TreeNode], lo: int, hi: int) -> int:\n        res = 0\n        \n        q = deque([root])\n        while q:\n            c = q.popleft()\n            v, l, r = c.val, c.left, c.right\n\n            if lo <= v and v <= hi:\n                res += v\n                \n            if l and (lo < v or v > hi):\n                q.append(l)\n                \n            if r and (lo > v or v < hi):\n                q.append(r)\n            \n        return res"}
{"prompt": "def minAreaRect(self, points: List[List[int]]) -> int:\n        x_axis = defaultdict(dict)\n        y_axis = defaultdict(dict)\n        d = {}\n        points.sort()\n        \n        ans = float('inf')\n        \n        for point in points:\n            x_axis[point[0]][point[1]] = True\n            y_axis[point[1]][point[0]] = True\n            d[(point[0],point[1])] = True\n\n        for point in points:\n            x1 = point[0]\n            y1 = point[1]\n            for y2 in x_axis[x1]:\n                if y2 == y1:continue\n                for x2 in y_axis[y2]:\n                    if x2 == x1:continue\n                    if (x2,y1) in  d:\n                        tmp = abs(x2-x1) * abs(y2-y1)\n                        if tmp < ans : ans = tmp\n        return ans if ans!=float('inf') else 0"}
{"prompt": "def distinctSubseqII(self, s: str) -> int:\n        n = len(s)\n        MOD = 1000000007\n        dp = {}\n        \n        def recursion(string,index):\n            ans = 1 if index > 0 else 0\n            used = {}\n            for idx in range(index,n):\n                if s[idx] in used:continue\n                used[s[idx]] = True\n                ans += recursion(string + s[idx] , idx + 1)\n            \n            return ans\n        \n        res = recursion(\"\",0)%MOD\n        return res"}
{"prompt": "def validMountainArray(self, A: List[int]) -> bool:\n        if len(A)<3:return False\n        l=len(A)\n        i,j=0,l-1\n        while i<j and A[i]<A[i+1]:\n            i+=1\n        while j>0 and A[j]<A[j-1]:\n            j-=1\n        if i==j and j!=l-1 and i!=0:return True\n        return False"}
{"prompt": "def diStringMatch(self, s: str) -> List[int]:\n        ans = []\n        a , b = 0 , len(s)\n        \n        for i in s:\n            if(i == 'I'):\n                ans.append(a)\n                a += 1\n            else:\n                ans.append(b)\n                b -= 1\n        \n        if(s[-1] == 'D'):\n            ans.append(a)\n        else:\n            ans.append(b)\n                       \n        return ans"}
{"prompt": "def shortestSuperstring(self, words: List[str]) -> str:\n        n = len(words)\n        graph = [[0]*n for _ in range(n)] # graph as adjacency matrix \n        \n        for i in range(n):\n            for j in range(n): \n                if i != j: \n                    for k in range(len(words[j])): \n                        if words[i].endswith(words[j][:k]): \n                            graph[i][j] = len(words[j]) - k \n                            \n        @cache\n        def fn(prev, mask): \n            \"\"\"Return length of shortest superstring &amp; current choice of word.\"\"\"\n            if mask == 0: return 0, None\n            vv, kk = inf, None\n            for k in range(n): \n                if mask &amp; 1<<k: \n                    v, _ = fn(k, mask ^ 1<<k)\n                    offset = len(words[k]) if prev == -1 else graph[prev][k]\n                    if v + offset < vv: vv, kk = v + offset, k\n            return vv, kk\n        \n        ans = []\n        prev = -1 \n        mask = (1<<n) - 1\n        while mask: \n            _, k = fn(prev, mask)\n            if ans: ans.append(words[k][-graph[prev][k]:])\n            else: ans.append(words[k])\n            prev = k\n            mask ^= 1<<k \n        return \"\".join(ans)"}
{"prompt": "def minDeletionSize(self, A: List[str]) -> int:\n        zipped=list(map(list,zip(*A)))\n        count=0\n        for item in zipped:\n            if item!=sorted(item):\n                count+=1\n        return count"}
{"prompt": "def minIncrementForUnique(self, nums: List[int]) -> int:\n        nums.sort()\n        n = len(nums)\n        ans = 0\n        for i in range(1,n):\n            if nums[i] <= nums[i-1]:\n                # this is the case for making item unique\n                diff = nums[i-1] + 1 - nums[i]\n                ans += diff\n                nums[i] = nums[i-1] + 1\n        return ans"}
{"prompt": "def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\n        stack = []\n        for i in pushed:\n            stack.append(i)\n            while stack and popped and stack[-1] == popped[0]:\n                stack.pop()\n                popped.pop(0)\n        return not stack"}
{"prompt": "def removeStones(self, stones: List[List[int]]) -> int:\n\t\t\t\n\t\t\tdef remove_point(a,b):                           # Function to remove connected points from the ongoing graph. \n\t\t\t\tpoints.discard((a,b))\n\t\t\t\tfor y in x_dic[a]:\n\t\t\t\t\tif (a,y) in points:\n\t\t\t\t\t\tremove_point(a,y)\n\n\t\t\t\tfor x in y_dic[b]:\n\t\t\t\t\tif (x,b) in points:\n\t\t\t\t\t\tremove_point(x,b)\n\n\t\t\tx_dic = defaultdict(list)\n\t\t\ty_dic = defaultdict(list)\n\t\t\tpoints= {(i,j) for i,j in stones}\n\t\t\t\n\t\t\tfor i,j in stones:                                # Construction of graph by x_coordinates and y_coordinates.\n\t\t\t\tx_dic[i].append(j)\n\t\t\t\ty_dic[j].append(i)\n\n\t\t\tcnt = 0\n\t\t\tfor a,b in stones:                                # counting of distinct connected graph.\n\t\t\t\tif (a,b) in points:\n\t\t\t\t\tremove_point(a,b)\n\t\t\t\t\tcnt+=1\n\n\t\t\treturn len(stones)-cnt"}
{"prompt": "def bagOfTokensScore(self, tokens: List[int], power: int) -> int:\n        score=0\n        tokens.sort()\n        i=0\n        j=len(tokens)-1\n        mx=0\n        while i<=j:\n            if tokens[i]<=power:\n                power-=tokens[i]\n                score+=1\n                i+=1\n                mx=max(mx,score)\n            elif score>0:\n                score-=1\n                power+=tokens[j]\n                j-=1\n            else:\n                break\n        return mx"}
{"prompt": "def largestTimeFromDigits(self, A: List[int]) -> str:\n        hh = mm = -1\n        for x in set(permutations(A, 4)): \n            h = 10*x[0] + x[1]\n            m = 10*x[2] + x[3]\n            if h < 24 and m < 60 and 60*h + m > 60*hh + mm: hh, mm = h, m\n        return f\"{hh:02}:{mm:02}\" if hh >= 0 else \"\""}
{"prompt": "def deckRevealedIncreasing(self, D: List[int]) -> List[int]:\n    \tL, Q, _ = len(D)-1, collections.deque(), D.sort()\n    \tfor _ in range(L): Q.appendleft(D.pop()), Q.appendleft(Q.pop())\n    \treturn D + list(Q)\n\t\t\n\t\t\n- Junaid Mansuri\n(LeetCode ID)@hotmail.com"}
{"prompt": "def flipEquiv(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:\n        if not root1 or not root2:\n            return not root1 and not root2\n        if root1.val != root2.val: return False\n        return (self.flipEquiv(root1.left, root2.left) and self.flipEquiv(root1.right, root2.right)) or (self.flipEquiv(root1.left, root2.right) and self.flipEquiv(root1.right, root2.left))"}
{"prompt": "def largestComponentSize(self, nums: List[int]) -> int:\n        m = max(nums)\n        uf = UnionFind(m+1)\n        for x in nums: \n            for p in range(2, int(sqrt(x))+1): \n                if x%p == 0: \n                    uf.union(x, p)\n                    uf.union(x, x//p)\n        freq = Counter(uf.find(x) for x in nums)\n        return max(freq.values())"}
{"prompt": "def isAlienSorted(self, words: List[str], order: str) -> bool:\n        hm = {ch: i for i, ch in enumerate(order)}\n\n        prev_repr = list(hm[ch] for ch in words[0])\n        for i in range(1, len(words)):\n            cur_repr = list(hm[ch] for ch in words[i])\n\n            if cur_repr < prev_repr:\n                return False\n\n            prev_repr = cur_repr\n\n        return True"}
{"prompt": "def canReorderDoubled(self, arr: List[int]) -> bool:\n        count = collections.Counter(arr)\n        for n in sorted(arr, key=abs):\n            if count[n] == 0:\n                continue\n            if count[n * 2] == 0:\n                return False\n            count[n] -= 1\n            count[n * 2] -= 1\n        \n        return True"}
{"prompt": "def minDeletionSize(self, A: List[str]) -> int:\n        m, n = len(A), len(A[0])\n        ans, in_order = 0, [False] * (m-1)\n        for j in range(n):\n            tmp_in_order = in_order[:]\n            for i in range(m-1):\n\t\t\t\t# previous step, rows are not in order; and current step rows are not in order, remove this column\n                if not in_order[i] and A[i][j] > A[i+1][j]: ans += 1; break  \n\t\t\t\t# previous step, rows are not in order, but they are in order now\n                elif A[i][j] < A[i+1][j] and not in_order[i]: tmp_in_order[i] = True\n\t\t\t# if column wasn't removed, update the row order information\n            else: in_order = tmp_in_order  \n            # not necessary, but speed things up\n            if all(in_order): return ans   \n        return ans"}
{"prompt": "def tallestBillboard(self, rods: List[int]) -> int:\n        dp = {0: 0}\n        for x in rods: \n            for k, v in dp.copy().items(): \n                dp[k+x] = max(dp.get(k+x, 0), v)\n                if k >= x: dp[k-x] = max(dp.get(k-x, 0), v+x)\n                else: dp[x-k] = max(dp.get(x-k, 0), v+k)\n        return dp[0]"}
{"prompt": "def prisonAfterNDays(self, cells: List[int], N: int) -> List[int]:\n        def nextday(cells):\n            next_day_cells = [0] *len(cells)\n            for i in range(1,len(cells)-1):\n                if cells[i-1] == cells[i+1]: \n                        next_day_cells[i] = 1\n                else:\n                        next_day_cells[i] = 0\n            return next_day_cells\n        \n        seen = {}\n        while N > 0:\n            c = tuple(cells)\n            if c in seen:\n                N %= seen[c] - N\n            seen[c] = N\n\n            if N >= 1:\n                N -= 1\n                cells = nextday(cells)\n\n        return cells"}
{"prompt": "def isCompleteTree(self, root: TreeNode) -> bool:\n                        # The criteria for an n-level complete tree:\n                        #\n                        #   • The first n-1 rows have no null nodes.\n                        #\n                        #   • The nth row has no non-null nodes to the right of the left-most null\n                        #     node encountered (if it exists).\n                        #\n                        # The plan is to bfs the tree, left to right, level by level. We mark the\n                        # instance of the first null popped from the queue and then ensure the remaining\n                        # queue is only null nodes. If so, both criteria are satisfied and True is\n                        # returned. If not, False is returned.\n\n        queue = deque([root])                       #   <-- initialize the queue\n\n        while queue[0]:                             #   <-- if and while top queue node is not null, pop   \n            node = queue.popleft()                  #       it and then push its left child and right  \n            queue.extend([node.left, node.right])   #       child onto the queue.\n\n        while queue and not queue[0]:               #   <-- if and while top queue node is null, pop it. \n            queue.popleft()                         #        \n\n        if queue: return False                      #   <-- If the queue is not empty, it must be non-null, so \n        return True                                 #       return False; if the queue is empty, return True."}
{"prompt": "def regionsBySlashes(self, grid: List[str]) -> int:\n        def dfs(i: int, j: int) -> int:\n            if min(i, j) < 0 or max(i, j) >= len(g) or g[i][j] != 0:\n                return 0\n            g[i][j] = 1\n            return 1 + dfs(i - 1, j) + dfs(i + 1, j) + dfs(i, j - 1) + dfs(i, j + 1)\n        n, regions  = len(grid), 0\n        g = [[0] * n * 3 for i in range(n * 3)]\n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] == '/':\n                    g[i * 3][j * 3 + 2] = g[i * 3 + 1][j * 3 + 1] = g[i * 3 + 2][j * 3] = 1\n                elif grid[i][j] == '\\\\':\n                    g[i * 3][j * 3] = g[i * 3 + 1][j * 3 + 1] = g[i * 3 + 2][j * 3 + 2] = 1\n        for i in range(n * 3):\n            for j in range(n * 3):\n                regions += 1 if dfs(i, j) > 0 else 0\n        return regions"}
{"prompt": "def minDeletionSize(self, strs: List[str]) -> int:\n        m, n = len(strs), len(strs[0]) # dimensions\n        \n        @cache \n        def fn(k, prev):\n            \"\"\"Return min deleted columns to make sorted.\"\"\"\n            if k == n: return 0 \n            ans = 1 + fn(k+1, prev) # delete kth column\n            if prev == -1 or all(strs[i][prev] <= strs[i][k] for i in range(m)): \n                ans = min(ans, fn(k+1, k)) # retain kth column\n            return ans \n        \n        return fn(0, -1)"}
{"prompt": "def repeatedNTimes(self, nums: List[int]) -> int:\n        \n        list1 = []\n        for i in nums :\n            if i in list1 :\n                return i\n            else :\n                list1.append(i)"}
{"prompt": "def maxWidthRamp(self, A: List[int]) -> int:\n        ans = 0\n        stack = []\n        for i in range(len(A)): \n            if not stack or A[stack[-1]] > A[i]: stack.append(i)\n            else: \n                lo, hi = 0, len(stack)\n                while lo < hi: \n                    mid = lo + hi >> 1\n                    if A[stack[mid]] <= A[i]: hi = mid\n                    else: lo = mid + 1\n                ans = max(ans, i - stack[lo])\n        return ans"}
{"prompt": "def minAreaFreeRect(self, points: List[List[int]]) -> float:\n        ans = inf\n        seen = {}\n        for i, (x0, y0) in enumerate(points):\n            for x1, y1 in points[i+1:]:\n                cx = (x0 + x1)/2\n                cy = (y0 + y1)/2\n                d2 = (x0 - x1)**2 + (y0 - y1)**2\n                for xx, yy in seen.get((cx, cy, d2), []): \n                    area = sqrt(((x0-xx)**2 + (y0-yy)**2) * ((x1-xx)**2 + (y1-yy)**2))\n                    ans = min(ans, area)\n                seen.setdefault((cx, cy, d2), []).append((x0, y0))\n        return ans if ans < inf else 0"}
{"prompt": "def leastOpsExpressTarget(self, x: int, target: int) -> int:\n        \n        @cache\n        def fn(val): \n            \"\"\"Return min ops to express val.\"\"\"\n            if val < x: return min(2*val-1, 2*(x-val))\n            k = int(log(val)//log(x))\n            ans = k + fn(val - x**k)\n            if x**(k+1) < 2*val: \n                ans = min(ans, k + 1 + fn(x**(k+1) - val))\n            return ans \n        \n        return fn(target)"}
{"prompt": "def isUnivalTree(self, root: Optional[TreeNode]) -> bool:\n        val = root.val\n        \n        def helper(root):\n            return root is None or (root.val == val and helper(root.left) and helper(root.right))\n        \n        return helper(root)"}
{"prompt": "def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\n        \n        # Convert words and vowels to sets for O(1) lookup times\n        words = set(wordlist)\n        vowels = set('aeiouAEIOU')\n        \n        # Create two maps.  \n        # One for case insensitive word to all words that match \"key\" -> [\"Key\", \"kEy\", \"KEY\"]\n        # The other for vowel insensitive words \"k*t*\" -> [\"Kite\", \"kato\", \"KUTA\"]\n        case_insensitive = collections.defaultdict(list)            \n        vowel_insensitive = collections.defaultdict(list)\n        for word in wordlist:\n            case_insensitive[word.lower()].append(word)\n            key = ''.join(char.lower() if char not in vowels else '*' for char in word)\n            vowel_insensitive[key].append(word)\n\n        res = []\n        for word in queries:\n\n            # Case 1: When query exactly matches a word\n            if word in words:\n                res.append(word)\n                continue\n\n            # Case 2: When query matches a word up to capitalization\n            low = word.lower()\n            if low in case_insensitive:\n                res.append(case_insensitive[low][0])\n                continue\n\n            # Case 3: When query matches a word up to vowel errors\n            key = ''.join(char.lower() if char not in vowels else '*' for char in word)\n            if key in vowel_insensitive:\n                res.append(vowel_insensitive[key][0])\n                continue\n\n            res.append('')\n\n        return res"}
{"prompt": "def numsSameConsecDiff(self, n: int, k: int) -> List[int]:\n\t\tgraph = defaultdict(list)\n\t\tfor i in range(0, 10):\n\t\t\tif i-k >= 0:\n\t\t\t\tgraph[i].append(i-k)\n\t\t\tif i +k < 10:\n\t\t\t\tgraph[i].append(i+k)\n\t\tstart = [i for i in graph if i!= 0]\n\t\tfor j in range(n-1):\n\t\t\tnew = set()\n\t\t\tfor i in start:\n\t\t\t\tlast = i%10\n\t\t\t\tfor k in graph[last]:\n\t\t\t\t\tnew.add(i*10 + k)\n\t\t\tstart = new\n\t\treturn list(start)"}
{"prompt": "def minCameraCover(self, root: TreeNode) -> int:\n        # set the value of camera nodes to 1\n        # set the value of monitored parent nodes to 2\n        def dfs(node: Optional[TreeNode]) -> int:\n            if not node:\n                return 0\n            res = dfs(node.left)+dfs(node.right)\n            # find out if current node is a root node / next node in line to be monitored\n            curr = min(node.left.val if node.left else float('inf'), node.right.val if node.right else float('inf'))\n            if curr == 0:\n                # at least one child node requires monitoring, this node must have a camera\n                node.val = 1\n                res += 1\n            elif curr == 1:\n                # at least one child node is a camera, this node is already monitored\n                node.val = 2\n            # if curr == float('inf'), the current node is a leaf node; let the parent node monitor this node\n            # if curr == 2, all child nodes are being monitored; treat the current node as a leaf node\n            return res\n        # ensure that root node is monitored, otherwise, add a camera onto root node\n        return dfs(root)+(root.val == 0)"}
{"prompt": "def pancakeSort(self, arr: List[int]) -> List[int]:\n\n        if arr == sorted(arr):\n            return []\n        \n        flips = []\n        end = len(arr) - 1\n        \n        # find the max flip all the numbers from the first position to the max position \n        # ==> from 0 to max_position = k\n        # ==> if max not at the end : flip again until the max is at the end of the array \n        # ==> from 0 to max_position = k\n        # end = end - 1\n        # repeat previous steps\n\n        while end > 0:\n            \n            max_num = max(arr[:end+1])\n            index_num = arr.index(max_num)\n            \n            if index_num != end:\n                k = index_num + 1\n                arr = arr[0:k][::-1] + arr[k:]\n                flips.append(k)\n                arr = arr[:end+1][::-1] + arr[end+1:]\n                flips.append(end+1)\n            else:\n                k = end\n                arr = arr[0:k][::-1] + arr[k:]\n                flips.append(k)\n            \n            end -= 1\n\n        return flips"}
{"prompt": "def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:\n        bx = int(log(bound)/log(x)) if x > 1 else 0\n        by = int(log(bound)/log(y)) if y > 1 else 0 \n        \n        ans = set()\n        for i in range(bx+1): \n            for j in range(by+1):\n                if x**i + y**j <= bound: \n                    ans.add(x**i + y**j)\n        return ans"}
{"prompt": "def __init__(self):\n        self.flipped_nodes = []\n        self.index = 0\n        \n    def flipMatchVoyage(self, root: TreeNode, voyage: List[int]) -> List[int]:\n        queue = deque([root])\n        while queue:\n            node = queue.pop()\n            if not node: continue\n            if node.val != voyage[self.index]: return [-1]\n            self.index += 1\n            if node.left and node.left.val != voyage[self.index]:\n                self.flipped_nodes.append(node.val)\n                node.left, node.right = node.right, node.left\n            queue.append(node.right), queue.append(node.left)\n        return self.flipped_nodes"}
{"prompt": "def isRationalEqual(self, S: str, T: str) -> bool:\n        L, A = [len(S), len(T)], [S,T]\n        for i,p in enumerate([S,T]):\n            if '(' in p:\n                I = p.index('(')\n                A[i] = p[0:I] + 7*p[I+1:L[i]-1]\n        return abs(float(A[0])-float(A[1])) < 1E-7\n\t\t\n\t\t\n- Junaid Mansuri"}
{"prompt": "def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n        return sorted(points, key = lambda p: p[0]**2 + p[1]**2)[0:k]"}
{"prompt": "def subarraysDivByK(self, A: List[int], k: int) -> int:\n        dic = collections.defaultdict(int)\n        dic[0] = 1\n        ans = 0\n        presum = 0\n        for num in A:\n            presum += num\n            ans += dic[presum%k]\n            dic[presum%k] += 1\n        return ans\n\t```"}
{"prompt": "def oddEvenJumps(self, A: List[int]) -> int:\n        \n\t\t# find next index of current index that is the least larger/smaller\n        def getNextIndex(sortedIdx):\n            stack = []\n            result = [None] * len(sortedIdx)\n        \n            for i in sortedIdx:\n                while stack and i > stack[-1]:\n                    result[stack.pop()] = i\n                stack.append(i)\n            return result\n        \n        sortedIdx = sorted(range(len(A)), key= lambda x: A[x])\n        oddIndexes = getNextIndex(sortedIdx)\n        sortedIdx.sort(key=lambda x: -A[x])\n        evenIndexes = getNextIndex(sortedIdx)\n        \n\t\t# [odd, even], the 0th jump is even\n        dp = [[0,1] for _ in range(len(A))]\n        \n        for i in range(len(A)):\n            if oddIndexes[i] is not None:\n                dp[oddIndexes[i]][0] += dp[i][1]\n            if evenIndexes[i] is not None:\n                dp[evenIndexes[i]][1] += dp[i][0]\n\t\t\t\t\n        return dp[-1][0] + dp[-1][1]"}
{"prompt": "def largestPerimeter(self, A: List[int]) -> int:\n        A.sort(reverse = True)\n        for i in range(3,len(A)+1):\n            if(A[i-3] < A[i-2] + A[i-1]):\n                return sum(A[i-3:i])\n        return 0"}
{"prompt": "def sortedSquares(self, A: List[int]) -> List[int]:\n        return_array = [0] * len(A)\n        write_pointer = len(A) - 1\n        left_read_pointer = 0\n        right_read_pointer = len(A) - 1\n        left_square = A[left_read_pointer] ** 2\n        right_square = A[right_read_pointer] ** 2\n        while write_pointer >= 0:\n            if left_square > right_square:\n                return_array[write_pointer] = left_square\n                left_read_pointer += 1\n                left_square = A[left_read_pointer] ** 2\n            else:\n                return_array[write_pointer] = right_square\n                right_read_pointer -= 1\n                right_square = A[right_read_pointer] ** 2\n            write_pointer -= 1\n        return return_array"}
{"prompt": "def maxTurbulenceSize(self, arr: List[int]) -> int:\n        cur, mx, t = 1, 1, None\n        for i in range(1, len(arr)):\n            # Start of subarray\n            if t == None:\n                if arr[i] != arr[i-1]: \n                    cur = 2\n                    t = arr[i] > arr[i-1]\n            # Valid element in subarray, continue cur subarray\n            elif (t and arr[i] < arr[i-1]) or (not t and arr[i] > arr[i-1]):\n                cur += 1; t = not t\n            # Invalid element in subarray, start new subarray\n            else:\n                if arr[i] == arr[i-1]: t = None\n                mx = max(mx, cur)\n                cur = 2\n        \n        return max(mx, cur)"}
{"prompt": "def distributeCoins(self, v: Optional[TreeNode], parent=None) -> int:\n        if v is None:\n            return 0\n        m = self.distributeCoins(v.left, v) + self.distributeCoins(v.right, v)\n        if v.val != 1:\n            parent.val += v.val - 1\n            m += abs(v.val - 1)\n        return m"}
{"prompt": "def uniquePathsIII(self, grid: List[List[int]]) -> int:\n\t\t# first, prepare the starting and ending points\n\t\t# simultaneously, record all the non-obstacle coordinates\n        start = end = None\n        visit = set()\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 0:\n                    visit.add((i, j))\n                elif grid[i][j] == 1:\n                    start = (i, j)\n                elif grid[i][j] == 2:\n                    end = (i, j)\n                    visit.add((i, j))\n        \n        def backtrack(x, y, visit):\n            if (x, y) == end:\n\t\t\t\t# implement success condition: valid only if there are no more coordinates to visit\n                return len(visit) == 0\n            result = 0  # assume no valid paths by default\n\t\t\t\n\t\t\t# we need to try every possible path from this coordinate\n            if (x-1, y) in visit:\n\t\t\t\t# the coordinate directly above this one is non-obstacle, try that path\n                visit.remove((x-1, y))  # first, note down the 'visited status' of the coordinate\n                result += backtrack(x-1, y, visit)  # then, DFS to find all valid paths from that coordinate\n                visit.add((x-1, y))  # last, reset the 'visited status' of the coordinate\n            if (x+1, y) in visit:\n\t\t\t\t# the coordinate directly below this one is non-obstacle, try that path\n                visit.remove((x+1, y))\n                result += backtrack(x+1, y, visit)\n                visit.add((x+1, y))\n            if (x, y-1) in visit:\n\t\t\t\t# the coordinate directly to the left of this one is non-obstacle, try that path\n                visit.remove((x, y-1))\n                result += backtrack(x, y-1, visit)\n                visit.add((x, y-1))\n            if (x, y+1) in visit:\n\t\t\t\t# the coordinate directly to the right of this one is non-obstacle, try that path\n                visit.remove((x, y+1))\n                result += backtrack(x, y+1, visit)\n                visit.add((x, y+1))\n            return result\n        \n        return backtrack(start[0], start[1], visit)  # we start from the starting point, backtrack all the way back, and consolidate the result"}
{"prompt": "def countTriplets(self, nums: List[int]) -> int:\n        freq = defaultdict(int)\n        for x in nums: \n            for y in nums: \n                freq[x&amp;y] += 1\n        \n        ans = 0\n        for x in nums: \n            mask = x = x ^ 0xffff\n            while x: \n                ans += freq[x]\n                x = mask &amp; (x-1)\n            ans += freq[0]\n        return ans"}
{"prompt": "def mincostTickets(self, days: List[int], costs: List[int]) -> int:\n\t\t#create the total costs for the days \n        costForDays = [0 for _ in range(days[-1] + 1) ]\n\t\t#since days are sorted in ascending order, we only need the index of the days we haven't visited yet\n        curIdx = 0\n\t\t\n        for d in range(1, len(costForDays)):\n\t\t\t#if we do not need to travel that day\n\t\t\t#we don't need to add extra costs\n            if d < days[curIdx]:\n                costForDays[d] = costForDays[d - 1]\n                continue\n            \n\t\t\t#else this means we need to travel this day\n\t\t\t#find the cost if we were to buy a 1-day pass, 7-day pass and 30-day pass\n            costs_extra_1 = costForDays[d - 1] + costs[0]\n            costs_extra_7 = costForDays[max(0, d - 7)] + costs[1] \n            costs_extra_30 = costForDays[max(0, d - 30)] + costs[2]\n            \n\t\t\t#get the minimum value\n            costForDays[d] = min(costs_extra_1, costs_extra_7, costs_extra_30)\n\t\t\t\n\t\t\t#update the index to the next day we need to travel\n            curIdx += 1\n\t\t\t\n        return costForDays[-1]"}
{"prompt": "def strWithout3a3b(self, a: int, b: int) -> str:\n        res = []\n        while a + b > 0:\n            if len(res) >= 2 and res[-2:] == ['a', 'a']:\n                res.append('b')\n                b-=1\n            elif len(res) >= 2 and res[-2:] == ['b', 'b']:\n                res.append('a')\n                a-=1\n            elif a > b:\n                res.append('a')\n                a-=1\n            else:\n                res.append('b')\n                b-=1\n            \n        return ''.join(res)"}
{"prompt": "# the idea is we don't calculate the even sum from scratch for each query\n    # instead, we calculate it at the beginning\n    # since each query only updates one value, \n    # so we can adjust the even sum base on the original value and new value\n    def sumEvenAfterQueries(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        # calculate the sum of all even numbers\n        evenSum = sum(x for x in nums if x % 2 == 0)\n        ans = []\n        for val, idx in queries:\n            # if original nums[idx] is even, then we deduct it from evenSum\n            if nums[idx] % 2 == 0: evenSum -= nums[idx]\n            # in-place update nums\n            nums[idx] += val\n            # check if we need to update evenSum for the new value\n            if nums[idx] % 2 == 0: evenSum += nums[idx]\n            # then we have evenSum after this query, push it to ans \n            ans.append(evenSum)\n        return ans"}
{"prompt": "def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        \n        idx_a, idx_b = 0, 0\n        size_a, size_b = len(A), len(B)\n        \n        intersection = []\n        \n        # Scan each possible interval pair\n        while idx_a < size_a and idx_b < size_b :\n            \n            # Get start-time as well as end-time\n            start_a, end_a = A[idx_a]\n            start_b, end_b = B[idx_b]\n            \n            \n            # Compute common start time and end time for current interval pair\n            common_start = max( start_a, start_b )\n            common_end = min( end_a, end_b )\n            \n            if common_start <= common_end:\n                # Find one common overlapped interval\n                intersection.append( [common_start, common_end] )\n                \n            if end_a <= end_b:\n                # Try next interval of A\n                idx_a += 1\n                \n            else:\n                # Try next interval of B\n                idx_b += 1\n        \n        return intersection"}
{"prompt": "def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        results = defaultdict(list)\n        \n        queue = [ (root, 0, 0) ]\n        \n        while queue:\n            node, pos, depth = queue.pop(0)\n            if not node: continue\n            results[(pos,depth)].append(node.val)\n            results[(pos,depth)].sort()\n            queue.extend( [ (node.left, pos-1, depth+1), (node.right, pos+1, depth+1) ] )\n            \n            \n        res = defaultdict(list)\n        keys = sorted(list(results.keys()), key=lambda x: (x[0], x[1]))\n        \n        \n        for k in keys:\n            pos, depth = k\n            res[pos].extend(results[k])\n\n        return res.values()"}
{"prompt": "res = 'z' * 13           # init max result, tree depth,  12< log2(8000) < 13\n    \n    def smallestFromLeaf(self, root: TreeNode) -> str:\n        \n        def helper(node: TreeNode, prev):\n            prev = chr(97 + node.val) + prev\n            \n            if not node.left and not node.right:\n                self.res = min(self.res, prev)\n                return\n            \n            if node.left:\n                helper(node.left, prev)\n            if node.right:\n                helper(node.right, prev)\n        \n        helper(root, \"\")\n        return self.res"}
{"prompt": "def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        return list(str(int(\"\".join([str(x) for x in num])) + k))"}
{"prompt": "# Here's the plan:\n                    #   1) We make an undirected graph in which the nodes are integers\n                    #      (as lower-case letters) and each edge connects integers\n                    #      that are equal.\n                    #   2) We use a union-find process to determine the connected graphs\n                    #   3) We keep track of the pairs (a,b) such that a =! b. If the any\n                    #      such pair are in the same connected graph, then return False,\n                    #      otherwise return True.\n    def equationsPossible(self, equations: List[str]) -> bool:\n        parent, diff = {}, []\n\n        def find(x):\n            if x not in parent: return x\n            else: return find(parent[x])\n\n        for s in equations:                 # <-- 1)\n            a, b = s[0], s[3]\n\n            if s[1]== \"=\":                  # <-- 2)\n                x, y = find(a), find(b)\n                if x!=y:\n                    parent[y] = x\n            else:    \n                diff.append((a,b))          # <-- 3)\n\n        return all(find(a)!=find(b) for a, b in diff)"}
{"prompt": "def brokenCalc(self, x: int, y: int) -> int:\n        if y<=x:\n            return x-y\n        else:\n            res=0\n            while x<y:\n                if y%2==1:\n                    y+=1\n                else:\n                    y=y//2\n                res+=1\n            res+=(x-y)\n            return res"}
{"prompt": "def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\n        \n        def window(nums, k):\n            left = 0\n            right = 0\n\n            res = 0\n            in_set = set()\n            hash_map = collections.Counter()\n\n            while right < len(nums):\n                in_set.add(nums[right])\n                hash_map[nums[right]] += 1\n\n                while len(in_set) > k:\n                    hash_map[nums[left]] -= 1\n                    if hash_map[nums[left]] == 0:\n                        in_set.remove(nums[left])\n                    left += 1\n\n                res += (right - left + 1)\n\n                right += 1\n            return res\n    \n       return window(nums, k) - window(nums, k - 1)"}
{"prompt": "def isCousins(self, root: Optional[TreeNode], x: int, y: int) -> bool:\n\t\t# Check if root node is x or y\n        if root.val == x or root.val == y:\n            return False\n\t\t# Prepare for BFS, initialise variables\n        curr, flag = [root.left, root.right], False\n\t\t\n        while curr:\n            tmp = []\n\t\t\t# Check nodes two-by-two\n            for i in range(0, len(curr), 2):\n\t\t\t\t# Case 1: x and y are both found\n\t\t\t\t# This indicates that they have the same parent\n                if curr[i] and curr[i+1] and \\\n                       ((curr[i].val == x and curr[i+1].val == y) or \\\n                       (curr[i+1].val == x and curr[i].val == y)):\n                    return False\n\t\t\t\t# Case 2: Either one of x or y is found\n                elif (curr[i] and (curr[i].val == x or curr[i].val == y)) or \\\n                        (curr[i+1] and (curr[i+1].val == x or curr[i+1].val == y)):\n                    if flag:\n\t\t\t\t\t\t# Previously, the other node has been found in the same depth\n\t\t\t\t\t\t# This is our success condition, return True\n                        return True\n\t\t\t\t\t# Otherwise, this is the first node in the current depth to be found\n                    flag = True\n\t\t\t\t\n\t\t\t\t# Simultaneously, we can prepare the nodes for the subsequent depth\n\t\t\t\t# Note to append both left and right regardless of existence\n                if curr[i]:\n                    tmp.append(curr[i].left)\n                    tmp.append(curr[i].right)\n                if curr[i+1]:\n                    tmp.append(curr[i+1].left)\n                    tmp.append(curr[i+1].right)\n\t\t\t\n\t\t\t# Before we proceed to the next depth, check:\n            if flag:\n\t\t\t\t# One of the nodes has already been found\n\t\t\t\t# This means that the other node cannot be of the same depth\n\t\t\t\t# By definition, this means that the two nodes are not cousins\n                return False\n            curr = tmp  # Assign the new nodes as the current ones\n\t\t\n\t\t# The program will never reach here since x and y are guaranteed to be found\n\t\t# But you can return False if you want"}
{"prompt": "def orangesRotting(self, grid: List[List[int]]) -> int:\n        visit, curr = set(), deque()\n\t\t# find all fresh and rotten oranges\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1:\n                    visit.add((i, j))\n                elif grid[i][j] == 2:\n                    curr.append((i, j))\n        result = 0\n        while visit and curr:\n\t\t\t# BFS iteration\n            for _ in range(len(curr)):\n                i, j = curr.popleft()  # obtain recent rotten orange\n                for coord in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):\n                    if coord in visit:  # check if adjacent orange is fresh\n                        visit.remove(coord)\n                        curr.append(coord)\n            result += 1\n\t\t# check if fresh oranges remain and return accordingly\n        return -1 if visit else result"}
{"prompt": "def minKBitFlips(self, nums: List[int], k: int) -> int:\n        ans = 0\n        q = []\n        for i in range(len(nums)):\n            if len(q) % 2 == 0:\n                if nums[i] == 0:\n                    if i+k-1 <= len(nums)-1:\n                        ans += 1\n                        q.append(i+k-1)\n                    else:\n                        return -1\n            else:\n                if nums[i] == 1:\n                    if i+k-1 <= len(nums)-1:\n                        ans += 1\n                        q.append(i+k-1)\n                    else:\n                        return -1\n            if q:\n                if q[0] == i:\n                    q.pop(0)\n        return ans"}
{"prompt": "def numSquarefulPerms(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def dfs(temp,num,count = 0):\n            if len(num)==0:\n                return count+1\n            for i in xrange(len(num)):\n                if (i>0 and num[i]==num[i-1]) or (len(temp) > 0 and math.sqrt(num[i] + temp[-1]) % 1 != 0):\n                    continue\n                count = dfs(temp+[num[i]],num[:i]+num[i+1:],count)\n            return count\n        \n        nums.sort()\n        res = dfs([],nums)\n        return res"}
{"prompt": "def findJudge(self, N: int, trust: List[List[int]]) -> int:\n        Trusted = [0] * (N+1)\n        for (a, b) in trust:\n            Trusted[a] -= 1\n            Trusted[b] += 1\n            \n        for i in range(1, len(Trusted)):\n            if Trusted[i] == N-1:\n                return i\n        return -1"}
{"prompt": "def insertIntoMaxTree(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\n        if not root: return TreeNode(val)\n        if val > root.val: return TreeNode(val, root)\n        root.right = self.insertIntoMaxTree(root.right, val)\n        return root"}
{"prompt": "def numRookCaptures(self, b: List[List[str]]) -> int:\n        I, J = divmod(sum(b,[]).index('R'),8)\n        C = \"\".join([i for i in [b[I]+['B']+[b[i][J] for i in range(8)]][0] if i != '.'])\n        return C.count('Rp') + C.count('pR')\n\t\t\n\t\t\n- Junaid Mansuri\n(LeetCode ID)@hotmail.com"}
{"prompt": "def mergeStones(self, stones: List[int], k: int) -> int:\n        if (len(stones)-1) % (k-1): return -1 # impossible\n        \n        prefix = [0]\n        for x in stones: prefix.append(prefix[-1] + x)\n        \n        @cache\n        def fn(lo, hi): \n            \"\"\"Return min cost of merging stones[lo:hi].\"\"\"\n            if hi - lo < k: return 0 # not enough stones\n            ans = inf \n            for mid in range(lo+1, hi, k-1): \n                ans = min(ans, fn(lo, mid) + fn(mid, hi))\n            if (hi-lo-1) % (k-1) == 0: ans += prefix[hi] - prefix[lo]\n            return ans \n        \n        return fn(0, len(stones))"}
{"prompt": "def gridIllumination(self, n: int, lamps: List[List[int]], queries: List[List[int]]) -> List[int]:\n        lamps = {(r, c) for r, c in lamps}\n        \n        row, col, left, right = dict(), dict(), dict(), dict()\n        for r, c in lamps:\n            row[r] = row.get(r, 0) + 1\n            col[c] = col.get(c, 0) + 1\n            left[r - c] = left.get(r - c, 0) + 1\n            right[r + c] = right.get(r + c, 0) + 1\n\n        res = list()\n        for qr, qc in queries:\n            if row.get(qr, 0) or col.get(qc, 0) or left.get(qr - qc, 0) or right.get(qr + qc, 0):\n                res.append(1)\n            else:\n                res.append(0)\n\n            for r, c in product(range(qr - 1, qr + 2), range(qc - 1, qc + 2)):\n                if (r, c) in lamps:\n                    lamps.remove((r, c))\n                    row[r] -= 1\n                    col[c] -= 1\n                    left[r - c] -= 1\n                    right[r + c] -= 1\n\n        return res"}
{"prompt": "def commonChars(self, A: List[str]) -> List[str]:\n        alphabet = string.ascii_lowercase\n        d = {c: 0 for c in alphabet}\n        \n        for k, v in d.items():\n            d[k] = min([word.count(k) for word in A])\n\n        res = []\n        for c, n in d.items():\n            if n > 0:\n                res += [c] * n\n        return res"}
{"prompt": "def isValid(self, s: str) -> bool:\n        stack=[]\n        for i in s:\n            if i == 'a':stack.append(i)\n            elif i=='b':\n                if not stack:return False\n                else:\n                    if stack[-1]=='a':stack.pop()\n                    else:return False\n                    stack.append(i)\n            else:\n                if not stack:return False\n                else:\n                    if stack[-1]=='b':stack.pop()\n                    else:return False\n\n        return len(stack)==0"}
{"prompt": "def longestOnes(self, nums: List[int], k: int) -> int:\n        left = 0\n        answer = 0\n        counts = {0: 0, 1: 0}\n        \n        for right, num in enumerate(nums):\n            counts[num] += 1\n            \n            while counts[0] > k:\n                counts[nums[left]] -= 1\n                left += 1\n                \n            curr_window_size = right - left + 1\n            answer = max(answer, curr_window_size)\n            \n        return answer"}
{"prompt": "def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n\t\tA.sort()\n\t\ti = 0\n\t\twhile i < len(A) and K>0:\n\t\t\tif A[i] < 0: # negative value\n\t\t\t\tA[i] = A[i] * -1 # update the list, change negative to positive\n\t\t\t\tK-=1\n\n\t\t\telif A[i] > 0: # positive value\n\t\t\t\tif K % 2 == 0: # let K==2(must be even value), this means -1*-1==1 so it has no effect on sum\n\t\t\t\t\treturn sum(A)\n\t\t\t\telse: return sum(A) - 2 * min(A) # let A==[1,2,3],K=1, so equation is 6-2(1)==4, same as -1+2+3=4 after taking the minimum in the list to give the largest possible sum required in the question\n\n\t\t\telse: return sum(A) # if A[i]==0,just sum cuz 0 is neutral: 1-0==1 or 1+0==1 thus no change just sum\n\n\t\t\ti+=1\n\n\t\tif K > len(A): # that means we have changed all values to positive\n\t\t\tA.sort() # cuz now its the opposite let A = [-4,-2,-3], K = 8, now flipping all negatives to positives, we have a new minimum which is 2\n\t\t\tif K % 2 == 0: # Here onwards is basically the same thing from before\n\t\t\t\treturn sum(A)\n\t\t\telse: return sum(A) - 2 * min(A)\n\n\t\treturn sum(A)"}
{"prompt": "def clumsy(self, N: int) -> int:\n    \treturn N + ([1,2,2,-1][N % 4] if N > 4 else [0,0,0,3,3][N])"}
{"prompt": "def minDominoRotations(self, tops: List[int], bottoms: List[int]) -> int:\n        total = len(tops)\n        top_fr, bot_fr, val_total = [0]*7, [0]*7, [total]*7\n        for top, bot in zip(tops, bottoms):\n            if top == bot:\n                val_total[top] -= 1\n            else:\n                top_fr[top] += 1\n                bot_fr[bot] += 1\n                \n        for val in range(1, 7):\n            if (val_total[val] - top_fr[val]) == bot_fr[val]:\n                return min(top_fr[val], bot_fr[val])\n            \n        return -1"}
{"prompt": "def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\n        node_stack = []\n        node = root = TreeNode(preorder[0])\n        for n in preorder[1:]:\n            if n <= node.val:\n                node.left = TreeNode(n)\n                node_stack.append(node)\n                node = node.left\n            else:\n                while node_stack and n > node_stack[-1].val:\n                    node = node_stack.pop()\n                node.right = TreeNode(n)\n                node = node.right\n        return root"}
{"prompt": "def bitwiseComplement(self, n: int) -> int:\n        if n == 0:\n            return 1\n        else:\n            result = 0\n            factor = 1\n            \n            while(n > 0):\n                result += factor * (1 if n%2 == 0 else 0)\n                factor *= 2\n                n //= 2\n            return result"}
{"prompt": "def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        res  , count  = 0,  [0] * 60\n        for one in range(len(time)):\n            index = time[one] % 60\n            res += count[(60 - index)%60] # %60 is for index==0\n            count[index] += 1\n        return res"}
{"prompt": "def shipWithinDays(self, weights: List[int], D: int) -> int:\n    \n    def feasible(capacity):\n        days = 1\n        local = 0\n        for w in weights:\n            local+=w\n            if local>capacity:\n                local = w\n                days+=1\n                if days>D:\n                    return False\n        return True\n            \n                \n    left, right = max(weights), sum(weights)\n    while left < right:\n        mid = left + (right-left)//2\n        if feasible(mid):\n            right = mid\n        else:\n            left = mid + 1\n            \n    return left"}
{"prompt": "def numDupDigitsAtMostN(self, N: int) -> int:\n    \tT = [9,261,4725,67509,831429,9287109,97654149,994388229]\n    \tt = [99,999,9999,99999,999999,9999999,99999999,999999999]\n    \tif N < 10:\n    \t\treturn 0\n    \tL = len(str(N))\n    \tm, n = [1], []\n    \tg = 11-L\n    \tfor i in range(L):\n    \t\tn.append(int(str(N)[i]))\n    \t\tm.append(g)\n    \t\tg = g*(12-L+i)\n    \tS = 0\n    \tfor i in range(L):\n    \t\tif len(set(n[:L-i-1])) != len(n)-i-1:\n    \t\t\tcontinue\n    \t\tk = 0\n    \t\tfor j in range(10):\n    \t\t\tif j not in n[:L-i-1] and j > n[L-i-1]:\n    \t\t\t\tk += 1\n    \t\tS += k*m[i]\n    \treturn(T[L-2]-(t[L-2]-N-S))\n\t\n- Python 3\n- Junaid Mansuri"}
{"prompt": "def canThreePartsEqualSum(self, A: List[int]) -> bool:\n    \tS = sum(A)\n    \tif S % 3 != 0: return False\n    \tg, C, p = S//3, 0, 0\n    \tfor a in A[:-1]:\n    \t\tC += a\n    \t\tif C == g:\n    \t\t\tif p == 1: return True\n    \t\t\tC, p = 0, 1\n    \treturn False"}
{"prompt": "def maxScoreSightseeingPair(self, values: List[int]) -> int:      \n      dp = [0]*(len(values))\n      dp[0] = values[0]\n      maxVal = 0\n      \n      for i in range(1, len(values)):\n        dp[i] = max(dp[i-1], values[i-1]+i-1)\n        maxVal = max(maxVal, dp[i]+values[i]-i)\n      \n      return maxVal"}
{"prompt": "def smallestRepunitDivByK(self, k: int) -> int:\n        if not k % 2 or not k % 5: return -1\n        n = length = 1\n        while True:\n            if not n % k: return length\n            length += 1\n            n = 10*n + 1"}
{"prompt": "def queryString(self, S: str, N: int) -> bool:\n        for x in range(N, 0, -1):\n            if bin(x)[2:] not in S: return False \n        return True"}
{"prompt": "def baseNeg2(self, n: int) -> str:\n        ans = \"\"\n        while n != 0:\n            if n%-2 != 0 :\n                ans = '1' + ans\n                n = (n-1)//-2\n            else:\n                ans = '0' + ans\n                n = n//-2\n        return ans if ans !=\"\" else '0'"}
{"prompt": "def prefixesDivBy5(self, A: List[int]) -> List[bool]:\n    \tn = 0\n    \tfor i in range(len(A)): A[i], n = (2*n + A[i]) % 5 == 0, (2*n + A[i]) % 5\n    \treturn A\n\t\t\n\t\t\n- Junaid Mansuri\n(LeetCode ID)@hotmail.com"}
{"prompt": "def nextLargerNodes(self, head: ListNode) -> List[int]:\n        result = []\n        stack = []\n        for i, current in enumerate(self.value_iterator(head)):\n            result.append(0)\n            while stack and stack[-1][0] < current:\n                _, index = stack.pop()\n                result[index] = current\n            stack.append((current, i))\n        return result\n\n    def value_iterator(self, head: ListNode):\n        while head is not None:\n            yield head.val\n            head = head.next"}
{"prompt": "def numEnclaves(self, A: List[List[int]]) -> int:\n    row, col = len(A), len(A[0])\n    \n    if not A or not A[0]:\n        return 0\n    \n    boundary1 = deque([(i,0) for i in range(row) if A[i][0]==1]) + deque([(i,col-1) for i in range(row) if A[i][col-1]==1])\n    boundary2 = deque([(0,i) for i in range(1,col-1) if A[0][i]==1]) + deque([(row-1,i) for i in range(1,col-1) if A[row-1][i]==1])\n        \n    queue = boundary1+boundary2\n    \n    \n    def bfs(queue,A):\n        visited = set()\n        while queue:\n            x,y = queue.popleft()\n            A[x][y] = \"T\"\n            if (x,y) in visited: continue\n            visited.add((x,y))\n            for nx,ny in [[x+1,y],[x-1,y],[x,y+1],[x,y-1]]:\n                if 0<=nx<row and 0<=ny<col and A[nx][ny]==1:\n                    A[nx][ny] = \"T\"\n                    queue.append((nx,ny))\n        return A\n    \n    bfs(queue,A)\n    \n    count = 0\n    for x in range(row):\n        for y in range(col):\n            if A[x][y] == 1:\n                count+=1\n    return count"}
{"prompt": "def removeOuterParentheses(self, S: str) -> str:\n        \n        stack=[]\n        counter=0\n        for i in S:\n            if i=='(':\n                counter=counter+1\n                if counter==1:\n                    pass\n                else:\n                    stack.append(i)\n            else:\n                counter=counter-1\n                if counter == 0:\n                    pass\n                else:\n                    stack.append(i)\n        return (''.join(stack))"}
{"prompt": "def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:\n        def dfs(node, path):\n            if not node: return 0\n\n            path = (path << 1) + node.val\n\t\t\t\n            if not node.left and not node.right:\n                return path\n            \n            return dfs(node.left, path) + dfs(node.right, path)\n            \n        return dfs(root, 0)"}
{"prompt": "def camelMatch(self, queries: List[str], pattern: str) -> List[bool]:\n        \n        def match(p, q):\n            i = 0\n            for j, c in enumerate(q):\n                if i < len(p) and p[i] == q[j]: i += 1\n                elif q[j].isupper(): return False\n            return i == len(p)\n        \n        return [True if match(pattern, s) else False for s in queries]"}
{"prompt": "def videoStitching(self, clips: List[List[int]], T: int) -> int:\n        end, end2, res = -1, 0, 0\n        for i, j in sorted(clips):\n            if end2 >= T or i > end2:\n                break\n            elif end < i <= end2:\n                res, end = res + 1, end2\n            end2 = max(end2, j)\n        return res if end2 >= T else -1"}
{"prompt": "def divisorGame(self, N: int) -> bool:\n        return N % 2 == 0\n\t\t\n\t\t\n- Junaid Mansuri\n(LeetCode ID)@hotmail.com"}
{"prompt": "def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:\n        def dfs(root, mn, mx):\n            # Base Case: If we reach None, just return 0 in order not to affect the result\n            if not root: return 0\n            \n\t\t\t# The best difference we can do using the current node can be found:\n            res = max(abs(root.val - mn), abs(root.val - mx))\n\t\t\t\n\t\t\t# Recompute the new minimum and maximum taking into account the current node\n            mn, mx = min(mn, root.val), max(mx, root.val)\n\t\t\t\n\t\t\t# Recurse left and right using the newly computated minimum and maximum\n            return max(res, dfs(root.left, mn, mx), dfs(root.right, mn, mx))\n        \n        # Initialize minimum `mn` and maximum `mx` equals value of given root\n        return dfs(root, root.val, root.val)"}
{"prompt": "def longestArithSeqLength(self, A: List[int]) -> int:\n        dp = {}\n        for i, a2 in enumerate(A[1:], start=1):\n            for j, a1 in enumerate(A[:i]):\n                d = a2 - a1\n                if (j, d) in dp:\n                    dp[i, d] = dp[j, d] + 1\n                else:\n                    dp[i, d] = 2\n        return max(dp.values())"}
{"prompt": "def recoverFromPreorder(self, S: str) -> TreeNode:\n        stack = []\n        depth, val = 0, \"\"\n        for i, x in enumerate(S): \n            if x == \"-\": \n                depth += 1\n                val = \"\"\n            else: \n                val += S[i]\n                if i+1 == len(S) or S[i+1] == \"-\": \n                    node = TreeNode(int(val))\n                    while len(stack) > depth: stack.pop()\n                    if stack:\n                        if not stack[-1].left: stack[-1].left = node\n                        else: stack[-1].right = node\n                    stack.append(node)\n                    depth = 0\n        return stack[0]"}
{"prompt": "def twoCitySchedCost(self, costs):\n        \"\"\"\n        :type costs: List[List[int]]\n        :rtype: int\n        \"\"\"\n        a = sorted(costs, key=lambda x: x[0]-x[1])\n        Sa = 0\n        Sb = 0\n        for i in range(len(a)//2):\n            Sa += a[i][0]\n            \n        for i in range(len(a)//2, len(a)):\n            Sb += a[i][1]\n        return Sa + Sb"}
{"prompt": "def allCellsDistOrder(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:\n        d = {}\n        for i in range(R):\n            for j in range(C):\n                d[(i,j)] = d.get((i,j),0) + abs(r0-i) + abs(c0-j)\n        return [list(i) for i,j in sorted(d.items(), key = lambda x : x[1])]"}
{"prompt": "def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\n        prefix = [0]\n        for x in A: prefix.append(prefix[-1] + x) # prefix sum w/ leading 0\n        ans = lmx = mmx = -inf \n        for i in range(M+L, len(A)+1): \n            lmx = max(lmx, prefix[i-M] - prefix[i-L-M])\n            mmx = max(mmx, prefix[i-L] - prefix[i-L-M])\n            ans = max(ans, lmx + prefix[i] - prefix[i-M], mmx + prefix[i] - prefix[i-L])\n        return ans"}
{"prompt": "def numMovesStones(self, a: int, b: int, c: int) -> List[int]:\n        x, y, z = sorted([a, b, c])\n        if x + 1 == y == z - 1:\n            min_steps = 0\n        elif y - x > 2 and z - y > 2:\n            min_steps = 2\n        else:\n            min_steps = 1\n        max_steps = z - x - 2\n        return [min_steps, max_steps]"}
{"prompt": "def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\n        \n        rows, cols = len(grid), len(grid[0])\n        border_color = grid[row][col]\n        border = []\n        \n\t\t# Check if a node is a border node or not\n        def is_border(r, c):\n            if r == 0 or r == rows - 1 or c == 0 or c == cols - 1:\n                return True\n\n            for dr, dc in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                nr, nc = r + dr, c + dc\n                if grid[nr][nc] != border_color:\n                    return True\n            return False                \n        \n        def dfs(r, c):\n            if r < 0 or c < 0 or r == rows or c == cols or (r, c) in visited or grid[r][c] != border_color:\n                return\n            visited.add((r, c))\n            \n            if is_border(r, c):\n                border.append((r, c))\n            \n            dfs(r + 1, c)\n            dfs(r - 1, c)\n            dfs(r, c + 1)\n            dfs(r, c - 1)\n        \n        visited = set()\n        dfs(row, col)\n        for r, c in border:\n            grid[r][c] = color\n        return grid"}
{"prompt": "def maxUncrossedLines(self, nums1: List[int], nums2: List[int]) -> int:\n        e1=len(nums1)\n        e2=len(nums2)\n        @lru_cache(None,None)\n        def dfs(s1,s2):\n            best=-float('inf')\n            if s1>=e1 or s2>=e2:\n                return 0\n            temp=[]\n            op1=0\n\t\t\t#finding element in array2 which is equal to element in array1 from where we want to draw line\n            for idx in range(s2,e2):\n                if nums2[idx]==nums1[s1]:\n                    temp.append(idx)\n\t\t\t#drawing line to all those element and checking which gives maximum value\n            for j in temp:\n                op1=1+dfs(s1+1,j+1)\n                best=max(op1,best)\n\t\t\t#choosing to not draw line from current element of array1\n            op2=dfs(s1+1,s2)\n\t\t\t#returning max of both options.\n            return max(op2,best)\n        return dfs(0,0)"}
{"prompt": "def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        blocked = set(map(tuple, blocked))\n        \n        def fn(x, y, tx, ty): \n            \"\"\"Return True if (x, y) is not looped from (tx, ty).\"\"\"\n            seen = {(x, y)}\n            queue = [(x, y)]\n            level = 0 \n            while queue: \n                level += 1\n                if level > 200: return True \n                newq = []\n                for x, y in queue: \n                    if (x, y) == (tx, ty): return True \n                    for xx, yy in (x-1, y), (x, y-1), (x, y+1), (x+1, y): \n                        if 0 <= xx < 1e6 and 0 <= yy < 1e6 and (xx, yy) not in blocked and (xx, yy) not in seen: \n                            seen.add((xx, yy))\n                            newq.append((xx, yy))\n                queue = newq\n            return False \n        \n        return fn(*source, *target) and fn(*target, *source)"}
{"prompt": "def isBoomerang(self, points: List[List[int]]) -> bool:\n        x1, y1 = points[0]\n        x2, y2 = points[1]\n        x3, y3 = points[2]\n        \n        area = abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2))/2\n        return area != 0"}
{"prompt": "def bstToGst(self, root: TreeNode) -> TreeNode:\n        s = 0\n        def f(root):\n            if root is None: return\n            nonlocal s\n            f(root.right)\n            #print(s,root.val)\n            s = s + root.val\n            root.val = s\n            f(root.left)\n        f(root)\n        return root"}
{"prompt": "def minScoreTriangulation(self, A: List[int]) -> int:\n    \tSP, LA = [[0]*50 for i in range(50)], len(A)\n    \tdef MinPoly(a,b):\n    \t\tL, m = b - a + 1, math.inf; \n    \t\tif SP[a][b] != 0 or L < 3: return SP[a][b]\n    \t\tfor i in range(a+1,b): m = min(m, A[a]*A[i]*A[b] + MinPoly(a,i) + MinPoly(i,b))\n    \t\tSP[a][b] = m; return SP[a][b]\n    \treturn MinPoly(0,LA-1)"}
{"prompt": "def numMovesStonesII(self, stones: list[int]) -> list[int]:\n        \"\"\"\n        1. For the higher bound, it is determined by either moving the leftmost\n            to the right side, or by moving the rightmost to the left side:\n            1.1 If moving leftmost to the right side, the available moving\n                positions are A[n - 1] - A[1] + 1 - (n - 1) = \n                A[n - 1] - A[1] - n + 2\n            1.2 If moving rightmost to the left side, the available moving\n                positions are A[n - 2] - A[0] + 1 - (n - 1) = \n                A[n - 2] - A[0] - n + 2.\n        2. For the lower bound, we could use sliding window to find a window\n            that contains the most consecutive stones (A[i] - A[i - 1] = 1):\n            2.1 Generally the moves we need are the same as the number of\n                missing stones in the current window.\n            2.3 When the window is already consecutive and contains all the\n                n - 1 stones, we need at least 2 steps to move the last stone\n                into the current window. For example, 1,2,3,4,10:\n                2.3.1 We need to move 1 to 6 first as we are not allowed to\n                    move 10 to 5 as it will still be an endpoint stone.\n                2.3.2 Then we need to move 10 to 5 and now the window becomes\n                    2,3,4,5,6.\n        \"\"\"\n        A, N = sorted(stones), len(stones)\n        maxMoves = max(A[N - 1] - A[1] - N + 2, A[N - 2] - A[0] - N + 2)\n        minMoves = N\n\n        # Calculate minimum moves through sliding window.\n        start = 0\n        for end in range(N):\n            while A[end] - A[start] + 1 > N:\n                start += 1\n\n            if end - start + 1 == N - 1 and A[end] - A[start] + 1 == N - 1:\n                # Case: N - 1 stones with N - 1 positions.\n                minMoves = min(minMoves, 2)\n            else:\n                minMoves = min(minMoves, N - (end - start + 1))\n\n        return [minMoves, maxMoves]"}
{"prompt": "def isRobotBounded(self, instructions: str) -> bool:\n        x = y = 0\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        i = 0\n        while True:\n            for do in instructions:\n                if do == 'G':\n                    x += directions[i][0]\n                    y += directions[i][1]\n                elif do == 'R':\n                    i = (i + 1) % 4\n                else:\n                    i = (i - 1) % 4\n                    \n            if i == 0:\n                return x == 0 and y == 0"}
{"prompt": "def gardenNoAdj(self, N: int, paths: List[List[int]]) -> List[int]:\n        G = defaultdict(list)\n        for path in paths:\n            G[path[0]].append(path[1])\n            G[path[1]].append((path[0]))\n        colored = defaultdict()\n\n        def dfs(G, V, colored):\n            colors = [1, 2, 3, 4]\n            for neighbour in G[V]:\n                if neighbour in colored:\n                    if colored[neighbour] in colors:\n                        colors.remove(colored[neighbour])\n            colored[V] = colors[0]\n\n        for V in range(1, N + 1):\n            dfs(G, V, colored)\n\n        ans = []\n        for V in range(len(colored)):\n            ans.append(colored[V + 1])\n\n        return ans"}
{"prompt": "def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        dp = [0]*n\n        \n        # handle the first k indexes differently\n        for j in range(k): dp[j]=max(arr[:j+1])*(j+1)\n        \n        # we can get rid of index i by running i times\n        for j in range(k,n):\n            curr = []\n            for m in range(k):\n                curr.append(dp[j-m-1] + max(arr[(j-m):(j+1)]) * (m+1))\n            dp[j] = max(curr)\n\n        return dp[-1]"}
{"prompt": "def longestDupSubstring(self, s: str) -> str:\n        length = len(s)\n        l,r = 0, length-1        \n        result = []\n        while l<r:\n            mid = (l+r)//2\n            d = {}\n            max_string = \"\"\n            for i in range(length-mid):\n                    if d.get(s[i:i+mid+1],0):\n                        max_string = s[i:i+mid+1]\n                        break\n                    d[s[i:i+mid+1]] = 1\n            if max_string:\n                l = mid+1\n                result.append(max_string)\n            else:\n                r = mid\n        return max(result,key=len) if result else \"\""}
{"prompt": "def lastStoneWeight(self, stones: List[int]) -> int:\n        stones.sort()\n        while stones:\n            s1 = stones.pop()  # the heaviest stone\n            if not stones:  # s1 is the remaining stone\n                return s1\n            s2 = stones.pop()  # the second-heaviest stone; s2 <= s1\n            if s1 > s2:\n                # we need to insert the remaining stone (s1-s2) into the list\n                pass\n            # else s1 == s2; both stones are destroyed\n        return 0  # if no more stones remain"}
{"prompt": "def removeDuplicates(self, s: str) -> str:\n        stack=[s[0]]\n        for i in range(1,len(s)):\n            if(stack and stack[-1]==s[i]):\n                stack.pop()\n            else:\n                stack.append(s[i])\n        return \"\".join(stack)"}
{"prompt": "def longestStrChain(self, words: List[str]) -> int:\n        \n        words.sort(key=len)\n        dic = {}\n        \n        for i in words:\n            dic[ i ] = 1\n            \n            for j in range(len(i)):\n                \n                # creating words by deleting a letter\n                successor = i[:j] + i[j+1:]\n                if successor in dic:\n                    dic[ i ] = max (dic[i], 1 + dic[successor])\n        \n        res = max(dic.values())\n        return res"}
{"prompt": "def lastStoneWeightII(self, stones: List[int]) -> int:\n        \n        @lru_cache(None)\n        def fn(i, v): \n            \"\"\"Return minimum weight of stones[i:] given existing weight.\"\"\"\n            if i == len(stones): return abs(v)\n            return min(fn(i+1, v - stones[i]), fn(i+1, v + stones[i]))\n        \n        return fn(0, 0)"}
{"prompt": "def heightChecker(self, heights: List[int]) -> int:\n   \n        max_val = max(heights)\n        \n        # Create frequency table\n        freq = [0] * (max_val + 1)\n        for num in heights: freq[num] += 1\n        for num in range(1, len(freq)): freq[num] += freq[num-1]\n\n        # Create places table\n        places = [0] * len(heights)\n        for num in heights:\n            places[freq[num]-1] = num\n            freq[num] -= 1\n\n        return sum([a!=b for a, b in zip(heights, places)])"}
{"prompt": "def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\n        # a sliding window approach\n        currsum = 0\n        # first store the sum as if the owner has no super power\n        for i in range(len(grumpy)):\n            if not grumpy[i]:\n                currsum += customers[i]\n        \n        # now assuming he has the power, take the first window \n        # and add to the previous sum\n        for i in range(X):\n            if grumpy[i]:\n                currsum += customers[i]\n        \n        maxsum = currsum\n        \n        # Now the sliding window starts\n        # i and j are the two opposite ends of the window\n        i = 0\n        j = X\n        while j < len(customers):\n            if grumpy[j]:\n                currsum += customers[j]\n            if grumpy[i]:\n                currsum -= customers[i]\n\t\t\t# we subtract above as the window has already passed over that customer\n            if currsum > maxsum:\n                maxsum = currsum\n            i += 1\n            j += 1\n        return maxsum"}
{"prompt": "def prevPermOpt1(self, nums: List[int]) -> List[int]:\n\t\tn = len(nums)-1\n\t\tleft = n\n\n    // find first non-decreasing number\n    while left >= 0 and nums[left] >= nums[left-1]:\n        left -= 1\n        \n\t// if this hits, it means we have the smallest possible perm \n    if left <= 0:\n        return nums\n\t\n\t// the while loop above lands us  at +1, so k is the actual value\n    k = left - 1\n    \n    // find the largest number that's smaller than k \n    // while skipping duplicates\n    right = n\n    while right >= left:\n        if nums[right] < nums[k] and nums[right] != nums[right-1]:\n            nums[k], nums[right] = nums[right], nums[k]\n            return nums\n            \n        right -= 1\n   \n    return nums"}
{"prompt": "def rearrangeBarcodes(self, B: List[int]) -> List[int]:\n        L, A, i = len(B), [0]*len(B), 0\n        for k,v in collections.Counter(B).most_common():\n            for _ in range(v):\n                A[i], i = k, i + 2\n                if i >= L: i = 1\n        return A\n\n\n\ndef rearrangeBarcodes(self, B: List[int]) -> List[int]:\n        L, C = len(B), collections.Counter(B)\n        B.sort(key = lambda x: (C[x],x))\n        B[1::2], B[::2] = B[:L//2], B[L//2:]\n        return B\n\t\t\n\t\t\n- Junaid Mansuri"}
{"prompt": "def gcdOfStrings(self, s1: str, s2: str) -> str:\n        return s1[:math.gcd(len(s1), len(s2))] if s1 + s2 == s2 + s1 else ''"}
{"prompt": "def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n    \n    dic = defaultdict(int)\n    for row in matrix:\n        local=[]\n        for c in row:\n            local.append(c^row[0])\n        dic[tuple(local)]+=1\n    \n    return max(dic.values())"}
{"prompt": "def addNegabinary(self, arr1: List[int], arr2: List[int]) -> List[int]:\n        ans = list()\n        m, n = len(arr1), len(arr2)\n        i, j = m-1, n-1\n        def add(a, b):                                         # A helper function to add -2 based numbers\n            if a == 1 and b == 1:\n                cur, carry = 0, -1\n            elif (a == -1 and b == 0) or (a == 0 and b == -1):    \n                cur = carry = 1\n            else:    \n                cur, carry = a+b, 0\n            return cur, carry                                  # Return current value and carry\n        carry = 0\n        while i >= 0 or j >= 0:                                # Two pointers from right side\n            cur, carry_1, carry_2 = carry, 0, 0\n            if i >= 0:\n                cur, carry_1 = add(cur, arr1[i])\n            if j >= 0:    \n                cur, carry_2 = add(cur, arr2[j])\n            carry = carry_1 + carry_2\n            ans.append(cur)\n            i, j = i-1, j-1\n        ans = [1,1] + ans[::-1] if carry == -1 else ans[::-1]  # Add [1, 1] if there is a carry -1 leftover\n        for i, v in enumerate(ans):                            # Remove leading zero and return\n            if v == 1:\n                return ans[i:]\n        else:\n            return [0]"}
{"prompt": "def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:\n        # find the rows and columns of the matrix\n        n,m = len(matrix) , len(matrix[0])\n        # find the prefix sum for each row\n        for i in range(n):\n            for j in range(1,m):\n                matrix[i][j] += matrix[i][j-1]\n        ans = 0\n        # fix the left boundary of the column\n        for start in range(m):\n            # fix the right boundary of the column\n            for end in range(start,m):\n                # a dictionary to map data\n                d = defaultdict(lambda:0)\n                d[0] = 1\n                summ = 0\n                # now we do check at each row\n                for i in range(n):\n                    curr = matrix[i][end]\n                    if start > 0: curr -= matrix[i][start-1]\n                    summ += curr\n                    ans += d[summ - target]\n                    d[summ] += 1\n        return ans"}
{"prompt": "def findOcurrences(self, text: str, first: str, second: str) -> List[str]:\n        ans, stack = [], []\n        for w in text.split():\n            if len(stack) > 1 and stack[-2] == first and stack[-1] == second:\n                ans.append(w)\n            stack.append(w)\n        return ans"}
{"prompt": "def numTilePossibilities(self, tiles: str) -> int:\n        record = [0] * 26\n        for tile in tiles: record[ord(tile)-ord('A')] += 1\n        def dfs(record):\n            s = 0\n            for i in range(26):\n                if not record[i]: continue\n                record[i] -= 1\n                s += dfs(record) + 1 \n                record[i] += 1\n            return s    \n        return dfs(record)"}
{"prompt": "def sufficientSubset(self, root: TreeNode, limit: int, pathSum = 0) -> TreeNode:\n        if not root: return None\n        if not root.left and not root.right:\n            if pathSum + root.val < limit:\n                return None\n            return root\n        root.left = self.sufficientSubset(root.left, limit, pathSum + root.val)\n        root.right = self.sufficientSubset(root.right, limit, pathSum + root.val)\n        if not root.left and not root.right:\n            return None\n        return root"}
{"prompt": "def smallestSubsequence(self, s: str) -> str:\n        loc = {x: i for i, x in enumerate(s)}\n        stack = []\n        for i, x in enumerate(s): \n            if x not in stack: \n                while stack and x < stack[-1] and i < loc[stack[-1]]: stack.pop()\n                stack.append(x)\n        return \"\".join(stack)"}
{"prompt": "def duplicateZeros(self, arr: List[int]) -> None:\n\t\ti = 0\n\t\tn = len(arr)\n\t\twhile(i<n):\n\t\t\tif arr[i]==0:\n\t\t\t\tarr.pop()\n\t\t\t\tarr.insert(i,0)\n\t\t\t\ti+=1\n\t\t\ti+=1"}
{"prompt": "def largestValsFromLabels(self, values: List[int], labels: List[int], num_wanted: int, use_limit: int) -> int:\n        ans = 0\n        freq = {}\n        for value, label in sorted(zip(values, labels), reverse=True):\n            if freq.get(label, 0) < use_limit: \n                ans += value\n                num_wanted -= 1\n                if not num_wanted: break \n                freq[label] = 1 + freq.get(label, 0)\n        return ans"}
{"prompt": "def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\n        # check if source and target are not clear cells\n        if grid[0][0] != 0 or grid[-1][-1] != 0:\n            return -1\n        \n        N = len(grid)            \n        # offsets required for all 8 directions\n        offsets = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n        \n        q = deque()\n        q.append((0,0)) # starting point\n        visited = {(0, 0)}\n        \n        \n        # finds unvisited clear cells using 8 offsets\n        def get_neighbours(x,y):\n            for x_offset, y_offset in offsets:\n                new_row = x + x_offset\n                new_col = y + y_offset\n                \n                if 0 <= new_row < N and 0 <= new_col < N and not grid[new_row][new_col] and (new_row, new_col) not in visited:\n                    yield (new_row, new_col)                                                \n            \n        \n        current_distance = 1 # start with one clear cell\n        # standard iterative BFS traversal\n        while q:\n            length = len(q)\n            \n            # loop through all the cells at the same distance\n            for _ in range(length):\n                row, col = q.popleft()\n                \n                if row == N-1 and col==N-1: # reached target\n                    return current_distance\n                \n                # loop though all valid neignbours\n                for p in get_neighbours(row, col):\n                    visited.add(p)\n                    q.append(p)\n                                    \n            current_distance+=1 # update the level or distance from source\n        \n        return -1"}
{"prompt": "def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        n,m = len(str1),len(str2)\n        dp = [[0 for j in range(m+1)]for i in range(n+1)]\n        for i in range(1,n+1):\n            for j in range(1,m+1):\n                if str1[i-1] == str2[j-1]:\n                    dp[i][j] = 1+dp[i-1][j-1]\n                else:\n                    dp[i][j] = max(dp[i-1][j],dp[i][j-1])\n        i,j = n,m\n        ans = \"\"\n        while(i>0 and j>0):\n            if str1[i-1] == str2[j-1]:\n                ans += str1[i-1]\n                i -= 1\n                j -= 1\n            else:\n                if(dp[i-1][j] > dp[i][j-1]):\n                    ans += str1[i-1]\n                    i -= 1\n                else:\n                    ans += str2[j-1]\n                    j -= 1\n        while(i>0):\n            ans += str1[i-1]\n            i -= 1\n        while(j>0):\n            ans += str2[j-1]\n            j -= 1\n        return ans[::-1]"}
{"prompt": "def sampleStats(self, count: List[int]) -> List[float]:\n        return [\n            #Minimum\n            min(i for i,c in enumerate(count) if c != 0),\n            #Maximum\n            max(i for i,c in enumerate(count) if c != 0),\n            #Mean\n            sum(i*c for i,c in enumerate(count)) / sum(c for c in count if c != 0),\n            #Media\n            (lambda total:\n                (\n                    next(i for i,s in enumerate(itertools.accumulate(count)) if s >= total//2+1)+\n                    next(i for i,s in enumerate(itertools.accumulate(count)) if s >= total//2+total%2)\n                )/2\n            )(sum(c for c in count if c != 0)),\n            #Mode\n            max(((i,c) for i,c in enumerate(count) if c != 0),key=(lambda x: x[1]))[0]\n        ]"}
{"prompt": "def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        path = [0]*1000\n        \n        for num, a, b in trips:\n            for loc in range (a, b):\n                path[loc] += num\n                if path[loc] > capacity: return False\n                \n        return True"}
{"prompt": "def findInMountainArray(self, target: int, mountain_arr: 'MountainArray') -> int:\n        \n        def fn(lo, hi, mult): \n            \"\"\"Return index of target between lo (inclusive) and hi (exlusive).\"\"\"\n            while lo < hi: \n                mid = lo + hi >> 1\n                if mountain_arr.get(mid) == target: return mid \n                elif mountain_arr.get(mid)*mult < target*mult: lo = mid + 1\n                else: hi = mid \n            return -1 \n        \n        lo, hi = 0, mountain_arr.length()\n        while lo < hi: \n            mid = lo + hi >> 1\n            if mid and mountain_arr.get(mid-1) < mountain_arr.get(mid): lo = mid + 1\n            else: hi = mid \n        if (x := fn(0, lo, 1)) != -1: return x \n        if (x := fn(lo, mountain_arr.length(), -1)) != -1: return x \n        return -1"}
{"prompt": "def braceExpansionII(self, expression: str) -> List[str]:\n        stack,res,cur=[],[],[]\n        for i in range(len(expression)):\n            v=expression[i]\n            if v.isalpha():\n                cur=[c+v for c in cur or ['']]\n            elif v=='{':\n                stack.append(res)\n                stack.append(cur)\n                res,cur=[],[]\n            elif v=='}':\n                pre=stack.pop()\n                preRes=stack.pop()\n                cur=[p+c for c in res+cur for p in pre or ['']]\n                res=preRes\n            elif v==',':\n                res+=cur\n                cur=[]\n        return sorted(set(res+cur))"}
{"prompt": "def distributeCandies(self, candies: int, num_people: int) -> List[int]:\n        # create an array of size num_people and initialize it with 0\n        list_people = [0] * num_people\n        \n        # starting value\n        index = 1\n        \n        # iterate until the number of candies are more than 0\n        while candies > 0:\n            \n            # if candies are more than index value, add the index value to the location \n            if candies > index:\n                # we are using mod operation by the num_people to locate the index of the array\n                # we are subtracting by 1 because the array index starts at 0\n                list_people[(index - 1) % num_people] += index\n            else:\n                # if candies are less than index value, add all remaining candies to location\n                list_people[(index - 1) % num_people] += candies\n            \n            # subtract the candies with index values\n            candies -= index\n            \n            # increment the index values\n            index += 1\n        \n        # return the resultant array\n        return(list_people)"}
{"prompt": "def pathInZigZagTree(self, label: int) -> List[int]:\n        rows = [(1, 0)] #row represented by tuple (min_element_in_row, is_neg_order)\n        while rows[-1][0]*2 <= label:\n            rows.append((rows[-1][0]*2, 1 - rows[-1][1]))\n            \n        power, negOrder = rows.pop()\n        \n        res = []\n        while label > 1:\n            res.append(label)\n                \n            if negOrder:\n                # adjust label position and find parent with division by 2\n                # a, b - range of current row \n                a, b = power, power*2 -1\n                label = (a + (b - label))//2\n            else:\n                # divide label by 2 and adjust parent position\n                # a, b - range of previous row\n                a, b = power//2, power - 1\n                label = b - (label//2 - a)\n                \n            power, negOrder = rows.pop()\n            \n                          \n        res.append(1)\n                          \n        return res[::-1]"}
{"prompt": "def minHeightShelves(self, books: List[List[int]], shelfWidth: int) -> int:\n        n = len(books)\n        dp = [sys.maxsize] * n\n        dp[0] = books[0][1]                                # first book will always on it's own row\n        for i in range(1, n):                              # for each book\n            cur_w, height_max = books[i][0], books[i][1]\n            dp[i] = dp[i-1] + height_max                   # initialize result for current book `dp[i]`\n            for j in range(i-1, -1, -1):                   # for each previou `book[j]`, verify if it can be placed in the same row as `book[i]`\n                if cur_w + books[j][0] > shelfWidth: break\n                cur_w += books[j][0]\n                height_max = max(height_max, books[j][1])  # update current max height\n                dp[i] = min(dp[i], (dp[j-1] + height_max) if j-1 >= 0 else height_max) # always take the maximum heigh on current row\n        return dp[n-1]"}
{"prompt": "operands = {\"!\", \"&amp;\", \"|\", \"t\", \"f\"}\n    values = {\"t\", \"f\"}\n\n    def parseBoolExpr(self, expression: str) -> bool:\n        stack = []\n        for c in expression:\n            if c == \")\":\n                val = stack.pop()\n                args = set()\n                while val in Solution.values:\n                    args.add(val)\n                    val = stack.pop()\n                if val == \"!\":\n                    stack.append(\"f\" if \"t\" in args else \"t\")\n                elif val == \"&amp;\":\n                    stack.append(\"f\" if \"f\" in args else \"t\")\n                elif val == \"|\":\n                    stack.append(\"t\" if \"t\" in args else \"f\")\n            elif c in Solution.operands:\n                stack.append(c)\n        return stack[0] == \"t\""}
{"prompt": "def defangIPaddr(self, address: str) -> str:\n        address=address.replace(\".\",\"[.]\")\n        return address"}
{"prompt": "def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:\n        res = [0]*n\n        for first, last, seat in bookings:\n            res[first - 1] += seat\n            if last < n:\n                res[last] -= seat\n        return accumulate(res)"}
{"prompt": "def delNodes(self, root: TreeNode, to_delete: List[int]) -> List[TreeNode]:\n        to_delete = set(to_delete) # O(1) lookup \n        \n        def fn(node, pval):\n            \"\"\"Return node upon deletion of required values.\"\"\"\n            if not node: return \n            if node.val in to_delete: \n                node.left = fn(node.left, None)\n                node.right = fn(node.right, None)\n                return \n            else: \n                if not pval: ans.append(node)\n                node.left = fn(node.left, node.val)\n                node.right = fn(node.right, node.val)\n                return node \n        \n        ans = []\n        fn(root, None)\n        return ans"}
{"prompt": "def maxDepthAfterSplit(self, seq: str) -> List[int]:\n        ans=[]\n        prev=1\n        for i in seq:\n            if i=='(':\n                if prev==0:\n                    ans.append(1)\n                else:\n                    ans.append(0)\n            else:\n                ans.append(prev)\n            if prev==0:\n                prev=1\n            else:\n                prev=0\n        return ans"}
{"prompt": "def relativeSortArray(self, arr1: List[int], arr2: List[int]) -> List[int]:\n\t\t# initialise a dictionary since we're going to want to count the occurences of each element in arr1\n        dic = {}\n\t\t# this loop populates the dictionary with the number of occurences for each element\n        for elem in arr1:\n            if dic.get(elem) is None:\n                dic[elem] = 1\n            else:\n                dic[elem] = dic[elem] + 1\n\t\t# initialise a new list to store the values which exist in both arr2 and arr1\n        output = []\n\t\t# populate output with the elements multiplied by their occurences (e.g. [1]*2 = [1, 1])\n        for elem in arr2:\n            output += [elem]*dic[elem]\n\t\t# initialise a new list to store the elements which are in arr1 but not arr2\n        extra_output = []\n\t\t# populate extra_output with these elements multiplied by their occurences. \n\t\t# Note: set(arr1)-set(arr2) provides us with the set of numbers which exist in arr1 but not in arr2\n        for elem in set(arr1)-set(arr2):\n            extra_output += [elem]*dic[elem]\n\t\t# return the first list and the sorted second list\n        return output + sorted(extra_output)"}
{"prompt": "def ht(self, node):\n        if not node:\n            return 0\n        return max(self.ht(node.left), self.ht(node.right)) + 1\n    \n    def dfs(self, node):\n        if not node:\n            return None\n        left, right = self.ht(node.left), self.ht(node.right)\n        if left == right:\n            return node\n        if left > right:\n            return self.dfs(node.left)\n        if left < right:\n            return self.dfs(node.right)\n\n    def lcaDeepestLeaves(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        return self.dfs(root)"}
{"prompt": "def longestWPI(self, hours: List[int]) -> int:\n    \n    dic = defaultdict(int)\n    dummy = [1 if hours[0]>8 else -1]\n    for h in hours[1:]:\n        c = 1 if h>8 else -1\n        dummy.append(dummy[-1]+c)\n    \n    res = 0\n    for i in range(len(dummy)):\n        if dummy[i]>0:\n            res = max(res,i+1)\n        else:\n            if dummy[i]-1 in dic:\n                res = max(res,i-dic[dummy[i]-1])\n            if dummy[i] not in dic:\n                dic[dummy[i]] = i\n    \n    return res"}
{"prompt": "def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        \n        # Firstly, convert all the sublists in people into sets for easier processing.\n        for i, skills in enumerate(people):\n            people[i] = set(skills)\n        \n        # Remove all skill sets that are subset of another skillset, by replacing the subset with an\n        # empty set. We do this rather than completely removing, so that indexes aren't \n        # disrupted (which is a pain to have to sort out later).\n        for i, i_skills in enumerate(people):\n            for j, j_skills in enumerate(people):\n                if i != j and i_skills.issubset(j_skills):\n                    people[i] = set()\n        \n        # Now build up a dictionary of skills to the people who can perform them. The backtracking algorithm\n        # will use this.\n        skills_to_people = collections.defaultdict(set)\n        for i, skills in enumerate(people):\n            for skill in skills:\n                skills_to_people[skill].add(i)\n            people[i] = set(skills)\n        \n        # Keep track of some data used by the backtracking algorithm.\n        self.unmet_skills = set(req_skills) # Backtracking will remove and readd skills here as needed.\n        self.smallest_length = math.inf # Smallest team length so far.\n        self.current_team = [] # Current team members.\n        self.best_team = [] # Best team we've found, i,e, shortest team that covers skills/\n        \n\t\t# Here is the backtracking algorithm.\n        def meet_skill(skill=0):\n\t\t\t# Base case: All skills are met.\n            if not self.unmet_skills:\n\t\t\t\t# If the current team is smaller than the previous we found, update it.\n                if self.smallest_length > len(self.current_team):\n                    self.smallest_length = len(self.current_team)\n                    self.best_team = self.current_team[::] # In Python, this makes a copy of a list.\n                return # So that we don't carry out the rest of the algorithm.\n                        \n            # If this skill is already met, move onto the next one.\n            if req_skills[skill] not in self.unmet_skills:\n                return meet_skill(skill + 1)\n\t\t\t\t# Note return is just to stop rest of code here running. Return values\n\t\t\t\t# are not caught and used.\n            \n            # Otherwise, consider all who could meet the current skill.\n            for i in skills_to_people[req_skills[skill]]:\n                \n\t\t\t\t# Add this person onto the team by updating the backtrading data.\n                skills_added_by_person = people[i].intersection(self.unmet_skills)\n                self.unmet_skills = self.unmet_skills - skills_added_by_person\n                self.current_team.append(i)\n                \n\t\t\t\t# Do the recursive call to further build the team.\n                meet_skill(skill + 1)\n                \n                # Backtrack by removing the person from the team again.\n                self.current_team.pop()\n                self.unmet_skills = self.unmet_skills.union(skills_added_by_person)\n        \n\t\t# Kick off the algorithm.\n        meet_skill()        \n        return self.best_team"}
{"prompt": "def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\n        m = collections.defaultdict(int)\n        ans = 0\n        for a, b in dominoes:\n            if a > b: a, b = b, a\n            v = 10*a + b\n            if v in m:\n                ans += m[v]\n            m[v] += 1\n        return ans"}
{"prompt": "def shortestAlternatingPaths(self, n, red_edges, blue_edges):\n        neighbors = [[[], []] for _ in range(n)]\n        ans = [[0, 0]]+[[2*n, 2*n] for _ in range(n-1)]\n        for u, v in red_edges: neighbors[u][0].append(v)\n        for u, v in blue_edges: neighbors[u][1].append(v)\n        \n        def dfs(u, c, dist):\n            for v in neighbors[u][c]:\n                if dist+1<ans[v][c]:\n                    ans[v][c] = dist+1\n                    dfs(v, 1-c, dist+1)\n                    \n        dfs(0, 0, 0)\n        dfs(0, 1, 0)\n        return [x if x<2*n else -1 for x in map(min, ans)]"}
{"prompt": "def mctFromLeafValues(self, arr: List[int]) -> int:\n    \n    arr = [float('inf')] + arr + [float('inf')]\n    n, res = len(arr), 0\n    \n    while n>3:\n        mi = min(arr)\n        ind = arr.index(mi)\n        \n        if arr[ind-1]<arr[ind+1]:\n            res+=arr[ind-1]*arr[ind]\n        else:\n            res+=arr[ind+1]*arr[ind]\n        \n        arr.remove(mi)\n        n = len(arr)\n    \n    return res"}
{"prompt": "def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\n        minA = minB = minC = minD = math.inf\n        maxA = maxB = maxC = maxD = -math.inf\n\n        for i, (num1, num2) in enumerate(zip(arr1, arr2)):\n            minA = min(minA, i + num1 + num2)\n            maxA = max(maxA, i + num1 + num2)\n            minB = min(minB, i + num1 - num2)\n            maxB = max(maxB, i + num1 - num2)\n            minC = min(minC, i - num1 + num2)\n            maxC = max(maxC, i - num1 + num2)\n            minD = min(minD, i - num1 - num2)\n            maxD = max(maxD, i - num1 - num2)\n        \n        return max(maxA - minA, maxB - minB,\n                   maxC - minC, maxD - minD)"}
{"prompt": "def tribonacci(self, n: int) -> int:\n    \ta, b, c = 0, 1, 1\n    \tfor i in range(n): a, b, c = b, c, a + b + c\n    \treturn a\n\t\t\n\t\t\n- Junaid Mansuri"}
{"prompt": "def __init__(self):\n        board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\n        self.d = {c:(i, j) for i, row in enumerate(board) for j, c in enumerate(row)}\n                \n    def alphabetBoardPath(self, target: str) -> str:\n        ans, prev = '', (0, 0)\n        for c in target:\n            cur = self.d[c]\n            delta_x, delta_y = cur[0]-prev[0], cur[1]-prev[1]\n            h = 'R'*delta_y if delta_y > 0 else 'L'*(-delta_y)                    \n            v = 'D'*delta_x if delta_x > 0 else 'U'*(-delta_x)                    \n            ans += (h+v if cur == (5,0) else v+h) + '!'\n            prev = cur\n        return ans"}
{"prompt": "def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        dp = [[(0, 0)] * (n) for _ in range((m))] \n        for i in range(m):                      # calculate prefix-sum as `hint` section suggested\n            for j in range(n):\n                if not grid[i][j]:\n                    continue\n                dp[i][j] = (dp[i][j][0] + dp[i-1][j][0] + 1, dp[i][j][1] + dp[i][j-1][1] + 1)\n        for win in range(min(m, n)-1, -1, -1):  # for each window size\n            for i in range(m-win):              # for each x-axis\n                for j in range(n-win):          # for each y-axis\n                    if not grid[i][j]: continue # determine whether square of (i, j), (i+win, j+win) is 1-boarded\n                    x1, y1 = dp[i+win][j+win]   # bottom-right corner\n                    x2, y2 = dp[i][j+win]       # upper-right corner\n                    x3, y3 = dp[i+win][j]       # bottom-left corner\n                    x4, y4 = dp[i][j]           # upper-left corner\n                    if y1 - y3 == x1 - x2 == y2 - y4 == x3 - x4 == win:\n                        return (win+1) * (win+1)\n        return 0"}
{"prompt": "def stoneGameII(self, piles: List[int]) -> int:\n        suffix_sum = self._suffix_sum(piles)\n\n        @lru_cache(None)\n        def dfs(pile: int, M: int, turn: bool) -> Tuple[int, int]:\n            # turn: true - alex, false - lee\n            sum_alex, sum_lee = suffix_sum[pile], suffix_sum[pile]\n\n            for next_pile in range(pile + 1, min(pile + 2 * M + 1, len(piles) + 1)):\n                sum_alex_next, sum_lee_next = dfs(\n                    next_pile, max(M, next_pile - pile), not turn\n                )\n                range_sum = suffix_sum[pile] - suffix_sum[next_pile]\n\n                if turn:\n                    if sum_lee_next < sum_lee:\n                        sum_alex = sum_alex_next + range_sum\n                        sum_lee = sum_lee_next\n                else:\n                    if sum_alex_next < sum_alex:\n                        sum_alex = sum_alex_next\n                        sum_lee = sum_lee_next + range_sum\n\n            return sum_alex, sum_lee\n\n        return dfs(0, 1, True)[0]"}
{"prompt": "def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        \n        dp = []\n        \n        # Fill the matrix\n        for _ in range(len(text1)+1):\n            row = []\n            for _ in range(len(text2)+1):\n                row.append(0)\n            \n            dp.append(row)\n        \n        \n        longest_length = 0\n        \n        # Start looping throught the text1 and text2\n        for i in range(1, len(text1)+1):\n            for j in range(1, len(text2)+1):\n                \n                # If characters match\n\t\t\t\t# fill the current cell by adding one to the diagonal value\n                if text1[i-1] == text2[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + 1\n                else:\n                    # If characters do not match\n\t\t\t\t\t# Fill the cell with max value of previous row and column\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n                \n                # Keep track of the MAXIMUM value in the matrix\n                longest_length = max(longest_length, dp[i][j])\n        \n        return longest_length"}
{"prompt": "def movesToMakeZigzag(self, nums: List[int]) -> int:\n        def greedy(nums, small_first=True):\n            if n <= 1: return 0\n            ans = 0\n            for i in range(n-1):\n                if small_first and nums[i] >= nums[i+1]:\n                    ans += nums[i] - (nums[i+1]-1)\n                    nums[i] = nums[i+1] - 1\n                elif not small_first and nums[i] <= nums[i+1]:\n                    ans += nums[i+1] - (nums[i]-1)\n                    nums[i+1] = nums[i] - 1\n                small_first = not small_first\n            return ans    \n        n = len(nums)\n        return min(greedy(nums[:], True), greedy(nums[:], False))"}
{"prompt": "def btreeGameWinningMove(self, root: TreeNode, n: int, x: int) -> bool:\n        first = None\n        def count(node):\n            nonlocal first\n            total = 0\n            if node: \n                if node.val == x: first = node\n                total += count(node.left) + count(node.right) + 1\n            return total\n        \n        s = count(root) # Get total number of nodes, and x node (first player's choice)\n        l = count(first.left) # Number of nodes on left branch \n        r = count(first.right) # Number of nodes on right branch \n        p = s-l-r-1 # Number of nodes on parent branch (anything else other than node, left subtree of node or right subtree of node)\n        return l+r < p or l+p < r or r+p < l"}
{"prompt": "def longestDecomposition(self, text: str) -> int:\n        \n\t\t# Used a prime number generator on the internet to grab a prime number to use.\n        magic_prime = 32416189573\n        \n\t\t# Standard 2 pointer technique variables.\n        low = 0\n        high = len(text) - 1\n        \n\t\t# These are the hash tracking variables.\n\t\tcur_low_hash = 0\n        cur_high_hash = 0\n        cur_hash_length = 0\n        \n\t\t# This is the number of parts we've found, i.e. the k value we need to return.\n\t\tk = 0\n        \n        while low < high:\n            \n\t\t\t# To put the current letter onto our low hash (i.e. the one that goes forward from\n\t\t\t# the start of the string, we shift up the existing hash by multiplying by the base\n\t\t\t# of 26, and then adding on the new character by converting it to a number from 0 - 25.\n            cur_low_hash *= 26 # Shift up by the base of 26.\n            cur_low_hash += ord(text[low]) - 97 # Take away 97 so that it's between 0 and 25.\n            \n\t\t\t\n\t\t\t# The high one, i.e. the one backwards from the end is a little more complex, as we want the \n\t\t\t# hash to represent the characters in forward order, not backwards. If we did the exact same\n\t\t\t# thing we did for low, the string abc would be represented as cba, which is not right.\t\n\t\t\t\n\t\t\t# Start by getting the character's 0 - 25 number.\n\t\t\thigh_char = ord(text[high]) - 97\n\t\t\t\n\t\t\t# The third argument to pow is modular arithmetic. It says to give the answer modulo the\n\t\t\t# magic prime (more on that below). Just pretend it isn't doing that for now if it confuses you. \n            # What we're doing is making an int that puts the high character at the top, and then the \n\t\t\t# existing hash at the bottom.\n\t\t\tcur_high_hash = (high_char * pow(26, cur_hash_length, magic_prime)) + cur_high_hash            \n            \n\t\t\t# Mathematically, we can safely do this. Impressive, huh? I'm not going to go into here, but\n\t\t\t# I recommend studying up on modular arithmetic if you're confused.\n\t\t\t# The algorithm would be correct without doing this, BUT it'd be very slow as the numbers could\n\t\t\t# become tens of thousands of bits long. The problem with that of course is that comparing the\n\t\t\t# numbers would no longer be O(1) constant. So we need to keep them small.\n\t\t\tcur_low_hash %= magic_prime \n            cur_high_hash %= magic_prime\n            \n\t\t\t# And now some standard 2 pointer technique stuff.\n            low += 1\n            high -= 1\n            cur_hash_length += 1\n            \n\t\t\t# This piece of code checks if we currently have a match.\n            # This is actually probabilistic, i.e. it is possible to get false positives.\n            # For correctness, we should be verifying that this is actually correct.\n            # We would do this by ensuring the characters in each hash (using\n\t\t\t# the low, high, and length variables we've been tracking) are\n\t\t\t# actually the same. But here I didn't bother as I figured Leetcode\n\t\t\t# would not have a test case that broke my specific prime.\n\t\t\tif cur_low_hash == cur_high_hash:\n                k += 2 # We have just added 2 new strings to k.\n                # And reset our hashing variables.\n\t\t\t\tcur_low_hash = 0\n                cur_high_hash = 0\n                cur_hash_length = 0\n        \n\t\t# At the end, there are a couple of edge cases we need to address....\n\t\t# The first is if there is a middle character left.\n\t\t# The second is a non-paired off string in the middle.\n        if (cur_hash_length == 0 and low == high) or cur_hash_length > 0:\n            k += 1\n        \n        return k"}
{"prompt": "def dayOfYear(self, date: str) -> int:\n        y, m, d = map(int, date.split('-'))\n        days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n        if (y % 400) == 0 or ((y % 4 == 0) and (y % 100 != 0)): days[1] = 29\n        return d + sum(days[:m-1])"}
{"prompt": "def numRollsToTarget(self, d: int, f: int, target: int) -> int:\n        if d*f < target: return 0        # Handle special case, it speed things up, but not necessary\n        elif d*f == target: return 1     # Handle special case, it speed things up, but not necessary\n        mod = int(10**9 + 7)\n        dp = [[0] * (target+1) for _ in range(d+1)] \n        for j in range(1, min(f+1, target+1)): dp[1][j] = 1\n        for i in range(2, d+1):\n            for j in range(1, target+1):\n                for k in range(1, f+1):\n                    if j - k >= 0: dp[i][j] += dp[i-1][j-k]\n                dp[i][j] %= mod        \n        return dp[-1][-1]"}
{"prompt": "def maxRepOpt1(self, text: str) -> int:\n        first_occurence,last_occurence = {},{}\n        ans,prev,count = 1,0,0\n        n = len(text)\n        \n        for i in range(n):\n            if text[i] not in first_occurence: first_occurence[text[i]] = i\n            last_occurence[text[i]] = i\n            \n        for i in range(n+1):\n            if i < n and text[i] == text[prev]:\n                count += 1\n            else:\n                if first_occurence[text[prev]] < prev or last_occurence[text[prev]] > i : count += 1\n                ans = max(ans,count)\n                count = 1\n                prev = i\n        \n        def someWork(item,before,after):\n            count = 0\n            while before >= 0 and text[before] == item: \n                count += 1\n                before -= 1\n            while after < n and text[after] == item:\n                count += 1\n                after += 1\n            if first_occurence[item] <= before or last_occurence[item] >= after:count+=1\n            return count\n        \n        for i in range(1,n-1):\n            ans = max(ans,someWork(text[i+1],i-1,i+1))\n        return ans"}
{"prompt": "#     O(n^2) || O(1)\n# Runtime: 96ms 97.20% Memory: 14.5mb 84.92%\n    def countCharacters(self, words: List[str], chars: str) -> int:\n        ans=0\n        for word in words:\n            for ch in word:\n                if word.count(ch)>chars.count(ch):\n                    break\n            else:\n                ans+=len(word)\n        \n        return ans"}
{"prompt": "def maxLevelSum(self, root: TreeNode) -> int:\n        \n        queue = deque() #init a queue for storing nodes as we traverse the tree\n        queue.append(root) #first node (level = 1) inserted\n        \n        #bfs = []  #just for understanding- this will be a bfs list to store nodes as we conduct the search, but we don't need it here.\n        \n        level_sum = 0 # for sum of each level\n        level_nodes = 1 # for knowing when a particular level has ended\n        \n        sum_of_levels = [] #list to store all levels sum of nodes\n        \n        while queue: #begin BFS\n            node = queue.popleft() \n            #bfs.append(node)\n            level_sum += node.val #add node \n            \n            if node.left:\n                queue.append(node.left)\n            \n            if node.right:\n                queue.append(node.right)\n            \n            level_nodes -= 1   #reduce level number by 1, as we popped out a node\n            if level_nodes == 0: # if 0, then a level has ended, so calculate the sum\n                sum_of_levels.append(level_sum)\n                level_sum = 0\n                level_nodes = len(queue)\n        \n        return sum_of_levels.index(max(sum_of_levels)) + 1  #return index of max level sum"}
{"prompt": "def maxDistance(self, grid: List[List[int]]) -> int:\n        \n\t\t# The # of rows and # of cols\n        M, N, result = len(grid), len(grid[0]), -1\n        \n\t\t# A list of valid points\n        valid_points = {(i, j) for i in range(M) for j in range(N)}\n        \n\t\t# A double-ended queue of \"land\" cells\n        queue = collections.deque([(i, j) for i in range(M) for j in range(N) if grid[i][j] == 1])\n        \n        # Check if all land, or all water, an edge case\n        if len(queue) == M*N or len(queue) == 0:\n            return -1\n        \n\t\t# BFS\n        while queue:\n\t\t\t\n\t\t\t# One iteration here\n            for _ in range(len(queue)):\n                i, j = queue.popleft()\n                for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\n                    if (x, y) not in valid_points: continue\n                    if grid[x][y] == 1: continue \n                    queue.append((x, y))\n                    grid[x][y] = 1 # We mark water cells as land to avoid visiting them again\n                    \n\t\t\t# Increase the iteration/result count\n            result += 1\n            \n        return result"}
{"prompt": "def lastSubstring(self, s: str) -> str:\n    \tS, L, a = [ord(i) for i in s] + [0], len(s), 1\n    \tM = max(S)\n    \tI = [i for i in range(L) if S[i] == M]\n    \tif len(I) == L: return s\n    \twhile len(I) != 1:\n    \t\tb = [S[i + a] for i in I]\n    \t\tM, a = max(b), a + 1\n    \t\tI = [I[i] for i, j in enumerate(b) if j == M]\n    \treturn s[I[0]:]\n\t\t\n\t\t\n- Junaid Mansuri\n(LeetCode ID)@hotmail.com"}
{"prompt": "def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        invalid = []\n        \n        for i, t1 in enumerate(transactions):\n            name1, time1, amount1, city1 = t1.split(',')\n            if int(amount1) > 1000:\n                invalid.append(t1)\n                continue\n            for j, t2 in enumerate(transactions):\n                if i != j: \n                    name2, time2, amount2, city2 = t2.split(',')\n                    if name1 == name2 and city1 != city2 and abs(int(time1) - int(time2)) <= 60:\n                        invalid.append(t1)\n                        break\n        \n        return invalid"}
{"prompt": "def numSmallerByFrequency(self, queries: List[str], words: List[str]) -> List[int]:\n\t\tdef f(s):\n\t\t\tt = sorted(list(s))[0]\n\t\t\treturn s.count(t)\n\t\tquery = [f(x) for x in queries]\n\t\tword = [f(x) for x in words]\n\t\tm = []\n\t\tfor x in query:\n\t\t\tcount = 0\n\t\t\tfor y in word:\n\t\t\t\tif y>x:\n\t\t\t\t\tcount+=1\n\t\t\tm.append(count)\n\t\treturn m"}
{"prompt": "def removeZeroSumSublists(self, head: Optional[ListNode]) -> Optional[ListNode]:\n\n\t\tdummy = ListNode(0,head)\n\t\tpre = 0\n\t\tdic = {0: dummy}\n\n\t\twhile head:\n\t\t\tpre+=head.val\n\t\t\tdic[pre] = head\n\t\t\thead = head.next\n\n\t\thead = dummy\n\t\tpre = 0\n\t\twhile head:\n\t\t\tpre+=head.val\n\t\t\thead.next = dic[pre].next\n\t\t\thead = head.next\n\n\t\treturn dummy.next"}
{"prompt": "def numPrimeArrangements(self, n: int) -> int:\n        # find number of prime indices\n        # ways to arrange prime indices\n        # is prime indices factorial\n        # amount of non-prime indices is\n        # n - prime indices \n        # the factorial of non - prime indices\n        # times the factorial of prime indices\n        # is the amount of ways to arrange the \n        # prime numbers and i be valid \n        # use helper to find factorial of a number\n        # use helper to see if a number is prime\n        # time O(n ^ 2) space O(1)\n\n        def isPrime(num):\n            if num <= 1:\n                return False\n            for i in range(2, num // 2 + 1):\n                if num % i == 0:\n                    return False\n            return True\n\n        def factorial(num):\n            res = 1\n            for i in range(1, num + 1):\n                res *= i\n            return res\n        \n        primes = 0\n        for num in range(1, n + 1):\n            if isPrime(num):\n                primes += 1\n        return int(factorial(primes) * factorial(n - primes) % (10**9 + 7))"}
{"prompt": "def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n        prefix = [[0]*26]\n        for c in s: \n            elem = prefix[-1].copy()\n            elem[ord(c)-97] += 1\n            prefix.append(elem)\n        \n        ans = []\n        for left, right, k in queries: \n            cnt = sum(1&amp;(prefix[right+1][i] - prefix[left][i]) for i in range(26))\n            ans.append(cnt <= 2*k+1)\n        return ans"}
{"prompt": "def mask(self, word: str) -> int:\n        result = 0\n        for ch in word:\n            result |= 1 << (ord(ch)-ord('a'))\n        return result\n\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\n        word_count = Counter(self.mask(word) for word in words)\n        result = []\n        for puzzle in puzzles:\n            original_mask, first = self.mask(puzzle[1:]), self.mask(puzzle[0])\n            curr_mask, count = original_mask, word_count[first]\n            while curr_mask:\n                count += word_count[curr_mask|first]\n                curr_mask = (curr_mask-1)&amp;original_mask\n            result.append(count)\n        return result"}
{"prompt": "def distanceBetweenBusStops(self, distance: List[int], start: int, destination: int) -> int:\n        a, b = min(start, destination), max(start, destination)\n        return min(sum(distance[a:b]), sum(distance) - sum(distance[a:b]))"}
{"prompt": "def dayOfTheWeek(self, day: int, month: int, year: int) -> str:\n        prev_year = year - 1\n        days = prev_year * 365 + prev_year // 4 - prev_year // 100 + prev_year // 400\n        days += sum([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][:month - 1])\n        days += day\n\n        if month > 2 and ((year % 4 == 0 and year % 100 != 0) or year % 400 == 0):\n            days += 1\n\n        return ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][days % 7]"}
{"prompt": "def maximumSum(self, arr: List[int]) -> int:\n        n = len(arr)\n        #maximum subarray starting from the last element i.e. backwards \n        prefix_sum_ending = [float('-inf')]*n\n        #maximum subarray starting from the first element i.e forwards\n        prefix_sum_starting = [float('-inf')]*n\n        prefix_sum_ending[n-1] = arr[n-1]\n        prefix_sum_starting[0] = arr[0]\n        \n        for i in range(1,n):\n            prefix_sum_starting[i] = max(prefix_sum_starting[i-1]+arr[i], arr[i])\n        for i in range(n-2,-1,-1):\n            prefix_sum_ending[i] = max(prefix_sum_ending[i+1]+arr[i], arr[i])\n           \n        max_without_deletion = max(prefix_sum_starting)\n        max_with_deletion = float('-inf')\n        for i in range(1,n-1):\n            max_with_deletion = max(max_with_deletion, prefix_sum_starting[i-1]+prefix_sum_ending[i+1])\n            \n        return max(max_without_deletion, max_with_deletion)"}
{"prompt": "def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        arr2.sort()\n        \n        @cache\n        def fn(i, prev): \n            \"\"\"Return min ops to make arr1[i:] increasing w/ given previous element.\"\"\"\n            if i == len(arr1): return 0 \n            ans = inf \n            if (prev < arr1[i]): ans = fn(i+1, arr1[i])\n            k = bisect_right(arr2, prev)\n            if k < len(arr2): ans = min(ans, 1 + fn(i+1, arr2[k]))\n            return ans \n        \n        ans = fn(0, -inf)\n        return ans if ans < inf else -1"}
{"prompt": "def maxNumberOfBalloons(self, text: str) -> int:\n        c = collections.Counter(text)\n        return min(c['b'],c['a'],c['l']//2,c['o']//2,c['n'])"}
{"prompt": "def reverseParentheses(self, s: str) -> str:\n        def solve(string):\n            n = len(string)\n            word = \"\"\n            i = 0\n            while i <n:\n                if string[i] == '(':\n                    new = \"\"\n                    count = 0\n                    while True:\n                        count += 1 if string[i] == '(' else -1 if string[i] == ')' else 0\n                        if count == 0: break\n                        new += string[i]\n                        i += 1\n                    i += 1\n                    word += solve(new[1:])\n                else:\n                    word += string[i]\n                    i += 1\n            return word[::-1]\n        return solve(s)[::-1]"}
{"prompt": "def kadane(self, nums):\n        for i in range(1, len(nums)):\n            if nums[i-1] > 0:\n                nums[i] += nums[i-1]\n        return max(max(nums), 0)\n    \n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        sums = sum(arr)\n        mod = 10**9 + 7\n        if k == 1:\n            return self.kadane(arr) % (mod)\n        if sums > 0:\n            return (self.kadane(arr+arr) + (k-2)*sums) % (mod)\n        else:\n            return self.kadane(arr+arr) % (mod)"}
{"prompt": "def criticalConnections(self, n: int, connections: List[List[int]]) -> List[List[int]]:\n        \n        dic = collections.defaultdict(list)\n        for c in connections:\n            u, v = c\n            dic[u].append(v)\n            dic[v].append(u)\n            \n        \n        timer = 0\n        \n        depth, lowest, parent, visited = [float(\"inf\")]*n, [float(\"inf\")]*n, [float(\"inf\")]*n, [False]*n\n        res = []\n        \n        def find(u):\n            \n            nonlocal timer\n            \n            visited[u] = True\n            depth[u], lowest[u] = timer, timer\n            timer += 1\n            \n            for v in dic[u]:   \n                \n                if not visited[v]:\n                    parent[v] = u\n                    find(v)\n                    if lowest[v]>depth[u]:\n                        res.append([u,v])\n                \n                if parent[u]!=v:\n                    lowest[u] = min(lowest[u], lowest[v])\n                \n        find(0)\n        return res"}
{"prompt": "def minimumAbsDifference(self, arr: List[int]) -> List[List[int]]:\n        arr.sort()\n        m = float('inf')\n        out = []\n        for i in range(1, len(arr)):\n            prev = arr[i - 1]\n            curr = abs(prev - arr[i])\n            if curr < m:\n                out = [[prev, arr[i]]]\n                m = curr\n            elif curr == m: out.append([prev, arr[i]])\n        return out"}
{"prompt": "def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\n        # inclusion-exclusion principle\n        ab = a*b//gcd(a, b)\n        bc = b*c//gcd(b, c)\n        ca = c*a//gcd(c, a)\n        abc = ab*c//gcd(ab, c)\n        \n        lo, hi = 1, n*min(a, b, c)\n        while lo < hi: \n            mid = lo + hi >> 1\n            if mid//a + mid//b + mid//c - mid//ab - mid//bc - mid//ca + mid//abc < n: lo = mid + 1\n            else: hi = mid \n        return lo"}
{"prompt": "def union(self, a, b):\n        self.parent[self.find(a)] = self.find(b)\n\t\t\n    def find(self, a):\n        if self.parent[a] != a:\n            self.parent[a] = self.find(self.parent[a])\n\n        return self.parent[a]\n        \n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n\t\t# 1. Union-Find\n        self.parent = list(range(len(s)))\n        for a, b in pairs:\n            self.union(a, b)\n\n\t\t# 2. Grouping\n        group = defaultdict(lambda: ([], []))  \n        for i, ch in enumerate(s):\n            parent = self.find(i)\n            group[parent][0].append(i)\n            group[parent][1].append(ch)\n\n\t\t# 3. Sorting\n        res = [''] * len(s)\n        for ids, chars in group.values():\n            ids.sort()\n            chars.sort()\n            for ch, i in zip(chars, ids):\n                res[i] = ch\n                \n        return ''.join(res)"}
{"prompt": "def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:\n        for i in range(n): \n            if group[i] == -1: group[i] = i + m # re-group \n        \n        graph0 = {} # digraph of groups \n        indeg0 = [0]*(m+n) # indegree of groups \n        \n        graph1 = {} # digrpah of items \n        indeg1 = [0]*n # indegree of items\n        \n        for i, x in enumerate(beforeItems): \n            for xx in x: \n                if group[xx] != group[i]: \n                    graph0.setdefault(group[xx], []).append(group[i])\n                    indeg0[group[i]] += 1\n                graph1.setdefault(xx, []).append(i)\n                indeg1[i] += 1\n        \n        def fn(graph, indeg): \n            \"\"\"Return topological sort of graph using Kahn's algo.\"\"\"\n            ans = []\n            stack = [k for k in range(len(indeg)) if indeg[k] == 0]\n            while stack: \n                n = stack.pop()\n                ans.append(n)\n                for nn in graph.get(n, []):\n                    indeg[nn] -= 1\n                    if indeg[nn] == 0: stack.append(nn)\n            return ans \n        \n        tp0 = fn(graph0, indeg0) \n        if len(tp0) != len(indeg0): return [] \n        \n        tp1 = fn(graph1, indeg1)\n        if len(tp1) != len(indeg1): return []\n        \n        mp0 = {x: i for i, x in enumerate(tp0)}\n        mp1 = {x: i for i, x in enumerate(tp1)}\n        \n        return sorted(range(n), key=lambda x: (mp0[group[x]], mp1[x]))"}
{"prompt": "def uniqueOccurrences(self, A: List[int]) -> bool:\n    \treturn (lambda x: len(x) == len(set(x)))(collections.Counter(A).values())\n\t\t\n\t\t\n- Junaid Mansuri\n(LeetCode ID)@hotmail.com"}
{"prompt": "def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n        n = len(s)\n        cost,start,ans = 0,0,0\n        for i in range(n):\n            diff = abs(ord(s[i]) - ord(t[i]))\n            if cost + diff <= maxCost:\n                # we can increase our sliding window\n                cost += diff\n            else:\n                # we are unable to increase our sliding window\n                ans = max(ans,i - start)\n                while True:\n                    cost -= abs(ord(s[start]) - ord(t[start]))\n                    start += 1\n                    if cost + diff <= maxCost: break\n                if cost + diff > maxCost: start = i + 1\n                else: cost += diff\n                    \n        ans = max(ans,n - start)\n        return ans"}
{"prompt": "def removeDuplicates(self, s: str, k: int) -> str:        \n        stck = [['$', 0]]     # a placeholder to mark stack is empty. This eliminates the need to do an empty check later\n        \n        for c in s:\n            if stck[-1][0] == c:\n                stck[-1][1]+=1 # update occurences count of top element if it matches current character\n                if stck[-1][1] == k:\n                    stck.pop()\n            else:\n                stck.append([c, 1])            \n        \n        return ''.join(c * cnt for c, cnt in stck)"}
{"prompt": "def minimumMoves(self, G: List[List[int]]) -> int:\n    \tN, S, T, V, c = len(G), [(0, 0, 'h')], [], set(), 0\n    \twhile S:\n    \t\tfor i in S:\n    \t\t\tif i in V: continue\n    \t\t\tif i == (N-1, N-2, 'h'): return c\n    \t\t\t(a, b, o), _ = i, V.add(i)\n\t    \t\tif o == 'h':\n    \t\t\t\tif b + 2 != N and G[a][b+2] == 0: T.append((a, b+1, o))\n    \t\t\t\tif a + 1 != N and G[a+1][b] == 0 and G[a+1][b+1] == 0: T.append((a+1, b, o)), T.append((a, b, 'v'))\n    \t\t\telif o == 'v':\n    \t\t\t\tif a + 2 != N and G[a+2][b] == 0: T.append((a+1, b, o))\n    \t\t\t\tif b + 1 != N and G[a][b+1] == 0 and G[a+1][b+1] == 0: T.append((a, b+1, o)), T.append((a, b, 'h'))\n    \t\tS, T, c = T, [], c + 1\n    \treturn -1"}
{"prompt": "def minCostToMoveChips(self, position: List[int]) -> int:\n    \n    dic = Counter([n%2 for n in position])\n    return min(dic[0],dic[1])"}
{"prompt": "def longestSubsequence(self, arr: List[int], difference: int) -> int:\n        \"\"\"\n        dp is a hashtable, dp[x] is the longest subsequence ending with number x\n        \"\"\"\n        dp = {}\n        for x in arr:\n            if x - difference in dp:\n                dp[x] = dp[x-difference] + 1\n            else:\n                dp[x] = 1\n            \n        return max(dp.values())"}
{"prompt": "def getMaximumGold(self, grid: List[List[int]]) -> int:\n\t\tm = len(grid)\n\t\tn = len(grid[0])\n\t\tdef solve(i,j,grid,vis,val):\n\t\t\t# print(i,j,grid,vis,val)\n\t\t\tif(i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 0 or vis[i][j]):\n\t\t\t\t# print(i,m,j,n)\n\t\t\t\treturn val\n\t\t\tvis[i][j] = True\n\t\t\ta = solve(i,j-1,grid,vis,val+grid[i][j])\n\t\t\tb = solve(i,j+1,grid,vis,val+grid[i][j])\n\t\t\tc = solve(i+1,j,grid,vis,val+grid[i][j])\n\t\t\td = solve(i-1,j,grid,vis,val+grid[i][j])\n\t\t\tvis[i][j] = False\n\t\t\treturn max(a,b,c,d)\n\t\tma = 0\n\t\tfor i in range(len(grid)):\n\t\t\tfor j in range(len(grid[0])):\n\t\t\t\tif(grid[i][j] != 0):\n\t\t\t\t\tvis = [[False for i in range(len(grid[0]))] for j in range(len(grid))]\n\t\t\t\t\tma = max(ma,solve(i,j,grid,vis,0))\n\t\treturn ma"}
{"prompt": "def countVowelPermutation(self, n: int) -> int:\n        dp_array = [[0] * 5 for _ in range(n + 1)]\n        dp_array[1] = [1, 1, 1, 1, 1]\n        for i in range(2, n + 1):\n            # a is allowed to follow e, i, or u.\n            dp_array[i][0] = dp_array[i - 1][1] + dp_array[i - 1][2] + dp_array[i - 1][4]\n            # e is allowed to follow a or i.\n            dp_array[i][1] = dp_array[i - 1][0] +  dp_array[i - 1][2]\n            # i is allowed to follow e or o.\n            dp_array[i][2] = dp_array[i - 1][1] + dp_array[i - 1][3]\n            # o is allowed to follow i\n            dp_array[i][3] = dp_array[i - 1][2]\n            # u is allowed to follow i or o.\n            dp_array[i][4] = dp_array[i - 1][2] + dp_array[i - 1][3]\n        return sum(dp_array[n]) % ((10 ** 9) + 7)"}
{"prompt": "def balancedStringSplit(self, S: str) -> int:\n        m = c = 0\n        for s in S:\n            if s == 'L': c += 1\n            if s == 'R': c -= 1\n            if c == 0: m += 1\n        return m"}
{"prompt": "# Time: O(1)\n    # Space: O(1)\n    def queensAttacktheKing(self, queens: List[List[int]], king: List[int]) -> List[List[int]]:\n        queen_set = {(i, j) for i, j in queens}\n        res = []\n        \n        for dx, dy in [[0, 1], [1, 0], [-1, 0], [0, -1], [1, 1], [-1, 1], [1, -1], [-1, -1]]:\n            x, y = king[0], king[1]\n            while 0 <= x < 8 and 0 <= y < 8:\n                x += dx\n                y += dy\n                if (x, y) in queen_set:\n                    res.append([x, y])\n                    break\n        return res"}
{"prompt": "def dieSimulator(self, n: int, rollMax: List[int]) -> int:\n        MOD = 10 ** 9 + 7\n        \n        @lru_cache(None)\n        def func(idx, prevNum, prevNumFreq):\n            if idx == n:\n                return 1\n            \n            ans = 0\n            for i in range(1, 7):\n                if i == prevNum:\n                    if prevNumFreq < rollMax[i - 1]:\n                        ans += func(idx + 1, i, prevNumFreq + 1)\n                        \n                else:\n                    ans += func(idx + 1, i, 1)\n            \n            return ans % MOD\n        \n        return func(0, 0, 0)"}
{"prompt": "def maxEqualFreq(self, nums: List[int]) -> int:\n        cnt, freq, maxfreq, ans = collections.defaultdict(int), collections.defaultdict(int), 0, 0\n        for i, num in enumerate(nums):\n            cnt[num] = cnt.get(num, 0) + 1\n            freq[cnt[num]] += 1\n            freq[cnt[num]-1] -= 1\n            maxfreq = max(maxfreq, cnt[num])\n            if maxfreq == 1:\n                ans = i+1\n            elif maxfreq*freq[maxfreq] == i:\n                ans = i+1\n            elif (maxfreq-1)*(freq[maxfreq-1]+1) == i:\n                ans = i+1\n        return ans"}
{"prompt": "def nthPersonGetsNthSeat(self, n: int) -> float:\n        return 1 if n == 1 else 0.5"}
{"prompt": "def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\n        x1, y1 = coordinates[0]\n        x2, y2 = coordinates[1]\n        for x, y in coordinates[2:]:\n            if (y2 - y1) * (x - x1) != (x2 - x1) * (y - y1):\n                return False\n        return True"}
{"prompt": "def removeSubfolders(self, folder: List[str]) -> List[str]:\n        ans = []\n        for i, path in enumerate(sorted(folder)):\n            if i == 0 or not path.startswith(ans[-1] + \"/\"):\n                ans.append(path)\n        return ans"}
{"prompt": "def balancedString(self, s: str) -> int:\n        counter = collections.Counter(s)\n        n = len(s) // 4\n        extras = {}\n        for key in counter:\n            if counter[key] > n:\n                extras[key] = counter[key] - n\n        \n        if not extras: return 0\n        i = 0\n        res = len(s)\n        for j in range(len(s)):\n            if s[j] in extras:\n                extras[s[j]] -= 1\n            \n            while max(extras.values()) <= 0:\n                res = min(res, j-i+1)\n                if s[i] in extras:\n                    extras[s[i]] += 1\n                i += 1\n                \n                \n        return res"}
{"prompt": "def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n\n    jobs = sorted([(startTime[i],endTime[i],profit[i]) for i in range(len(startTime))])\n    heap=[]\n    cp,mp = 0,0                           # cp->current profit, mp-> max-profit\n    for s,e,p in jobs:\n        while heap and heap[0][0]<=s:\n            et,tmp = heapq.heappop(heap)\n            cp = max(cp,tmp)\n        heapq.heappush(heap,(e,cp+p))\n        mp = max(mp,cp+p)\n    \n    return mp"}
{"prompt": "def findSolution(self, customfunction: 'CustomFunction', z: int) -> List[List[int]]:\n\tx, y = 1, z\n\tpairs = []\n\t\n\twhile x<=z and y>0:\n\t\tcf = customfunction.f(x,y)\n\t\tif cf==z:\n\t\t\tpairs.append([x,y])\n\t\t\tx, y = x+1, y-1\n\t\telif cf > z:\n\t\t\ty -= 1\n\t\telse:\n\t\t\tx += 1\n\treturn pairs"}
{"prompt": "def circularPermutation(self, n: int, start: int) -> List[int]:\n        ans = []\n        for i in range(1<<n): \n            ans.append(start ^ i ^ i >> 1)\n        return ans"}
{"prompt": "def maxLength(self,arr):\n    \n    unique = ['']\n    res = 0\n    for i in range(len(arr)):\n        for j in range(len(unique)):\n            local = arr[i]+unique[j]\n            if len(local)==len(set(local)):\n                unique.append(local)\n                res=max(res,len(local))\n    \n    return res"}
{"prompt": "def tilingRectangle(self, n: int, m: int) -> int:\n        if n == m: return 1\n        depth = [0]*m\n        \n        def fn(x): \n            \"\"\"Explore tiling rectangle area via backtracking.\"\"\"\n            nonlocal ans \n            if x < ans: \n                if min(depth) == n: ans = x # all tiled\n                else: \n                    i = min(depth)\n                    j = jj = depth.index(i) # (i, j)\n                    while jj < m and depth[jj] == depth[j]: jj += 1\n                    k = min(n - i, jj - j)\n                    for kk in reversed(range(1, k+1)): \n                        for jj in range(j, j+kk): depth[jj] += kk\n                        fn(x+1)\n                        for jj in range(j, j+kk): depth[jj] -= kk\n                            \n        ans = max(n, m)\n        fn(0)\n        return ans"}
{"prompt": "def minimumSwap(self, s1: str, s2: str) -> int:\n        if s1 == s2:\n            return 0\n        else:\n            count = 0\n            d = {('xx','yy'):1,('xy','yx'):2,('yy','xx'):1,('yx','xy'):2}\n            x = []\n            y = []\n            for i,j in zip(s1,s2):\n                if i != j:\n                    x.append(i)\n                    y.append(j)\n            x.sort()\n            y.sort(reverse=True)\n            i,j = 0,0\n            if len(x)%2 != 0 or len(y)%2 != 0:\n                return -1\n            while i < len(x) and j < len(y):\n                z = (''.join(x[i:i+2]),''.join(y[i:i+2]))\n                if z not in d:\n                    return -1\n                else:\n                    count += d[z]\n                i += 2\n                j += 2\n            return count"}
{"prompt": "def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        right ,left = 0,0\n        ans = 0 \n        odd_cnt = 0\n        ans = 0\n        cur_sub_cnt = 0\n        for right in range(len(nums)):\n            \n            if nums[right]%2 == 1:\n                odd_cnt += 1\n                cur_sub_cnt = 0\n                \n            while odd_cnt == k:\n                if nums[left]%2 == 1:\n                    odd_cnt -= 1\n                cur_sub_cnt += 1\n                left += 1\n                \n            ans += cur_sub_cnt\n            \n        return ans"}
{"prompt": "def minRemoveToMakeValid(self, s: str) -> str:\n        \n        open = 0\n        s = list(s)\n        \n        for i, c in enumerate(s):\n            if c == '(': open += 1\n            elif c == ')':\n                if not open: s[i] = \"\"\n                else: open -= 1\n        \n        for i in range(len(s)-1, -1, -1):\n            if not open: break\n            if s[i] == '(': s[i] = \"\"; open -= 1\n        \n        return \"\".join(s)"}
{"prompt": "def isGoodArray(self, nums: List[int]) -> bool:\n        import math \n        n = len(nums)\n        if n ==1:\n            return nums[0] ==1\n        d = math.gcd(nums[0], nums[1])\n        for i in range(n):\n            d = math.gcd(nums[i], d)\n        return d ==1"}
{"prompt": "def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:\n        row_data = [0]*m\n        col_data = [0]*n\n        \n        for tup in indices:\n            row_data[tup[0]] = row_data[tup[0]] + 1\n            col_data[tup[1]] = col_data[tup[1]] + 1\n        \n        odd_count = 0 \n        for rowp in range(m):\n            for colp in range(n):\n                val = row_data[rowp] + col_data[colp]\n                if val % 2 != 0:\n                    odd_count+=1\n        \n        return odd_count"}
{"prompt": "def reconstructMatrix(self, upper: int, lower: int, colsum: List[int]) -> List[List[int]]:\n        s, n = sum(colsum), len(colsum)\n        if upper + lower != s: return []\n        u, d = [0] * n, [0] * n\n        for i in range(n):\n            if colsum[i] == 2 and upper > 0 and lower > 0:\n                u[i] = d[i] = 1\n                upper, lower = upper-1, lower-1\n            elif colsum[i] == 1:    \n                if upper > 0 and upper >= lower:\n                    u[i], upper = 1, upper-1\n                elif lower > 0 and lower > upper:\n                    d[i], lower = 1, lower-1\n                else: return []    \n            elif not colsum[i]: continue\n            else: return []\n        return [u, d]"}
{"prompt": "def closedIsland(self, grid: List[List[int]]) -> int:\n    \n    def dfs(i,j):\n        if grid[i][j]==1:\n            return True\n        if i<=0 or i>=m-1 or j<=0 or j>=n-1:\n            return False\n        grid[i][j]=1\n        up=dfs(i-1,j)\n        down=dfs(i+1,j)\n        left=dfs(i,j-1)\n        right=dfs(i,j+1)\n        return left and right and up and down\n     \n    m,n = len(grid),len(grid[0])\n    c=0\n\t# iterate through the grid from 1 to length of grid for rows and columns.\n    # the iteration starts from 1 because if a 0 is present in the 0th column, it can't be a closed island.\n    for i in range(1,m-1):\n        for j in range(1,n-1):\n\t\t\t# if the item in the grid is 0 and it is surrounded by\n            # up, down, left, right 1's then increment the count.\n            if grid[i][j]==0 and dfs(i,j):\n                c+=1\n    return c"}
{"prompt": "def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\n        count , n , dp = [0]*26 , len(words) , {}\n        \n        for c in letters: count[ord(c) - 97] += 1\n        \n        def recursion(index,count):\n            if index == n: return 0\n            \n            tpl = tuple(count)\n            \n            if (index,tpl) in dp: return dp[(index,tpl)]\n            \n            ans = recursion(index + 1, count)\n            \n            flag , tmp , cpy , add = True , defaultdict(int) , count.copy() , 0\n            for c in words[index]: tmp[c] += 1\n            \n            for key in tmp:\n                if tmp[key] <= cpy[ord(key) - 97]:\n                    cpy[ord(key) - 97] -= tmp[key]\n                    add += score[ord(key) - 97] * tmp[key] \n                else:\n                    flag = False\n                    break\n            if flag : ans = max(ans, recursion(index + 1, cpy) + add)\n            \n            dp[(index,tpl)] = ans\n            \n            return ans\n        \n        return recursion(0 , count)"}
{"prompt": "def rotate(self, nums: List[int], k: int) -> None: # From Leetcode Problem 189. Rotate Array\n        n = len(nums)\n        k = k % n\n        nums[:] = nums[n - k:] + nums[:n - k]\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\n        m, n = len(grid), len(grid[0])\n        arr = [i for sublist in grid for i in sublist] # Flatten out the array\n        self.rotate(arr,k) # Rotate the array \n        grid = [[arr[i*n+j] for j in range(n)] for i in range(m)] # Convert Flattened output to 2d Matrix\n        return grid # Return 2d Result"}
{"prompt": "def maxSumDivThree(self, N: List[int]) -> int:\n        A, B, S = heapq.nsmallest(2,[n for n in N if n % 3 == 1]), heapq.nsmallest(2,[n for n in N if n % 3 == 2]), sum(N)\n        if S % 3 == 0: return S\n        if S % 3 == 1: return S - min(A[0], sum(B) if len(B) > 1 else math.inf)\n        if S % 3 == 2: return S - min(B[0], sum(A) if len(A) > 1 else math.inf)\n\t\t\n\t\t\n- Junaid Mansuri\n- Chicago, IL"}
{"prompt": "def minPushBox(self, grid: List[List[str]]) -> int:\n        \n        neighbors = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n        \n        def player_bfs(st_row, st_col, tgt_row, tgt_col):\n            nonlocal rows, cols\n            if (st_row, st_col) == (tgt_row, tgt_col):\n                return True\n            q = deque([(st_row, st_col)]) \n            seen = [[False] * cols for _ in range(rows)]\n            seen[st_row][st_col] = True\n            \n            while q:\n                row, col = q.pop()\n                for r, c in neighbors:\n                    if 0 <= row+r < rows and 0 <= col+c < cols and not seen[row+r][col+c] and grid[row+r][col+c] == '.':\n                        if row+r == tgt_row and col+c == tgt_col:\n                            return True\n                        seen[row+r][col+c] = True\n                        q.appendleft((row+r, col+c))\n            return False\n            \n        def box_bfs(st_row, st_col):\n            nonlocal rows, cols, target\n            q = deque([(st_row, st_col, start[0], start[1], 0)])\n            seen = {st_row, st_col, start[0], start[1]}\n            \n            while q:\n                row, col, prow, pcol, moves = q.pop()\n                grid[row][col] = 'B'\n                for r, c in neighbors:\n                    box_can_move = 0 <= row+r < rows and 0 <= col+c < cols and (row+r, col+c, row-r, col-c) not in seen and grid[row+r][col+c] == '.'\n                    if box_can_move and player_bfs(prow, pcol, row-r, col-c):\n                        if (row+r, col+c) == target:\n                            return moves + 1\n                        seen.add((row+r, col+c, row-r, col-c))\n                        q.appendleft((row+r, col+c, row-r, col-c, moves+1))\n                grid[row][col] = '.'\n            \n            return -1\n        \n        start = target = box = None\n        rows, cols = len(grid), len(grid[0])\n        for r, row in enumerate(grid):\n            for c, pos in enumerate(row):\n                if pos == 'S':\n                    start = (r, c)\n                    grid[r][c] = '.'\n                elif pos == 'T':\n                    target = (r, c)\n                    grid[r][c] = '.'\n                elif pos == 'B':\n                    box = (r, c)\n                    grid[r][c] = '.'\n        \n        return box_bfs(*box)"}
{"prompt": "def minTimeToVisitAllPoints(self, points: List[List[int]]) -> int:\n        timer = 0\n        for i in range(len(points)-1):\n            dx = abs(points[i+1][0] - points[i][0])\n            dy = abs(points[i+1][1] - points[i][1])\n            \n            timer = timer + max(dx,dy)\n        \n        return timer"}
{"prompt": "def countServers(self, grid: List[List[int]]) -> int:\n    \n    m,n = len(grid),len(grid[0])\n    rows = [0]*m\n    cols = [0]*n\n    total = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j]==1:\n                rows[i]+=1\n                cols[j]+=1\n                total+=1\n    \n    cnt = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j]==1 and rows[i]==1 and cols[j]==1:\n                cnt+=1\n    \n    return total-cnt"}
{"prompt": "def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:\n        list_ = []\n        products.sort()\n        for i, c in enumerate(searchWord):\n            products = [ p for p in products if len(p) > i and p[i] == c ]\n            list_.append(products[:3])\n        return list_"}
{"prompt": "def numWays(self, steps: int, arrLen: int) -> int:\n        M = 10 ** 9 + 7\n        @lru_cache(None)\n        def dfs(pos, steps):\n            # if we walk outside the array or use all the steps\n            # then return 0\n            if pos < 0 or pos > steps or pos > arrLen - 1: return 0\n            # if we use all the steps, return 1 only if pos is 0\n            if steps == 0: return pos == 0\n            return (\n                # move to the left\n                dfs(pos - 1, steps - 1) +\n                # stay at current position\n                dfs(pos, steps - 1) +\n                # move to the right\n                dfs(pos + 1, steps - 1) \n            ) % M\n        return dfs(0, steps)"}
{"prompt": "def tictactoe(self, moves: List[List[int]]) -> str:\n        # keep track of the \"net score\" of each row/col/diagonal\n        # player A adds 1 to the \"net score\" of each row/col/diagonal they play in,\n        # player B subtracts 1\n        # scores[0], scores[1] and scores[2] are for rows 0, 1 and 2\n        # scores[3], scores[4] and scores[5] are for cols 0, 1 and 2\n        # scores[6] and scores[7] are for the forward and backward diagonal\n        scores = [0] * 8\n        \n        for i, (row, col) in enumerate(moves):\n            if i % 2 == 0:  # if player A is playing\n                x = 1\n            else:  # if player B is playing\n                x = -1\n            \n            scores[row] += x\n            scores[col + 3] += x\n            if row == col:\n                scores[6] += x\n            if 2 - row == col:\n                scores[7] += x\n            \n        for score in scores:\n            if score == 3:\n                return 'A'\n            elif score == -3:\n                return 'B'\n        \n        return 'Draw' if len(moves) == 9 else 'Pending'"}
{"prompt": "def numOfBurgers(self, tomatoSlices, cheeseSlices):\n\t\t# on the basis of the matrix solution\n        ans = [0.5 * tomatoSlices - cheeseSlices, -0.5 * tomatoSlices + 2 * cheeseSlices]\n\t\t\n\t\t# using the constraints to see if solution satisfies it\n        if 0 <= int(ans[0]) == ans[0] and 0 <= int(ans[1]) == ans[1]:\n            return [int(ans[0]), int(ans[1])]\n        else:\n            return []"}
{"prompt": "def countSquares(self, matrix: List[List[int]]) -> int:\n        \n        count=matrix.count(1)\n        count=0\n        for r in range(len(matrix)):\n            for c in range(len(matrix[0])):\n                if matrix[r][c]==1:\n                    count+=1\n                if r==0 or c==0: continue\n                \n                old_val=matrix[r][c]\n                matrix[r][c]=min(matrix[r-1][c-1], matrix[r][c-1],matrix[r-1][c]) + 1 if matrix[r][c]==1 else 0\n                count= count+ matrix[r][c]- old_val  \n        return count"}
{"prompt": "def palindromePartition(self, s: str, k: int) -> int:\n        \n        \n\t\t#This is the cost function \n        \n        def Cost(s):\n            i,j,c=0,len(s)-1,0\n            \n            while i<j:\n                if s[i]!=s[j]:c+=1\n                j-=1\n                i+=1\n            return c\n        \n        dp={}\n        \n\t\t# Recursion\n\t\t\n        def A(s,k):\n\t\t\t# Memoization\n            if (s,k) in dp:\n                return dp[(s,k)]\n\t\t\t# if k==1 then we want the whole string there is no other way \n            if k==1:\n                return Cost(s)\n            \n\t\t\t#intial value to max\n            f=float('inf')\n            \n            #start checking whole string \n            for x in range(1,len(s)+1):\n                #check wheather if both the strings exist.\n                if len(s[:x]) and len(s[x:]):\n\t\t\t\t\n                    #if exist we find the cost recursively assign min value \n                    f=min(f,Cost(s[:x])+A(s[x:],k-1))\n             #store the min value       \n            dp[(s,k)]=f\n\t\t\t\n            return dp[(s,k)]\n        return A(s,k)\n                \n                    \n            \n            ```"}
{"prompt": "def subtractProductAndSum(self, n: int) -> int:\n        p,s=1,0\n        while n!=0:\n            p*=(n%10)\n            s+=(n%10)\n            n//=10\n        return p-s"}
{"prompt": "# Time: O(n)\n    # Space: O(n)\n    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:\n        res, dic = [], {}\n        for idx, group in enumerate(groupSizes):\n            if group not in dic:\n                dic[group] = [idx]\n            else:\n                dic[group].append(idx)\n            \n            if len(dic[group]) == group:\n                res.append(dic[group])\n                del dic[group]\n        return res"}
{"prompt": "def smallestDivisor(self, nums: List[int], threshold: int) -> int:\n        left, right = 1, max(nums)\n        while left + 1 < right:\n            mid = (left + right) // 2\n            div_sum =  self.get_sum(mid, nums)\n            if div_sum > threshold:\n                left = mid\n            else:\n                right = mid\n        \n        div_sum = self.get_sum(left, nums)\n        if div_sum <= threshold:\n            return left\n        return right\n        \n    \n    def get_sum(self, divisor, nums):\n        res = 0\n        for n in nums:\n            tmp = n // divisor\n            if tmp * divisor < n:\n                tmp += 1\n            \n            res += tmp\n        \n        return res"}
{"prompt": "def minFlips(self, G: List[List[int]]) -> int:\n        M, N = len(G), len(G[0])\n        P = [(i,j) for i,j in itertools.product(range(M),range(N))]\n        for n in range(M*N+1):\n            for p in itertools.permutations(P,n):\n                H = list(map(list,G))\n                for (x,y) in p:\n                    for (i,j) in (x,y-1),(x,y),(x,y+1),(x-1,y),(x+1,y):\n                        if 0 <= i < M and 0 <= j < N: H[i][j] = 1 - H[i][j]\n                if max(max(H)) == 0: return n\n        return -1\n\t\t\n\t\t\n- Junaid Mansuri\n- Chicago, IL"}
{"prompt": "def findSpecialInteger(self, A: List[int]) -> int:\n        return collections.Counter(A).most_common(1)[0][0]\n\t\t\n\nfrom statistics import mode\n\ndef findSpecialInteger(self, A: List[int]) -> int:\n        return mode(A)\n\n\ndef findSpecialInteger(self, A: List[int]) -> int:\n        return max(set(A), key = A.count)\n\t\t\n\t\t\ndef findSpecialInteger(self, A: List[int]) -> int:\n        return (lambda C: max(C.keys(), key = lambda x: C[x]))(collections.Counter(A))\n\t\t\n\t\t\n- Junaid Mansuri\n- Chicago, IL"}
{"prompt": "def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        res, longest = len(intervals), 0\n        srtd = sorted(intervals, key = lambda i: (i[0], -i[1]))\n        \n        for _, end in srtd:\n            if end <= longest:\n                res -= 1\n            else:\n                longest = end\n                \n        return res"}
{"prompt": "def minFallingPathSum(self, grid: List[List[int]]) -> int:\n        rows = len(grid)\n        cols = len(grid[0])\n        min1 = min11 = float('inf')                     # min1 -> minimum , min11 -> second minimum in even indexed row\n        min2 = min22 = float('inf')                     # min2 -> minimum , min22 -> second minimum in odd indexed row\n        for i in range(rows):\n            for j in range(cols):\n                if i==0:\n                    if grid[i][j]<=min1:                # Logic to find minimum and second minimum\n                        min11 = min1\n                        min1 = grid[i][j]\n                    elif grid[i][j]<min11:\n                        min11 = grid[i][j]    \n                else:\n                    if i%2:\n                        if grid[i-1][j]==min1:          # If adjacent -> then add the second minimum value\n                            grid[i][j] += min11\n                        else:                           # Else -> add the minimum value\n                            grid[i][j] += min1\n                        if grid[i][j]<min2:             # Logic to find minimum and second minimum\n                            min22 = min2\n                            min2 = grid[i][j]\n                        elif grid[i][j]<min22:\n                            min22 = grid[i][j]\n                    else:\n                        if grid[i-1][j]==min2:\n                            grid[i][j] += min22\n                        else:\n                            grid[i][j] += min2\n                        if grid[i][j]<min1:             # Logic to find minimum and second minimum\n                            min11 = min1\n                            min1 = grid[i][j]\n                        elif grid[i][j]<min11:\n                            min11 = grid[i][j]    \n            if i%2:                                     # Reset the minimum and second minimum values accordingly\n                min1 = min11 = float('inf')\n            else:\n                min2 = min22 = float('inf')\n        return min(grid[-1])                            # Return the minimum element in last row"}
{"prompt": "def getDecimalValue(self, head: ListNode) -> int:\n        answer = 0\n        while head: \n            answer = 2*answer + head.val \n            head = head.next \n        return answer"}
{"prompt": "def sequentialDigits(self, low: int, high: int) -> List[int]:\n        l=len(str(low))\n        h=len(str(high))\n        ans=[]\n        a=[12,23,34,45,56,67,78,89]\n        t=0\n        while l<=h:\n            for i in a:\n                for j in range(0,l-2):\n                    t=i%10\n                    if i==9:\n                        break\n                    i=int(str(i)+str(t+1))\n                if i%10==0:\n                    break\n                if i>=low and i<=high:\n                    ans.append(i)\n            l+=1\n        return ans"}
{"prompt": "def maxSideLength(self, mat: List[List[int]], threshold: int) -> int:\n        ans = 0            \n        m = len(mat)\n        n = len(mat[0])\n        presum = [[0] * (n+1) for _ in range(m+1)]\n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                presum[i][j] = mat[i-1][j-1] + presum[i][j-1] + presum[i-1][j] - presum[i-1][j-1] \n                lo, hi = 1, min(i, j) + 1\n                while lo < hi:\n                    mid = (lo + hi)//2\n                    cursum = presum[i][j] - presum[i-mid][j] - presum[i][j-mid] + presum[i-mid][j-mid]\n                    if cursum > threshold:\n                        hi = mid\n                    else:\n                        lo = mid + 1\n                ans = max(ans, lo-1)\n        return ans"}
{"prompt": "def shortestPath(self, grid: List[List[int]], k: int) -> int:\n        m, n = len(grid), len(grid[0])\n        \n        # x, y, obstacles, steps\n        q = deque([(0,0,k,0)])\n        seen = set()\n        \n        while q:\n            x, y, left, steps = q.popleft()\n            if (x,y,left) in seen or left<0:\n                continue\n            if (x, y) == (m-1, n-1):\n                return steps\n            seen.add((x,y,left))\n            if grid[x][y] == 1:\n                left-=1\n            for dx, dy in [(1,0), (-1,0), (0,1), (0,-1)]:\n                new_x, new_y = x+dx, y+dy\n                if 0<=new_x<m and 0<=new_y<n:\n                    q.append((new_x, new_y, left, steps+1))\n        return -1"}
{"prompt": "def findNumbers(self, nums: List[int]) -> int:\n        return len([x for x in nums if len(str(x)) % 2 == 0])"}
{"prompt": "def isPossibleDivide(self, nums: List[int], k: int) -> bool:\n        hand = nums\n        W = k\n        if not hand and W > 0:\n            return False\n        if W > len(hand):\n            return False\n        if W == 0 or W == 1: \n            return True\n        expectation_map = {}\n        # self.count keep track of the numbers of cards that have been successfully counted as a straight,\n        # when self.count == len(hand) => All cards are part of a valid straight \n        self.count = 0\n        handLength = len(hand)\n\n        #Sort the hand.\n        sortedHand = sorted(hand)\n\n        \n        \"\"\"\n        This method updates the expectation map in the following way:\n            a) If the len(l) == W\n                    => We've completed a straight of length W, add it towards the final count\n            b) if the next expected number (num+1) is already in the map \n                    => add the list to a queue of hands waiting to make a straight\n            c) if expected number (num+1) not in the map \n                    => Add a new expectation key with value as a new queue with this list \n        \"\"\"\n        def update_expectation_with_list(expectation_map, num, l, W):\n            # If we have W consecutive numbers, we're done with this set, count towards final count\n            if len(l) == W:\n                self.count += W\n            # we need more numbers to make this straight, add back with next expected num \n            else:\n                exp = num + 1\n                # Some other list is already expecting this number, add to the queue\n                if exp in expectation_map:\n                    expectation_map[exp].append(l)\n\n                # New expected number, create new key and set [l] as value\n                else:\n                    expectation_map[exp] = [l]\n        \n        \"\"\"\n        Very similar to update_expectation_with_list. The difference here is we have the first card of the straight and thus we need to handle it correctly (set the value as a list of lists)\n        \"\"\"\n        def update_expectation_with_integer(expectation_map, num):\n            exp = num + 1\n            # Some other list is already expecting this number, add to the queue\n            if exp in expectation_map:\n                expectation_map[exp].append([num])\n            # New expected number, create new key and set [num] as value\n            else:\n                expectation_map[exp] = [[num]]\n        \n        for idx,num in enumerate(sortedHand):\n            # A possible straight can be formed with this number\n            if num in expectation_map:\n                # there are multiple hands waiting for this number\n                if len(expectation_map[num]) > 1:\n                    # pop the first hand\n                    l = expectation_map[num].pop(0)\n                    # add num to this hand\n                    l.append(num)\n                    # Update the expectation map\n                    update_expectation_with_list(expectation_map, num, l, W)\n                \n                # there's only one hand expecting this number\n                else:\n                    # pop the first hand\n                    l = expectation_map[num].pop(0)\n                    l.append(num)\n\n                    # Important : del the key! There's no other hand expecting this number\n                    expectation_map.pop(num) \n                    update_expectation_with_list(expectation_map, num, l, W)\n                    \n            # Nothing is expecting this number, add new expectation to the map\n            else:\n                update_expectation_with_integer(expectation_map, num)\n                \n        return self.count == handLength"}
{"prompt": "def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n        s1 = []\n        count ={}\n        while minSize <= maxSize:\n            for i in range(0,len(s)):\n                if (i+ minSize) <=len(s) and len(set(s[i: i+ minSize])) <= maxLetters:\n                    s1.append(s[i: i+ minSize])\n            minSize += 1         \n        for i in s1:\n            count[i] = count[i] + 1 if i in count  else 1      \n        return max(count.values()) if count else 0"}
{"prompt": "def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        myKeys = set()\n        canVisit = set(initialBoxes)\n        q = initialBoxes[:]\n        # Check [all keys we can get] and [all boxes we can visit]\n        while q:\n            box = q.pop(0)\n            myKeys.update(set((keys[box]))) # Add the keys in box into \"myKeys\"\n            canVisit.add(box) # Add current box into \"canVisit\"\n            newBoxes = containedBoxes[box] # Add next boxes to the queue\n            for nb in newBoxes:\n                q.append(nb)\n                \n        ans = 0\n        # Visit all boxes we can visit \n        for i in canVisit:\n            # We can open the box only if we have the key or box's status is open(1)\n            if i in myKeys or status[i] == 1:\n                ans += candies[i]\n        return ans"}
{"prompt": "def replaceElements(self, arr: List[int]) -> List[int]:\n        mx = arr[-1]\n        arr[-1] = -1\n        for i in range(len(arr) - 2, -1, -1):\n            temp = arr[i]\n            arr[i] = mx\n            if mx < temp: mx = temp\n        return arr"}
{"prompt": "def findBestValue(self, arr: List[int], target: int) -> int:\n        arr.sort()\n        s, n = 0, len(arr)\n        \n        for i in range(n):\n            ans = round((target - s)/n)\n            if ans <= arr[i]: return ans \n            s += arr[i]\n            n -= 1\n            \n        return arr[-1]"}
{"prompt": "def pathsWithMaxScore(self, board: List[str]) -> List[int]:\n        \"\"\"bottom-up dp\"\"\"\n        n = len(board) #dimension\n\n        #count > 0 also indicates state is reachable\n        dp = [[0, 0] for _ in range(n+1)] #score-count (augment by 1 for convenience)\n        \n        for i in reversed(range(n)):\n            #not assuming reachability while updating state\n            copy = [[0, 0] for _ in range(n+1)] #to be updated to new dp\n            for j in reversed(range(n)): \n                if board[i][j] == \"X\": continue #skip obstacle\n                if board[i][j] == \"S\": #initialize \"S\"\n                    copy[j] = [0, 1]\n                    continue \n                #find max score from neighbors\n                for candidate in (copy[j+1], dp[j], dp[j+1]): #right/below/right-below\n                    if not candidate[1]: continue #not reachable\n                    if copy[j][0] < candidate[0]: copy[j] = candidate[:]\n                    elif copy[j][0] == candidate[0]: copy[j][1] = (copy[j][1] + candidate[1])%(10**9+7)\n                #update with board number \n                if board[i][j] != \"E\": copy[j][0] += int(board[i][j])\n            dp = copy\n        return dp[0]"}
{"prompt": "def deepestLeavesSum(self, root: Optional[TreeNode]) -> int:\n        q = [(root, 0)]\n        ans = 0\n        curr_level = 0 # Maintains the current level we are at\n        while len(q) != 0: # Do a simple Level Order Traversal\n            current, max_level = q.pop(0)\n            if max_level > curr_level: # Update the ans as curr_level gets outdated\n                curr_level = max_level # Update curr_level\n                ans = 0 # Ans needs to be constructed for the new level i.e. max_level\n            ans += current.val\n            if current.left is not None:\n                q.append((current.left, max_level + 1))\n            if current.right is not None:\n                q.append((current.right, max_level + 1))\n        return ans"}
{"prompt": "def sumZero(self, n: int) -> List[int]:\n        return list(range(1,n))+[-n*(n-1)//2]"}
{"prompt": "def getAllElements(self, root1: TreeNode, root2: TreeNode) -> List[int]:\n        h = lambda r:  h(r.left) + [r.val] + h(r.right) if r else []\n        return sorted( h(root1) + h(root2) )"}
{"prompt": "def canReach(self, arr: List[int], i: int) -> bool:\n        if i < 0 or i >= len(arr) or arr[i] < 0: return False\n        arr[i] *= -1 # Mark visited\n        return arr[i] == 0 or self.canReach(arr, i - arr[i]) or self.canReach(arr, i + arr[i])"}
{"prompt": "def isSolvable(self, words: List[str], result: str) -> bool:\n        if max(map(len, words)) > len(result): return False # edge case \n        \n        words.append(result)\n        digits = [0]*10 \n        mp = {} # mapping from letter to digit \n        \n        def fn(i, j, val): \n            \"\"\"Find proper mapping for words[i][~j] and result[~j] via backtracking.\"\"\"\n            if j == len(result): return val == 0 # base condition \n            if i == len(words): return val % 10 == 0 and fn(0, j+1, val//10)\n            \n            if j >= len(words[i]): return fn(i+1, j, val)\n            if words[i][~j] in mp: \n                if j and j+1 == len(words[i]) and mp[words[i][~j]] == 0: return # backtrack (no leading 0)\n                if i+1 == len(words): return fn(i+1, j, val - mp[words[i][~j]])\n                else: return fn(i+1, j, val + mp[words[i][~j]])\n            else: \n                for k, x in enumerate(digits): \n                    if not x and (k or j == 0 or j+1 < len(words[i])): \n                        mp[words[i][~j]] = k\n                        digits[k] = 1\n                        if i+1 == len(words) and fn(i+1, j, val-k): return True \n                        if i+1 < len(words) and fn(i+1, j, val+k): return True \n                        digits[k] = 0\n                        mp.pop(words[i][~j])\n        \n        return fn(0, 0, 0)"}
{"prompt": "def freqAlphabets(self, s: str) -> str:\n        for i in range(26,0,-1): s = s.replace(str(i)+'#'*(i>9),chr(96+i))\n        return s\n            \n\t\t\n\t\t\n- Junaid Mansuri\n- Chicago, IL"}
{"prompt": "def xorQueries(self, A: List[int], Q: List[List[int]]) -> List[int]:\n        B = [A[0]]\n        for a in A[1:]: B.append(B[-1]^a)\n        B.append(0)\n        return [B[L-1]^B[R] for L,R in Q]"}
{"prompt": "def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\n        queue = [id]\n        count = 0\n        seen = set(queue)\n        while queue and count < level: #bfs\n            count += 1\n            temp = set()\n            for i in queue: \n                for j in friends[i]:\n                    if j not in seen: \n                        temp.add(j)\n                        seen.add(j)\n            queue = temp\n        \n        movies = dict()\n        for i in queue: \n            for m in watchedVideos[i]: \n                movies[m] = movies.get(m, 0) + 1\n        return [k for _, k in sorted((v, k) for k, v in movies.items())]"}
{"prompt": "def minInsertions(self, S: str) -> int:\n        L = len(S)\n        DP = [[0 for _ in range(L+1)] for _ in range(L+1)]\n        for i,j in itertools.product(range(L),range(L)): DP[i+1][j+1] = DP[i][j] + 1 if S[i] == S[L-1-j] else max(DP[i][j+1],DP[i+1][j])\n        return L - DP[-1][-1]\n\t\t\n\t\t\n- Junaid Mansuri\n- Chicago, IL"}
{"prompt": "def decompressRLElist(self, N: List[int]) -> List[int]:\n        L, A = len(N), []\n        for i in range(0,L,2):\n            A.extend(N[i]*[N[i+1]])\n        return A"}
{"prompt": "def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\n        m, n = len(mat), len(mat[0])\n        mat[:] = [[0] * (n + 1)] + [[0] + row for row in mat]\n        res = [[0] * n for i in range(m)]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                mat[i][j] += mat[i - 1][j] + mat[i][j - 1] - mat[i - 1][j - 1]\n                \n        for i in range(m):\n            for j in range(n):\n                r1, r2 = max(i - K, 0), min(i + K + 1, m)\n                c1, c2 = max(j - K, 0), min(j + K + 1, n)\n                res[i][j] = mat[r2][c2] - mat[r2][c1] - mat[r1][c2] + mat[r1][c1]\n\n        return res"}
{"prompt": "def __init__(self):\n        self.summary = 0\n\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\n        self.walk(root, False, False)\n        return self.summary\n\n    def walk(self, node: TreeNode, parent_even: bool, grand_parent_even: bool):\n        if node is None:\n            return\n        if grand_parent_even:\n            self.summary += node.val\n        next_parent_even = True if node.val % 2 == 0 else False\n        self.walk(node.left, next_parent_even, parent_even)\n        self.walk(node.right, next_parent_even, parent_even)\n        return"}
{"prompt": "def distinctEchoSubstrings(self, text: str) -> int:\n        n = len(text)\n\t\t\n        def helper(size):\n            base = 1 << 5\n            M = 10 ** 9 + 7\n            a = pow(base, size, M)\n            t = 0\n            vis = defaultdict(set)\n            vis_pattern = set()\n            ans = 0\n            for i in range(n):\n                t = (base * t + ord(text[i]) - ord('a')) % M\n                if i >= size:\n                    t -= a * (ord(text[i - size]) - ord('a'))\n                    t %= M\n                    if t not in vis_pattern and (i - size * 2 + 1) in vis[t]:\n                        ans += 1\n                        vis_pattern.add(t)\n                if i >= size - 1:\n                    vis[t].add(i - size + 1)\n            return ans\n\n        return sum(helper(size) for size in range(1, n//2+1))"}
{"prompt": "def getNoZeroIntegers(self, n: int) -> List[int]:\n        left = 0\n        right = n\n        ans = []\n        while True:\n            if str(left).count(\"0\")==0 and str(right).count(\"0\")==0:\n                ans.append(left)\n                ans.append(right)\n                break\n            left+=1\n            right-=1\n        return ans"}
{"prompt": "def minFlips(self, a: int, b: int, c: int) -> int:   \n        count = 0\n        while a or b or c:\n            if (a &amp; 1) | (b &amp; 1) != (c &amp; 1):\n                if (c &amp; 1): count += 1\n                else: count += (a &amp; 1) + (b &amp; 1)\n            a, b, c = a >> 1, b >> 1, c >> 1\n        return count"}
{"prompt": "def makeConnected(self, n: int, connections: List[List[int]]) -> int:\n        self.components = n\n        # We need atleast n-1 connections to connect n networks\n        if(len(connections) < n-1):\n            return -1\n        # If we have n-1 connections, we only need to count to number of components\n        # Union-Find \n        \n        parent = [i for i in range(0, n)]\n        rank = [0] * n\n        for x, y in connections:\n            self.union(x, y, parent, rank)\n        # we require no. of components - 1 edge to connect n components\n        return self.components - 1             \n        \n    def find(self, x, parent):\n        if(parent[x] != x):\n            parent[x] = self.find(parent[x], parent)\n        return parent[x]\n    \n    def union(self, x, y, parent, rank):\n        parent_x = self.find(x, parent)\n        parent_y = self.find(y, parent)\n        \n        if(parent_x == parent_y):\n            return\n        rank_x = rank[parent_x]\n        rank_y = rank[parent_y]\n        \n        if(rank_x > rank_y):\n            parent[parent_y] = parent_x\n        elif(rank_x < rank_y):\n            parent[parent_x] = parent_y\n        else:\n            parent[parent_y] = parent_x\n            rank[parent_x] += 1\n        self.components -= 1"}
{"prompt": "def minimumDistance(self, word: str) -> int:\n    def dist(pre,cur):\n        if pre==None:\n            return 0\n        x1,y1 = divmod(ord(pre)-ord('A'),6)\n        x2,y2 = divmod(ord(cur)-ord('A'),6)\n        return abs(x1-x2) + abs(y1-y2)\n    \n    @lru_cache(None)\n    def fingers(i,l,r):\n        if i == len(word):\n            return 0\n        n1 = dist(l,word[i]) + fingers(i+1,word[i],r)\n        n2 = dist(r,word[i]) + fingers(i+1,l,word[i])\n        return min(n1,n2)\n    \n    return fingers(0,None,None)"}
{"prompt": "def maximum69Number (self, nums: int) -> int:\n        nums = str(nums)                          #changing integer to string\n        j = 1                                     #maximum number you can change atmost\n        for i in range(len(nums)):\n            if nums[i] == \"6\" and (j == 1):       #checking if the element is \"6\" and we are change only once\n                bef = nums[:i]                    #stored element before the element 6 using slicing\n                aft = nums[i+1:]                  #stored element after the element 6 using slicing\n                nums = bef + \"9\"+aft              #adding element in place of 6\n                j-=1                              # we will reduct 1. so that above condition cant satisfy again.\n        nums = int(nums)\n        return nums"}
{"prompt": "def printVertically(self, s: str) -> List[str]:\n        \n        \n        st=0 # track of index to take element from each word \n        s=s.split()\n        ans=[]\n        y=0\n        for i in s:\n            y=max(y,len(i))\n   \n        while st<y:\n            u=[]\n            for i in s:\n                if st<len(i):\n                    u.append(i[st])\n                else:\n                    u.append(' ')# adding spaces if word length is less\n                    \n            \n            while u[-1]==' ': # using stack operation to remove trailing spaces\n                u.pop()\n            ans.append(''.join(u))\n            st+=1# increasing index at each iteration \n        return ans"}
{"prompt": "def removeLeafNodes(self, R: TreeNode, t: int) -> TreeNode:\n        def RLN(R):\n            if R == None: return None\n            R.left, R.right = RLN(R.left), RLN(R.right)\n            return None if R.val == t and R.left == R.right else R\n        return RLN(R)\n\t\t\n\t\t\n- Junaid Mansuri\n- Chicago, IL"}
{"prompt": "def minTaps(self, n: int, ranges: List[int]) -> int:\n        jumps = [0]*(n+1)\n        for i in range(n+1):\n            l, r = max(0,i-ranges[i]),  min(n,i+ranges[i])\n            jumps[l] = max(jumps[l],r-l)\n        step = start = end = 0\n        while end < n:\n            start, end = end+1, max(i+jumps[i] for i in range(start, end+1))\n            if start > end:\n                return -1\n            step += 1\n        return step"}
{"prompt": "def breakPalindrome(self, palindrome: str) -> str:\n        n = len(palindrome)\n        if n == 1: return ''\n        for i, c in enumerate(palindrome):\n            if c != 'a' and ((i != n // 2 and n % 2) or not n % 2): return palindrome[:i] + 'a' + palindrome[i+1:]                \n        else: return palindrome[:-1] + 'b'"}
{"prompt": "def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\n        \n        \n        d = defaultdict(list)\n        \n        for i in range(len(mat)):\n            for j in range(len(mat[0])):\n                d[i-j].append(mat[i][j])\n        \n        for k in d.keys():\n            d[k].sort()\n        \n        for i in range(len(mat)):\n            for j in range(len(mat[0])):\n                mat[i][j] = d[i-j].pop(0)\n        return mat"}
{"prompt": "def maxValueAfterReverse(self, nums: List[int]) -> int:\n        maxi, mini = -math.inf, math.inf\n        \n        for a, b in zip(nums, nums[1:]):\n            maxi = max(min(a, b), maxi)\n            mini = min(max(a, b), mini)\n        change = max(0, (maxi - mini) * 2)\n        \n        # solving the boundary situation\n        for a, b in zip(nums, nums[1:]):\n            tmp1 = - abs(a - b) + abs(nums[0] - b)\n            tmp2 = - abs(a - b) + abs(nums[-1] - a)\n            change = max([tmp1, tmp2, change])\n\t\t\t\n        original_value = sum(abs(a - b) for a, b in zip(nums, nums[1:]))\n        return  original_value + change"}
{"prompt": "\"\"\"\n\tTime:   O(n*log(n))\n\tMemory: O(n)\n\t\"\"\"\n\n\tdef arrayRankTransform(self, arr: List[int]) -> List[int]:\n\t\tranks = {num: r for r, num in enumerate(sorted(set(arr)), start=1)}\n\t\treturn [ranks[num] for num in arr]"}
{"prompt": "def removePalindromeSub(self, s: str) -> int:\n        return 1 if s == s[::-1] else 2"}
{"prompt": "def filterRestaurants(self, restaurants: List[List[int]], veganFriendly: int, maxPrice: int, maxDistance: int) -> List[int]:\n        def f(x):\n            if (veganFriendly == 1 and x[2] == 1 and x[3] <= maxPrice and x[4] <= maxDistance) or (veganFriendly == 0 and x[3] <= maxPrice and x[4] <= maxDistance):\n                return True\n            else:\n                return False\n        y = list(filter(f,restaurants))\n        y.sort(key=lambda a:a[0],reverse=True)\n        y.sort(key=lambda a:a[1],reverse=True)\n        return [i[0] for i in y]"}
{"prompt": "def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:\n        \"\"\"Floyd-Warshall algorithm\"\"\"\n        dist = [[float(\"inf\")]*n for _ in range(n)]\n        for i in range(n): dist[i][i] = 0\n        for i, j, w in edges: dist[i][j] = dist[j][i] = w\n            \n        for k in range(n):\n            for i in range(n):\n                for j in range(n):\n                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n        \n        ans = {sum(d <= distanceThreshold for d in dist[i]): i for i in range(n)}\n        return ans[min(ans)]"}
{"prompt": "def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        jobCount = len(jobDifficulty)    \n        if jobCount < d:\n            return -1\n\n        @lru_cache(None)\n        def topDown(jobIndex: int, remainDayCount: int) -> int:\n            remainJobCount = jobCount - jobIndex\n            if remainDayCount == 1:\n                return max(jobDifficulty[jobIndex:])\n            \n            if remainJobCount == remainDayCount:\n                return sum(jobDifficulty[jobIndex:])\n\n            minDiff = float('inf')\n            maxToday = 0\n            for i in range(jobIndex, jobCount - remainDayCount + 1):\n                maxToday = max(maxToday, jobDifficulty[i])\n                minDiff = min(minDiff, maxToday + topDown(i+1, remainDayCount-1))\n            return minDiff\n\n        return topDown(0, d)"}
{"prompt": "def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:\n\t\tm = len(mat)\n\t\trows = sorted(range(m), key=lambda i: (mat[i], i))\n\t\tdel rows[k:]\n\t\treturn rows"}
{"prompt": "def minSetSize(self, arr: List[int]) -> int:\n        freq = Counter(arr);\n        f = [];\n        for val in freq.values():\n            f.append(val);\n        f.sort(reverse=True)\n        ans = 0;\n        n = 0;\n        while(len(arr)//2>n):\n            n += f[ans];\n            ans += 1;\n        return ans;"}
{"prompt": "def maxProduct(self, root: Optional[TreeNode]) -> int:\n        vals = []\n        \n        def fn(node): \n            \"\"\"Return sum of sub-tree.\"\"\"\n            if not node: return 0 \n            ans = node.val + fn(node.left) + fn(node.right)\n            vals.append(ans)\n            return ans\n        \n        total = fn(root)\n        return max((total-x)*x for x in vals) % 1_000_000_007"}
{"prompt": "def maxJumps(self, arr: List[int], d: int) -> int:\n\n\t\tdp = defaultdict(int)\n\t\tdef dfs(i):\n\t\t\tif i in dp: return dp[i]\n\t\t\tm_path = 0\n\t\t\tfor j in range(i+1,i+d+1):\n\t\t\t\tif j>=len(arr) or arr[j]>=arr[i]: break\n\t\t\t\tm_path = max(m_path,dfs(j))\n\n\t\t\tfor j in range(i-1,i-d-1,-1):\n\t\t\t\tif j<0 or arr[j]>=arr[i]: break\n\t\t\t\tm_path = max(m_path,dfs(j))\n\t\t\tdp[i] = m_path+1\n\t\t\treturn m_path+1\n\n\t\tres = 0\n\t\tfor i in range(len(arr)):\n\t\t\tres = max(res,dfs(i))\n\t\treturn res"}
{"prompt": "\"\"\"\n    Time:   O(log(n))\n    Memory: O(log(n))\n    \"\"\"\n\n    def numberOfSteps(self, num: int) -> int:\n        if num == 0:\n            return 0\n        return 1 + self.numberOfSteps(num - 1 if num &amp; 1 else num >> 1)"}
{"prompt": "def numOfSubarrays(self, arr, k, threshold):\n        windowStart = 0\n        max_avg = 0\n        avg = 0\n        c=0\n        result = []\n        windowSum = 0\n        for windowEnd in range(len(arr)):\n            windowSum += arr[windowEnd]\n            if((windowEnd)>=k-1):\n                avg = windowSum//k\n                result.append(avg)\n                windowSum -= arr[windowStart]\n                windowStart += 1\n        for i in range(len(result)):\n            if(result[i]>=threshold):\n                c=c+1\n        return c"}
{"prompt": "def angleClock(self, hour: int, minutes: int) -> float:\n        return min(abs(30*hour-5.5*minutes),360-abs(30*hour-5.5*minutes))"}
{"prompt": "def minJumps(self, arr: List[int]) -> int:\n        N, groups = len(arr), defaultdict(list)\n\n        for i, el in enumerate(arr): \n            groups[el].append(i)\n\n        vis, vis_groups = set(), set()\n        \n        def bfs(lvl, dist):\n            nextLvl = set()\n            \n            for i in lvl:\n                if i in vis: continue\n                if i == N-1: return dist\n                \n                vis.add(i)\n                \n                if i: nextLvl.add(i-1)\n                if i+1 < N: nextLvl.add(i+1)\n                \n                if not arr[i] in vis_groups:\n                    vis_groups.add(arr[i])\n                    nextLvl.update(groups[arr[i]])\n            \n            return bfs(nextLvl, dist + 1)\n            \n        return bfs(set([0]), 0)"}
{"prompt": "def checkIfExist(self, A: List[int]) -> bool:\n        if A.count(0) > 1: return True\n        S = set(A) - {0}\n        for a in A:\n            if 2*a in S: return True\n        return False\n\t\t\n\t\t\n- Junaid Mansuri\n- Chicago, IL"}
{"prompt": "def minSteps(self, S: str, T: str) -> int:\n        D = collections.Counter(S) - collections.Counter(T)\n        return sum(max(0, D[s]) for s in set(S))\n\t\t\n\t\t\n- Junaid Mansuri\n- Chicago, IL"}
{"prompt": "def maxStudents(self, seats: list[list[str]]) -> int:\n        def count_bits(num: int) -> int:\n            # Count how many bits having value 1 in num.\n            cnt = 0\n            while num:\n                cnt += 1\n                num &amp;= num - 1\n\n            return cnt\n\n        R, C = len(seats), len(seats[0])\n        validSeats = []\n\n        # Calculate valid seats mask for each row.\n        for row in seats:\n            curr = 0\n            for seat in row:\n                curr = (curr << 1) + (seat == '.')\n\n            validSeats.append(curr)\n\n        # dp[i][mask] stands for the maximum students on ith row with students\n        # following the mask.\n        dp = [[-1] * (1 << C) for _ in range(R + 1)]\n        dp[0][0] = 0\n        for r in range(1, R + 1):\n            seatMask = validSeats[r - 1]\n            for studentMask in range(1 << C):\n                validBits = count_bits(studentMask)\n\n                # 1. Check if a student mask is a subset of seatMask so that\n                #   the target student could sit on a seat.\n                # 2. The student should not sit next to each other.\n                if (\n                    studentMask &amp; seatMask == studentMask and\n                    studentMask &amp; (studentMask >> 1) == 0\n                ):\n                    # Then check the upper student mask and make sure that\n                    # 1. no student is on the upper left.\n                    # 2. no student is on the upper right.\n                    # Then the upper mask is a valid candidate for the current\n                    # student mask.\n                    for upperStudentMask in range(1 << C):\n                        if (\n                            studentMask &amp; (upperStudentMask >> 1) == 0 and\n                            studentMask &amp; (upperStudentMask << 1) == 0 and\n                            dp[r - 1][upperStudentMask] != -1\n                        ):\n                            dp[r][studentMask] = max(\n                                dp[r][studentMask],\n                                dp[r - 1][upperStudentMask] + validBits\n                            )\n\n        return max(dp[-1])"}
{"prompt": "def countNegatives(self, grid: List[List[int]]) -> int:\n        result = 0\n        rows = len(grid)\n        cols = len(grid[0])\n        \n        i = 0\n        j = cols - 1\n        while i < rows and j>=0:\n            curr = grid[i][j]\n            if(curr < 0):\n                j-=1\n            else:\n                result+=((cols-1) - j) #capture the no.of negative number in this row and jump to next row\n                i+=1\n        \n\t\t#left out negative rows\n        while i < rows:\n            result+=cols\n            i+=1\n        \n        return result"}
{"prompt": "# Solution 1\ndef maxEvents(self, events: List[List[int]]) -> int:\n        events = sorted(events, key=lambda x: x[1])\n        visited = set()\n        for s, e in events:\n            for t in range(s, e+1):\n                if t not in visited:\n                    visited.add(t)\n                    break\n        return len(visited)"}
{"prompt": "def isPossible(self, target: List[int]) -> bool:\n\n\t\theapq._heapify_max(target)\n\t\ts = sum(target)\n\n\t\twhile target[0] != 1:\n\t\t\tsub = s - target[0]\n\t\t\tif sub == 0: return False\n\t\t\tn = max((target[0] - 1) // sub, 1)\n\t\t\ts -= n * sub\n\t\t\ttarget0 = target[0] - n * sub\n\t\t\tif target0 < 1: return False\n\t\t\theapq._heapreplace_max(target, target0)\n\n\t\treturn True\n\t```"}
{"prompt": "def sortByBits(self, arr: List[int]) -> List[int]:\n        return sorted(arr, key = lambda item: (str(bin(item))[2:].count(\"1\"), item))"}
{"prompt": "def numberOfSubstrings(self, s: str) -> int:\n        a = b = c = 0                        # counter for letter a/b/c\n        ans, i, n = 0, 0, len(s)             # i: slow pointer\n        for j, letter in enumerate(s):       # j: fast pointer\n            if letter == 'a': a += 1         # increment a/b/c accordingly\n            elif letter == 'b': b += 1\n            else: c += 1\n            while a > 0 and b > 0 and c > 0: # if all of a/b/c are contained, move slow pointer\n                ans += n-j                   # count possible substr, if a substr ends at j, then there are n-j substrs to the right that are containing all a/b/c\n                if s[i] == 'a': a -= 1       # decrement counter accordingly\n                elif s[i] == 'b': b -= 1\n                else: c -= 1\n                i += 1                       # move slow pointer\n        return ans"}
{"prompt": "def countOrders(self, n: int) -> int:\n        n=2*n\n        ans=1\n        while n>=2:\n            ans = ans *((n*(n-1))//2)\n            n-=2\n            ans=ans%1000000007\n        return ans"}
{"prompt": "def daysBetweenDates(self, date1: str, date2: str) -> int:\n        \n        def f_date(date): # calculates days passed since '1900-01-01'\n            year0 = '1900'\n            year1, month1, day1 = date.split('-')\n                        \n            days = 0\n            for y in range(int(year0), int(year1)):\n                days += 365\n                if y%100 == 0:\n                    if y%400 == 0:\n                        days += 1\n                else:\n                    if y%4 == 0:\n                        days += 1\n                        \n            for m in range(int(month1)):\n                if m in [1, 3, 5, 7, 8, 10, 12]:\n                    days += 31\n                if m in [4, 6, 9, 11]:\n                    days += 30\n                if m == 2:\n                    days += 28\n                    if int(year1)%100 == 0:\n                        if int(year1)%400 == 0:\n                            days += 1\n                    else:\n                        if int(year1)%4 ==0:\n                            days += 1\n            days += int(day1)\n            return days\n\t\t\t\n        return abs(f_date(date1) - f_date(date2))"}
{"prompt": "def validateBinaryTreeNodes(self, n: int, leftChild: List[int], rightChild: List[int]) -> bool:\n        n = len(leftChild)\n        \n        # tree has 2 requirements\n        # 1. every node has a single parent\n        # 2. single root (only one node has NO parent)\n        # 3. no cycle\n        # 4. all nodes connected to each other (single component)\n        \n        parent = [-1] * n\n        \n        # checking condition (1. and 2.)\n        for idx, (left, right) in enumerate(zip(leftChild, rightChild)):\n            \n            if left != -1:\n                # FAILED: condition (1.)\n                if parent[left] != -1: return False\n                parent[left] = idx\n                \n            if right != -1:\n                # FAILED: condition (1.)\n                if parent[right] != -1: return False\n                parent[right] = idx\n        \n        # FAILED condition (2.)\n        if parent.count(-1) != 1: return False\n            \n        # checking condition (3. and 4.)\n        vis = set()\n        def dfs_has_cycle(u):\n            if u in vis:\n                return True\n            else:\n                vis.add(u)\n            \n            for kid in [leftChild[u], rightChild[u]]:\n                if kid != -1:\n                    if dfs_has_cycle(kid): return True\n            \n        # FAILED condition (3.) - found a cycle\n        if dfs_has_cycle(parent.index(-1)): return False\n        \n        # FAILED condition (4.) - DFS did not visit all nodes!\n        if len(vis) != n: return False\n        \n        # did not FAIL any condition, success ;)\n        return True\n\n\"\"\"\nTricky test case (cycle and not connected):\n4\n[1,-1,3,-1]\n[2,-1,-1,-1]\n\n\"\"\""}
{"prompt": "def closestDivisors(self, num: int) -> List[int]:\n        for i in range(int((num+2)**0.5), 0, -1):\n            if not (num+1)%i: return (i, (num+1)//i)\n            if not (num+2)%i: return (i, (num+2)//i)"}
{"prompt": "def largestMultipleOfThree(self, digits: List[int]) -> str:\n        def dump(r: int) -> str:\n            if r:\n                for i in range(3):\n                    idx = 3 * i + r\n                    if counts[idx]:\n                        counts[idx] -= 1\n                        break\n                else:\n                    rest = 2\n                    for j in range(3):\n                        idx = 3 * j + (-r % 3)\n                        while rest and counts[idx]:\n                            counts[idx] -= 1\n                            rest -= 1\n                        if not rest: break\n                    if rest: return ''\n            if any(counts):\n                result = ''\n                for i in reversed(range(10)):\n                    result += str(i) * counts[i]\n                return str(int(result))\n            return ''\n\n        total, counts = 0, [0] * 10\n        for digit in digits:\n            counts[digit] += 1\n            total += digit\n        return dump(total % 3)"}
{"prompt": "def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\n        a=[]\n        numi = sorted(nums)\n        for i in range(0,len(nums)):\n            a.append(numi.index(nums[i]))\n        return a"}
{"prompt": "def rankTeams(self, votes: List[str]) -> str:\n        teamVotes = collections.defaultdict(lambda: [0] * 26)\n        for vote in votes:\n            for pos, team in enumerate(vote):\n                teamVotes[team][pos] += 1\n        \n        return ''.join(sorted(teamVotes.keys(), reverse=True,\n                              key=lambda team: (teamVotes[team], -ord(team))))"}
{"prompt": "def isSubPath(self, head: ListNode, root: TreeNode) -> bool:\n        #build longest prefix-suffix array\n        pattern, lps = [head.val], [0] #longest prefix-suffix array\n        j = 0\n        while head.next: \n            head = head.next \n            pattern.append(head.val)\n            \n            while j and head.val != pattern[j]: j = lps[j-1]\n            if head.val == pattern[j]: j += 1\n            lps.append(j)\n            \n        def dfs(root, i): \n            \"\"\"Return True of tree rooted at \"root\" match pattern\"\"\"\n            if i == len(pattern): return True\n            if not root: return False \n            \n            while i > 0 and root.val != pattern[i]: i = lps[i-1]\n            if root.val == pattern[i]: i += 1\n            return dfs(root.left, i) or dfs(root.right, i)\n        \n        return dfs(root, 0)"}
{"prompt": "def minCost(self, grid: List[List[int]]) -> int:\n        graph = {}\n        m, n = len(grid), len(grid[0])\n        \n        def addEdges(i, j):\n            graph[(i, j)] = {}\n            neighbors = [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]\n            for each in neighbors:\n                x, y = each\n                if x < 0 or y < 0 or x > m - 1 or y > n - 1:\n                    continue\n                else:\n                    graph[(i, j)][(x, y)] = 1\n            \n            if grid[i][j] == 1:\n                if j != n - 1:\n                    graph[(i, j)][(i, j + 1)] = 0\n            \n            elif grid[i][j] == 2:\n                if j != 0:\n                    graph[(i, j)][(i, j - 1)] = 0\n            \n            elif grid[i][j] == 3:\n                if i != m - 1:\n                    graph[(i, j)][(i + 1, j)] = 0\n            \n            else:\n                if i != 0:\n                    graph[(i, j)][(i - 1, j)] = 0\n                    \n        \n        for i in range(m):\n            for j in range(n):\n                addEdges(i, j)\n        \n\t\t# convert row, col to index value in distances array\n        def convert(x, y):\n            return x * n + y\n        \n        def BFS(graph):\n            q = deque()\n            q.append([0, 0, 0])\n            distances = [float(inf)] * (m * n)\n            \n            while q:\n                cost, x, y = q.popleft()\n                if (x, y) == (m - 1, n - 1):\n                    return cost\n                \n                idx = convert(x, y)\n                if distances[idx] < cost:\n                    continue\n                \n                distances[idx] = cost\n                for node, nxtCost in graph[(x, y)].items():\n                    nxtIndex = convert(node[0], node[1])\n                    if distances[nxtIndex] <= cost + nxtCost:\n                        continue\n                    \n                    distances[nxtIndex] = cost + nxtCost\n                    if nxtCost == 0:\n                        q.appendleft([cost, node[0], node[1]])\n                    else:\n                        q.append([cost + 1, node[0], node[1]])\n                        \n        \n        def dijkstra(graph):\n            distances = [float(inf)] * (m * n)\n            myheap = [[0, 0, 0]]\n            #distances[0] = 0\n            \n            while myheap:\n                cost, x, y = heappop(myheap)\n                if (x, y) == (m - 1, n - 1):\n                    return cost\n                \n                idx = convert(x, y)\n                if distances[idx] < cost:\n                    continue\n                else:\n                    distances[idx] = cost\n                    for node, nxtCost in graph[(x, y)].items():\n                        total = cost + nxtCost\n                        nxtIndex = convert(node[0], node[1])\n                        if distances[nxtIndex] <= total:\n                            continue\n                        else:\n                            distances[nxtIndex] = total\n                            heappush(myheap, [total, node[0], node[1]])\n            \n            return distances[-1]\n        \n        #return dijkstra(graph)\n        return BFS(graph)"}
{"prompt": "def sortString(self, s: str) -> str:\n        s = list(s)\n        # Big S: O(n)\n        result = []\n        \n        # Logic is capture distinct char with set\n        # Remove found char from initial string\n        \n        # Big O: O(n)\n        while len(s) > 0:\n\n            # Big O: O(n log n) Space: O(n)\n            smallest = sorted(set(s))\n            # Big O: O(s) - reduced set\n            for small in smallest:\n                result.append(small)\n                s.remove(small)\n                \n            # Big O: O(n log n) Space: O(n)\n            largest = sorted(set(s), reverse = True)\n            # Big O: O(s) - reduced set\n            for large in largest:\n                result.append(large)\n                s.remove(large)\n        \n        return ''.join(result)\n    \n        # Summary:  Big O(n)^2 Space: O(n)"}
{"prompt": "def findTheLongestSubstring(self, s: str) -> int:\n        ans = mask = 0 \n        seen = {0: -1}\n        for i, c in enumerate(s):\n            if c in \"aeiou\": \n                mask ^= 1 << (\"aeiou\".find(c))\n            if mask in seen: ans = max(ans, i - seen[mask])\n            seen.setdefault(mask, i)\n        return ans"}
{"prompt": "def longestZigZag(self, root: Optional[TreeNode]) -> int:\n        \n        LEFT = 0\n        RIGHT = 1\n            \n        stack = []\n        if root.left:\n            stack.append((root.left, LEFT, 1))\n        if root.right:\n            stack.append((root.right, RIGHT, 1))\n            \n        longest = 0\n        while stack:\n            node, direction, count = stack.pop()\n            \n            longest = max(longest, count)\n            if direction == LEFT:\n                if node.left:\n                    stack.append((node.left, LEFT, 1))\n                if node.right:\n                    stack.append((node.right, RIGHT, count+1))\n            else:\n                if node.right:\n                    stack.append((node.right, RIGHT, 1))\n                if node.left:\n                    stack.append((node.left, LEFT, count+1))\n        return longest"}
{"prompt": "def maxSumBST(self, root: TreeNode) -> int:\n        tot = -math.inf\n\n        def dfs(node):\n            nonlocal tot\n            if not node:\n                return 0, math.inf, -math.inf \n            l_res, l_min, l_max = dfs(node.left)\n            r_res, r_min, r_max = dfs(node.right)\n\t\t\t# if maintains BST property\n            if l_max<node.val<r_min:\n                res = node.val + l_res + r_res\n                tot = max(tot, res)\n\t\t\t\t# keep track the min and max values of the subtree\n                return res, min(l_min,node.val), max(r_max, node.val)\n            else:\n                return 0, -math.inf, math.inf\n        \n        return max(dfs(root)[0], tot)"}
{"prompt": "def generateTheString(self, n: int) -> str:\n        a=\"a\"\n        b=\"b\"\n        if n%2==0:\n            return (((n-1)*a)+b)\n        return (n*a)"}
{"prompt": "def numTimesAllBlue(self, light: List[int]) -> int:\n        max = count = 0\n        for i in range(len(light)):\n            if max < light[i]:\n                max = light[i]\n            if max == i + 1:\n                count += 1\n        return count"}
{"prompt": "def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\n        def find(i):\n            if manager[i] != -1:\n                informTime[i] += find(manager[i])\n                manager[i] = -1\n            return informTime[i]\n        return max(map(find, range(n)))"}
{"prompt": "def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n\t\tif target==1:\n\t\t\tif t>=1 and len(edges)>=1:\n\t\t\t\treturn 0\n\t\tadj = collections.defaultdict(list)\n\t\tfor i in edges:\n\t\t\tadj[min(i[0],i[1])].append(max(i[1],i[0]))\n\n\t\tdef traversal(curr, target,t):\n\t\t\tif curr==target:\n\t\t\t\tif t==0 or len(adj[curr])==0:\n\t\t\t\t\treturn 1\n\t\t\t\treturn 0\n\t\t\tif t==0:\n\t\t\t\treturn 0\n\t\t\tfor child in adj[curr]:\n\t\t\t\tprob = traversal(child, target, t-1)/len(adj[curr])\n\t\t\t\tif prob>0: \n\t\t\t\t\treturn prob\n\t\t\treturn 0\n\t\treturn traversal(1,target,t)"}
{"prompt": "def getTargetCopy(self, node1: TreeNode, node2: TreeNode, target: TreeNode) -> TreeNode:        \n        if not node1 or target == node1:  # if node1 is null, node2 will also be null\n            return node2\n        \n        return self.getTargetCopy(node1.left, node2.left, target) or self.getTargetCopy(node1.right, node2.right, target)"}
{"prompt": "def luckyNumbers (self, matrix: List[List[int]]) -> List[int]:\n        rmin = [min(x) for x in matrix]\n        cmax = [max(x) for x in zip(*matrix)]\n        return [matrix[i][j] for i in range(len(matrix)) for j in range(len(matrix[0])) if rmin[i] == cmax[j]]"}
{"prompt": "def balanceBST(self, root: TreeNode) -> TreeNode:\n        \n        def dfs(node):\n            \"\"\"inorder depth-first traverse bst\"\"\"\n            if not node: return \n            dfs(node.left)\n            value.append(node.val)\n            dfs(node.right)\n        \n        value = [] #collect values\n        dfs(root)\n        \n        def tree(lo, hi): \n            if lo > hi: return None\n            mid = (lo + hi)//2\n            ans = TreeNode(value[mid])\n            ans.left = tree(lo, mid-1)\n            ans.right = tree(mid+1, hi)\n            return ans\n        \n        return tree(0, len(value)-1)"}
{"prompt": "def maxPerformance_simple(self, n, speed, efficiency):\n        \n        people = sorted(zip(speed, efficiency), key=lambda x: -x[1])\n        \n        result, sum_speed = 0, 0\n        \n        for s, e in people:\n            sum_speed += s\n            result = max(result, sum_speed * e)\n        \n        return result # % 1000000007"}
{"prompt": "def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\n        n = len(arr2)\n        arr2.sort()\n        res = 0\n        \n        for num in arr1:\n            low, high = 0, n - 1\n            while low <= high:\n                mid = (low + high) // 2\n                if abs(num - arr2[mid]) <= d:\n                    break\n                elif num < arr2[mid]:\n                    high = mid - 1\n                else:\n                    low = mid + 1\n            else:\n                res += 1\n        \n        return res"}
{"prompt": "def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        seats = {}\n        for i, j in reservedSeats: \n            if i not in seats: seats[i] = 0\n            seats[i] |= 1 << j-1\n        \n        ans = 2 * (n - len(seats))\n        for v in seats.values(): \n            if not int(\"0111111110\", 2) &amp; v: ans += 2\n            elif not int(\"0111100000\", 2) &amp; v: ans += 1\n            elif not int(\"0001111000\", 2) &amp; v: ans += 1\n            elif not int(\"0000011110\", 2) &amp; v: ans += 1\n        return ans"}
{"prompt": "def getpower(self,num):\n        p=0\n        while(num!=1):\n            if num%2==0:\n                num=num//2\n                \n            else:\n                num=(3*num)+1\n            p+=1\n            \n        return p\n             \n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        \n        temp=sorted(range(lo,hi+1),key=lambda x:self.getpower(x))\n        return temp[k-1]\n\t\t```"}
{"prompt": "def maxSizeSlices(self, slices: List[int]) -> int:\n        \n        @cache\n        def fn(i, k, first): \n            \"\"\"Return max sum of k pieces from slices[i:].\"\"\"\n            if k == 0: return 0 \n            if i >= len(slices) or first and i == len(slices)-1: return -inf \n            if i == 0: return max(fn(i+1, k, False), slices[i] + fn(i+2, k-1, True))\n            return max(fn(i+1, k, first), slices[i] + fn(i+2, k-1, first))\n        \n        return fn(0, len(slices)//3, None)"}
{"prompt": "def createTargetArray(self, nums: List[int], index: List[int]) -> List[int]:\n        ans = []\n        \n        for i in range(len(nums)):\n            ans.insert(index[i] , nums[i])\n        \n        return ans"}
{"prompt": "def sumFourDivisors(self, nums: List[int]) -> int:\n        res = 0\n        for num in nums:\n            divisor = set() \n            for i in range(1, floor(sqrt(num)) + 1):\n                if num % i == 0:\n                    divisor.add(num//i)\n                    divisor.add(i)\n                if len(divisor) > 4:    \n                    break\n                    \n            if len(divisor) == 4:\n                res += sum(divisor)\n        return res"}
{"prompt": "directions = [[-1, 0], [0, 1], [1, 0], [0, -1]]\n    streetDirections = {\n       1: [1, 3],\n       2: [0, 2],\n       3: [2, 3],\n       4: [1, 2],\n       5: [0, 3],\n       6: [0, 1]\n    }\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        def dfs(i: int, j: int, oppositeDirection: int) -> None:\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] < 0:\n                return\n            v = grid[i][j]\n            sd = Solution.streetDirections[v]\n            direction = (oppositeDirection + 2) % 4\n            if direction not in sd:\n                return\n            grid[i][j] = -v\n            for d in sd:\n                delta = Solution.directions[d]\n                dfs(i+delta[0], j+delta[1], d)\n        dfs(0, 0, 0)\n        dfs(0, 0, 3)\n        return grid[m-1][n-1] < 0"}
{"prompt": "def longestPrefix(self, s: str) -> str:\n        n = [0] + [None] * (len(s) - 1)\n\n        for i in range(1, len(s)):\n            k = n[i - 1] # trying length k + 1\n            while (k > 0) and (s[i] != s[k]):\n                k = n[k - 1]\n            if s[i] == s[k]:\n                k += 1\n            n[i] = k\n        happy_border = n[-1]\n        return s[:happy_border]"}
{"prompt": "def findLucky(self, arr: List[int]) -> int:\n        \n        charMap = {}\n        \n        for i in arr:\n            charMap[i] = 1 + charMap.get(i, 0)\n            \n        res = []\n        \n        for i in charMap:\n            if charMap[i] == i:\n                res.append(i)\n                \n        res = sorted(res)    \n        \n        if len(res) > 0:\n            return res[-1]\n            \n        return -1"}
{"prompt": "def numTeams(self, rating: List[int]) -> int:\n        \n        dp = [[1, 0, 0] for i in range(len(rating))]\n        \n        for i in range(1, len(rating)):\n            for j in range(i):\n                if rating[i] > rating[j]:\n                    dp[i][1] += dp[j][0]\n                    dp[i][2] += dp[j][1]\n        \n        a = sum(dp[i][2] for i in range(len(dp)))\n        #print(a)\n\n        dp = [[1, 0, 0] for i in range(len(rating))]\n        \n        for i in range(1, len(rating)):\n            for j in range(i):\n                if rating[i] < rating[j]:\n                    dp[i][1] += dp[j][0]\n                    dp[i][2] += dp[j][1]\n        \n        b = sum(dp[i][2] for i in range(len(dp)))\n        \n        return a + b"}
{"prompt": "def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:\n        lps = [0]\n        k = 0 \n        for i in range(1, len(evil)): \n            while k and evil[k] != evil[i]: k = lps[k-1]\n            if evil[k] == evil[i]: k += 1\n            lps.append(k)\n        \n        @cache\n        def fn(i, k, lower, upper): \n            \"\"\"Return number of good strings at position i and k prefix match.\"\"\"\n            if k == len(evil): return 0 # boundary condition \n            if i == n: return 1 \n            lo = ascii_lowercase.index(s1[i]) if lower else 0\n            hi = ascii_lowercase.index(s2[i]) if upper else 25\n            \n            ans = 0\n            for x in range(lo, hi+1): \n                kk = k \n                while kk and evil[kk] != ascii_lowercase[x]: \n                    kk = lps[kk-1]\n                if evil[kk] == ascii_lowercase[x]: kk += 1\n                ans += fn(i+1, kk, lower and x == lo, upper and x == hi)\n            return ans \n        \n        return fn(0, 0, True, True) % 1_000_000_007"}
{"prompt": "def countLargestGroup(self, n: int) -> int:\n        dp = {0: 0}\n        counts = [0] * (4 * 9)\n        for i in range(1, n + 1):\n            quotient, reminder = divmod(i, 10)\n            dp[i] = reminder + dp[quotient]\n            counts[dp[i] - 1] += 1\n\n        return counts.count(max(counts))"}
{"prompt": "def canConstruct(self, s: str, k: int) -> bool:\n        if k > len(s):\n            return False\n        dic = {}\n        \n        for i in s:\n            if i not in dic:\n                dic[i] = 1\n            else:\n                dic[i] += 1\n        c = 0        \n        for i in dic.values():\n            if i % 2 == 1:\n                c += 1\n        \n        if c > k:\n            return False\n        return True"}
{"prompt": "def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\n        x = 0 if x1 <= x_center <= x2 else min(abs(x1-x_center), abs(x2-x_center))\n        y = 0 if y1 <= y_center <= y2 else min(abs(y1-y_center), abs(y2-y_center))\n        return x**2 + y**2 <= radius**2"}
{"prompt": "def maxSatisfaction(self, satisfaction: List[int]) -> int:\n        satisfaction.sort(reverse=True)\n        maxSatisfaction = dishSum = 0\n\n        for dish in satisfaction:\n            dishSum += dish\n            if dishSum <= 0:\n                break\n            maxSatisfaction += dishSum\n        \n        return maxSatisfaction"}
{"prompt": "def minSubsequence(self, nums: List[int]) -> List[int]:\n        nums.sort()\n        l = []\n        while sum(l) <= sum(nums):\n            l.append(nums.pop())\n        return l"}
{"prompt": "def numSteps(self, s):\n        return len(s) + s.rstrip('0').count('0') + 2 * (s.count('1') != 1) - 1"}
{"prompt": "def longestDiverseString(self, a: int, b: int, c: int) -> str:\n        count = collections.Counter({'a':a, 'b':b, 'c':c})\n        res = ['#']\n        while True:\n            (a1, _), (a2, _) = count.most_common(2)\n            \n            if a1 == res[-1] == res[-2]:\n                a1 = a2\n                \n            if not count[a1]:\n                break\n                \n            res.append(a1)\n            count[a1] -= 1            \n        \n        return ''.join(res[1:])"}
{"prompt": "def stoneGameIII(self, stoneValue):\n        \"\"\"\n        :type stoneValue: List[int]\n        :rtype: str\n        \"\"\"\n        \n        dp = [0 for _ in range(len(stoneValue))]\n        if len(dp) >= 1:\n            dp[-1] = stoneValue[-1]\n        if len(dp) >= 2:\n            dp[-2] = max(stoneValue[-1] + stoneValue[-2], stoneValue[-2] - dp[-1])\n        if len(dp) >= 3:\n            dp[-3] = max(stoneValue[-3] + stoneValue[-1] + stoneValue[-2], stoneValue[-3] - dp[-2], stoneValue[-3] + stoneValue[-2] - dp[-1])\n        \n        for i in range(len(stoneValue) - 4, -1, -1):\n            \n            dp[i] = max([sum(stoneValue[i: i + j]) - dp[i + j] for j in range(1, 4)])\n        \n        if dp[0] > 0:\n            return \"Alice\"\n        if dp[0] == 0:\n            return \"Tie\"\n        return \"Bob\""}
{"prompt": "def stringMatching(self, words: List[str]) -> List[str]:\n        def add(word: str):\n            node = trie\n            for c in word:\n                node = node.setdefault(c, {})\n\n        def get(word: str) -> bool:\n            node = trie\n            for c in word:\n                if (node := node.get(c)) is None: return False\n            return True\n\n        words.sort(key=len, reverse=True)\n        trie, result = {}, []\n        for word in words:\n            if get(word): result.append(word)\n            for i in range(len(word)):\n                add(word[i:])\n        return result"}
{"prompt": "def processQueries(self, queries: List[int], m: int) -> List[int]:\n        permuteArr=[i for i in range(1,m+1)]\n        query_len=len(queries)\n        answer=[]\n        left,right=[],[]\n        for query in range(query_len):\n            index=permuteArr.index(queries[query])\n            answer.append(index)\n            left=permuteArr[:index]\n            right=permuteArr[index+1:]\n            permuteArr=[permuteArr[index]]+left+right\n        return answer"}
{"prompt": "def entityParser(self, text: str) -> str:\n        \n        html_symbol = [ '&amp;quot;', '&amp;apos;', '&amp;gt;', '&amp;lt;', '&amp;frasl;', '&amp;amp;']\n        formal_symbol = [ '\"', \"'\", '>', '<', '/', '&amp;']\n                \n        for html_sym, formal_sym in zip(html_symbol, formal_symbol):\n            text = text.replace( html_sym , formal_sym )\n        \n        return text"}
{"prompt": "def numOfWays(self, n: int) -> int:\n        mod = 10 ** 9 + 7\n        two_color, three_color = 6, 6\n        for _ in range(n - 1):\n            two_color, three_color = (two_color * 3 + three_color * 2) % mod, (two_color * 2 + three_color * 2) % mod\n        return (two_color + three_color) % mod"}
{"prompt": "def minStartValue(self, nums: List[int]) -> int:\n        \n        for i in range(1, len(nums)): nums[i] = nums[i] + nums[i - 1]\n        \n        return 1 if min(nums) >= 1 else abs(min(nums)) + 1"}
{"prompt": "def findMinFibonacciNumbers(self, n: int) -> int:\n        def check(z):\n            key = [1,1]\n            while key[-1] + key[-2] <= z:\n                key.append(key[-1]+key[-2])\n            print(key,z)\n            if z in key:\n                return 1\n            return 1 + check(z-key[-1])\n        return check(n)"}
{"prompt": "def getHappyString(self, n: int, k: int) -> str:\n        \n        char = [\"a\", \"b\", \"c\"]  \n        \n        # Edge case, n = 1\n        if n == 1: return char[k - 1] if k <= 3 else \"\"\n        \n        # There will be $part$ number of strings starting with each character (a, b, c)\n        part = 2 ** (n - 1)\n        \n        # If k is too large\n        if k > part * 3: return \"\"\n        \n        res = []\n        \n        # Edge case is k = n * i, where i is an integer in range [1, 3]\n        res.append(char[k // part if k % part != 0 else k // part - 1])\n        k = k % part if k % part != 0 else part\n        \n        for i in range(n - 2, -1, -1):\n            char = [\"a\", \"b\", \"c\"]  \n            char.remove(res[-1])        # Make sure the adjacent characters will be different\n            \n            if len(res) + 1 == n:       # Edge case, assigning the last element\n                if k == 1: res.append(char[0])\n                elif k == 2: res.append(char[-1])\n            elif k > 2 ** i:            # Go to the right side\n                res.append(char[-1])\n                k -= 2 ** i       \n            else: res.append(char[0])   # Go to the left side\n        \n        return \"\".join(res)"}
{"prompt": "def numberOfArrays(self, s, k):\n        n=len(s)\n        new=[0]*n\n        new[0]=1\n        m=len(str(k))\n        for i in range(1,n):\n            for j in range(max(0,i-m+1),i+1):\n                if s[j]!=\"0\" and int(s[j:i+1])<=k:\n                    if j==0:\n                        new[i]=1\n                    else:\n                        new[i]+=new[j-1]\n                #print(new)\n        \n        return new[-1]%(10**9+7)"}
{"prompt": "def reformat(self, s: str) -> str:\n        nums, chars = [], []\n        [(chars, nums)[char.isdigit()].append(str(char)) for char in s]\n        nums_len, chars_len = len(nums), len(chars)\n        if 2 > nums_len - chars_len > -2:\n            a, b = ((chars, nums), (nums, chars))[nums_len > chars_len]\n            return reduce(lambda x, y: x + y[0] + y[1], itertools.zip_longest(a, b, fillvalue=''), '')\n        return ''"}
{"prompt": "def displayTable(self, orders: List[List[str]]) -> List[List[str]]:\n                        \n        order = defaultdict(lambda : {})\n                \n        foods = set()\n        \n        ids = []\n        \n        for i , t , name in orders:\n            t = int(t)\n            if(name in order[t]):\n                order[t][name] += 1\n            else:\n                order[t][name] = 1\n            if(int(t) not in ids):\n                ids.append(int(t))\n                \n            foods.add(name)\n        \n        ids.sort()\n                        \n        foods = list(foods)\n        \n        foods.sort()\n        \n        tables = [['Table'] + foods]\n        \n        k = 0\n                \n        order = dict(sorted(order.items() , key=lambda x: x[0]))\n                \n        for _ , j in order.items():\n            ans = [str(ids[k])]\n            for i in foods:\n                if(i in j):\n                    ans.append(str(j[i]))\n                else:\n                    ans.append(\"0\")\n            \n            tables.append(ans)\n            \n            k += 1\n        \n        return tables"}
{"prompt": "def minNumberOfFrogs(self, croakOfFrogs: str) -> int:\n        cnt, s = collections.defaultdict(int), 'croak'     \n        ans, cur, d = 0, 0, {c:i for i, c in enumerate(s)}  # d: mapping for letter &amp; its index\n        for letter in croakOfFrogs:                         # iterate over the string\n            if letter not in s: return -1                   # if any letter other than \"croak\" is met, then invalid\n            cnt[letter] += 1                                # increase cnt for letter\n            if letter == 'c': cur += 1                      # 'c' is met, increase current ongoing croak `cur`\n            elif cnt[s[d[letter]-1]] <= 0: return -1        # if previous character fall below to 0, return -1\n            else: cnt[s[d[letter]-1]] -= 1                  # otherwise, decrease cnt for previous character\n            ans = max(ans, cur)                             # update answer using `cur`\n            if letter == 'k':                               # when 'k' is met, decrease cnt and cur\n                cnt[letter] -= 1\n                cur -= 1\n        return ans if not cur else -1                       # return ans if current ongoing \"croak\" is 0"}
{"prompt": "def numOfArrays(self, n: int, m: int, K: int) -> int:\n        MOD = 10 ** 9 + 7\n        # f[i][j][k] cumulative sum, first i elements, current max less than or equal to j, k more maximum to fill\n        f = [[[0 for _ in range(K + 1)] for _ in range(m + 1)] for _ in range(n + 1)]\n        for j in range(m + 1):\n            f[0][j][K] = 1\n\n        for i in range(n + 1):\n            for j in range(1, m + 1):\n                for k in range(K):\n                    #             prev value       a[i] <= pref high                            a[i] = j refresh high\n                    f[i][j][k] = (f[i][j - 1][k] + j * (f[i - 1][j][k] - f[i - 1][j - 1][k]) + f[i - 1][j - 1][k + 1]) % MOD\n        \n        return f[n][m][0]"}
{"prompt": "def maxScore(self, s: str) -> int:\n        zeros = ones = 0\n        ans = float(\"-inf\")\n        \n        for i in range(len(s)-1):\n            if s[i] == \"0\": zeros += 1\n            else: ones -= 1\n            ans = max(ans, zeros + ones)\n        \n        return ans - ones + (1 if s[-1] == \"1\" else 0)"}
{"prompt": "def maxScore(self, cardPoints: List[int], k: int) -> int:\n        n = len(cardPoints)\n        total = sum(cardPoints)\n        \n        remaining_length = n - k\n        subarray_sum = sum(cardPoints[:remaining_length])\n        \n        min_sum = subarray_sum\n        for i in range(remaining_length, n):\n            # Update the sliding window sum to the subarray ending at index i\n            subarray_sum += cardPoints[i]\n            subarray_sum -= cardPoints[i - remaining_length]\n            # Update min_sum to track the overall minimum sum so far\n            min_sum = min(min_sum, subarray_sum)\n        return total - min_sum"}
{"prompt": "def findDiagonalOrder(self, nums: List[List[int]]) -> List[int]:\n        d = collections.defaultdict(list)\n        \n        for i in range(len(nums)):\n            for j in range(len(nums[i])):\n                d[(i+j)].append(nums[i][j])\n        \n        \n        ans = []\n        for key in d:\n            ans += d[key][::-1]\n        \n        return ans"}
{"prompt": "def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        dp = [0]*n\n        q = deque()\n\n        for i, num in enumerate(nums):\n            if i > k and q[0] == dp[i-k-1]:\n                q.popleft()\n            dp[i] = max(q[0] if q else 0, 0)+num\n\n            while q and q[-1] < dp[i]:\n                q.pop()\n            q.append(dp[i])\n        return max(dp)"}
{"prompt": "def kidsWithCandies(self, candies: List[int], extraCandies: int) -> List[bool]:\n        return [x+extraCandies >= max(candies) for x in candies]"}
{"prompt": "def maxDiff(self, num: int) -> int:\n        num = str(num)\n        \n        i = next((i for i in range(len(num)) if num[i] != \"9\"), -1) #first non-9 digit\n        hi = int(num.replace(num[i], \"9\"))\n        \n        if num[0] != \"1\": lo = int(num.replace(num[0], \"1\"))\n        else: \n            i = next((i for i in range(len(num)) if num[i] not in \"01\"), -1)\n            lo = int(num.replace(num[i], \"0\") if i > 0 else num)\n            \n        return hi - lo"}
{"prompt": "def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n        return all(a<=b for a,b in zip(min(sorted(s1),sorted(s2)),max(sorted(s1),sorted(s2))))```"}
{"prompt": "def numberWays(self, hats: List[List[int]]) -> int:\n        n = len(hats)\n        h2p = collections.defaultdict(list)\n        for p, hs in enumerate(hats):\n            for h in hs:\n                h2p[h].append(p)\n        full_mask = (1 << n) - 1\n        mod = 10**9 + 7\n        @functools.lru_cache(maxsize=None)\n        def count(h, mask):\n\t\t    # everyone wears a hat\n            if mask == full_mask:\n                return 1\n\t\t\t# ran out of hats\n            if h == 41:\n                return 0\n\t\t\t# skip the current hat h\n            ans = count(h + 1, mask)\n            for p in h2p[h]:\n\t\t\t    # if person p already has a hat\n                if mask &amp; (1 << p):\n                    continue\n\t\t\t\t# let person p wear hat h\n                ans += count(h + 1, mask | (1 << p))\n                ans %= mod\n            return ans\n\t\t# start from the first hat and no one wearing any hat\n        return count(1, 0)"}
{"prompt": "def destCity(self, paths: List[List[str]]) -> str:\n        lst=[]\n        arr=[]\n        for i in paths:\n            lst.append(i[0])\n            arr.append(i[1])\n        ptr=set(lst)\n        ptr2=set(arr)\n        return list(ptr2-ptr)[0]"}
{"prompt": "def kLengthApart(self, nums: List[int], k: int) -> bool:\n        indices = [i for i, x in enumerate(nums) if x == 1]\n        if not indices:\n            return True\n        for i in range(1, len(indices)):\n            if indices[i] - indices[i-1] < k + 1:\n                return False\n        return True"}
{"prompt": "def longestSubarray(self, nums: List[int], limit: int) -> int:\n        #[8,2,4,3,6,11] limit = 5\n\n        #if the new number is greater than max this becomes new max,\n        #if new number is less than min this becomes new min\n        #if max - min exceeds limit, pop the left most element -> if the left most element was max or min, recompute max - min and see if it goes limit\n\n        q = []\n        min_heap = []\n        max_heap = []\n        max_ans = 1\n        popped_index = set()\n\n        for i,v in enumerate(nums):\n\n            q.append((v,i))\n            # max_ans = max(max_ans,len(q))\n            heapq.heappush(min_heap,(v,i))\n            heapq.heappush(max_heap,(v*-1,i))\n            while(max_heap[0][0]*-1 - min_heap[0][0] > limit):\n                temp = q.pop(0)\n                popped_ele = temp[0]\n                popped_index.add(temp[1])\n\n                while(min_heap[0][1] in popped_index):\n                    heapq.heappop(min_heap)\n                \n                while(max_heap[0][1] in popped_index):\n                    heapq.heappop(max_heap)\n\n            if len(q) > max_ans:\n                max_ans = len(q)\n\n        return max_ans"}
{"prompt": "def kthSmallest(self, mat: List[List[int]], k: int) -> int:\n        row=len(mat)\n        col=len(mat[0])\n        temp=[i for i in mat[0]]\n        for i in range(1,row):\n            currSum=[]\n            for j in range(col):\n                for it in range(len(temp)):\n                    currSum.append(temp[it]+mat[i][j])\n            currSum.sort()\n            temp.clear()\n            maxSize=min(k,len(currSum))\n            for size in range(maxSize):\n                temp.append(currSum[size])\n        return temp[k-1]"}
{"prompt": "def buildArray(self, target: List[int], n: int) -> List[str]:\n        stack=[]\n        for i in range(1,n+1):\n            if(i in target):\n                stack.append(\"Push\")\n            else:\n                stack.append(\"Push\")\n                stack.append(\"Pop\")\n            if(i==(target[-1])):\n                break\n        return stack"}
{"prompt": "def countTriplets(self, arr: List[int]) -> int:\n        import collections\n        if len(arr) < 2:\n            return 0\n        xors = arr[0]\n        cnt = collections.Counter()\n        cnt_sums = collections.Counter()        \n        result = 0\n        cnt[xors] = 1\n        cnt_sums[xors] = 0\n        for k in range(1, len(arr)):\n            xors ^= arr[k]\n            if xors == 0:\n                result += k\n            result += (k - 1)*cnt[xors] - cnt_sums[xors]\n            cnt_sums[xors] += k\n            cnt[xors] += 1\n            \n        return result"}
{"prompt": "def minTime(self, n: int, edges: List[List[int]], hasApple: List[bool]) -> int:\n        self.res = 0\n        d = collections.defaultdict(list)\n        \n        for e in edges: # construct the graph\n            d[e[0]].append(e[1])\n            d[e[1]].append(e[0])\n            \n        seen = set() # initialise seen set for visited nodes\n        seen.add(0) # add root to visited\n        \n        def dfs(key):\n            # we initialize the go_thru state as 0, meaning we do not go through this node from root\n            # there are two cases where we would set go_thru == 1: \n            #(1) when this is the apple node, so we must visit it and go back up\n            #(2) when this node has apple nodes as descendants below, we must go down and come back\n            go_thru = 0 \n            if hasApple[key]: # case 1\n                go_thru = 1\n    \n            for i in d[key]:\n                if i not in seen:\n                    seen.add(i)\n                    a = dfs(i)    \n                    if a: # case 2, note that having just one path with an apple node below would require us to go through our current node, \n\t\t\t\t\t\t  # i.e we don't need both the paths to have apples\n                        go_thru = 1\n            \n            if key != 0: # since 0 is already the root, there is no way we can go through 0 to a node above\n                self.res += 2 * go_thru # passing one node means forward and backward, so 1 * 2 for going through, 0 * 2 for not\n            return go_thru\n        \n        dfs(0)\n        return self.res"}
{"prompt": "def ways(self, pizza: List[str], k: int) -> int:\n        rows, cols = len(pizza), len(pizza[0])\n        \n        # first, need way to query if a section contains an apple given a top left (r1, c1) and bottom right (r2, c2)\n        # we can do this in constant time by keeping track of the number of apples above and to the left of any given cell\n        apples = [[0] * cols for _ in range(rows)]\n        for row in range(rows):\n            apples_left = 0\n            for col in range(cols):\n                if pizza[row][col] == 'A':\n                    apples_left += 1\n                apples[row][col] = apples[row-1][col] + apples_left\n              \n        # query if there is an apple in this rectangle using the prefix sums\n        def has_apple(r1, c1, r2 = rows-1, c2 = cols-1) -> bool:\n            if r1 > r2 or c1 > c2:\n                return False\n            tot = apples[r2][c2]\n            left_sub = apples[r2][c1-1] if c1 > 0 else 0\n            up_sub = apples[r1-1][c2] if r1 > 0 else 0\n            upleft_sub = apples[r1-1][c1-1] if r1 > 0 < c1 else 0\n            in_rect = tot - left_sub - up_sub + upleft_sub\n            return in_rect > 0\n        \n        # memory optimized dp, keep track of only one matrix of rows x cols\n        # bc we only need to access the values at the previous number of cuts\n        dp = [[1 if has_apple(r, c) else 0 for c in range(cols + 1)] for r in range(rows + 1)]\n        \n        for cuts in range(1, k):\n            new_dp = [[0] * (cols + 1) for _ in range(rows + 1)]\n            for row in range(rows-1, -1, -1):\n                for col in range(cols-1, -1, -1):\n                    \n                    for r2 in range(row, rows):\n                        if has_apple(row, col, r2):\n                            new_dp[row][col] += dp[r2+1][col]\n                            \n                    for c2 in range(col, cols):\n                        if has_apple(row, col, rows-1, c2):\n                            new_dp[row][col] += dp[row][c2+1]\n            dp = new_dp\n                            \n        return dp[0][0] % (10**9 + 7)"}
{"prompt": "def maxPower(self, s: str) -> int:\n        \n        # the minimum value for consecutive is 1\n        local_max, global_max = 1, 1\n        \n        # dummy char for initialization\n        prev = '#'\n        for char in s:\n            \n            if char == prev:\n                \n                # keeps consecutive, update local max\n                local_max += 1\n                \n                # update global max length with latest one\n                global_max = max( global_max, local_max )\n                \n            else:\n                \n                # lastest consective chars stops, reset local max\n                local_max = 1\n            \n                # update previous char as current char for next iteration\n                prev = char\n        \n        \n        return global_max"}
{"prompt": "def simplifiedFractions(self, n: int) -> List[str]:\n        if n == 1:\n            return []\n        else:\n            numerator = list(range(1,n))\n            denominator = list(range(2,n+1))\n            res = set()\n            values = set()\n            for i in numerator:\n                for j in denominator:\n                    if i < j and i/j not in values:\n                        res.add(f'{i}/{j}')\n                        values.add(i/j)\n            return res"}
{"prompt": "def goodNodes(self, root: TreeNode) -> int:\n        def solve(root,val):\n            if root:\n                k = solve(root.left, max(val,root.val)) + solve(root.right, max(val,root.val))\n                if root.val >= val:\n                    k+=1\n                return k\n            return 0\n        return solve(root,root.val)"}
{"prompt": "def largestNumber(self, cost: List[int], target: int) -> str:\n        \n        @cache\n        def fn(x): \n            \"\"\"Return max integer given target x.\"\"\"\n            if x == 0: return 0\n            if x < 0: return -inf \n            return max(fn(x - c) * 10 + i + 1 for i, c in enumerate(cost))\n        \n        return str(max(0, fn(target)))"}
{"prompt": "def busyStudent(self, startTime: List[int], endTime: List[int], queryTime: int) -> int:\n        count = 0 # If a value meets the criteria, one will be added here.\n\n        for x, y in zip(startTime, endTime): # Zipping the two lists to allow us to iterate over them using x,y as our variables.\n            if x <= queryTime <= y: # Checking if the queryTime number is between startTime and endTime, adding one to count if it is.\n                    count += 1\n        return count # Returning the value in count"}
{"prompt": "def arrangeWords(self, text: str) -> str:\n        return \" \".join(sorted(text.split(), key=len)).capitalize()"}
{"prompt": "def peopleIndexes(self, favoriteCompanies: List[List[str]]) -> List[int]:\n\n        n = len(favoriteCompanies)\n        comp = []\n        for f in favoriteCompanies:\n            comp += f\n        comp = list(set(comp))\n  \n        dictBit = {comp[i] : 1 << i for i in range(len(comp))}\n\n        def getBit(cList):\n            output = 0\n            for c in cList:\n                output |= dictBit[c]\n            return output\n        bitFav = [getBit(favoriteCompanies[i]) for i in range(n)]\n\n        output = []\n        for i in range(n):\n            isGood = True\n            for j in range(n):\n                if(i != j and bitFav[i] &amp; bitFav[j] == bitFav[i]):\n                    isGood = False\n                    break\n            if(isGood):\n                output.append(i)\n    \n        return output"}
{"prompt": "def numPoints(self, points: List[List[int]], r: int) -> int:\n        ans = 1\n        for x, y in points: \n            angles = []\n            for x1, y1 in points: \n                if (x1 != x or y1 != y) and (d:=sqrt((x1-x)**2 + (y1-y)**2)) <= 2*r: \n                    angle = atan2(y1-y, x1-x)\n                    delta = acos(d/(2*r))\n                    angles.append((angle-delta, +1)) #entry\n                    angles.append((angle+delta, -1)) #exit\n            angles.sort(key=lambda x: (x[0], -x[1]))\n            val = 1\n            for _, entry in angles: \n                ans = max(ans, val := val+entry)\n        return ans"}
{"prompt": "def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\n        for i , j in enumerate(sentence.split()):\n            if(j.startswith(searchWord)):\n                return i + 1\n        \n        return -1"}
{"prompt": "def maxVowels(self, s: str, k: int) -> int:\n        x = 0\n        for i in range(k):\n            if s[i] in ('a', 'e', 'i', 'o', 'u'):\n                x += 1\n        ans = x\n        for i in range(k,len(s)):\n            if s[i] in ('a', 'e', 'i', 'o', 'u'):\n                x += 1\n            if s[i-k] in ('a', 'e', 'i', 'o', 'u'):\n                x -= 1\n            ans = max(ans,x)\n        return ans"}
{"prompt": "def pseudoPalindromicPaths (self, root: Optional[TreeNode], cnt = 0) -> int:\n        if not root: return 0\n        cnt ^= 1 << (root.val - 1)\n        if root.left is None and root.right is None:\n            return 1 if cnt &amp; (cnt - 1) == 0 else 0\n        return self.pseudoPalindromicPaths(root.left, cnt) + self.pseudoPalindromicPaths(root.right, cnt)"}
{"prompt": "def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        n=len(nums1)\n        m=len(nums2)\n        \n        dp=[[0]*(m+1) for i in range(n+1)]\n        for i in range(m+1):\n            dp[0][i]=-1e9\n        for i in range(n+1):\n            dp[i][0]=-1e9\n        \n        for i in range(1, n+1):\n            for j in range(1, m+1):\n                val=nums1[i-1]*nums2[j-1]+max(0, dp[i-1][j-1])\n                dp[i][j]=max(val, max(dp[i-1][j], dp[i][j-1]))\n        return dp[n][m]"}
{"prompt": "def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n        n, m = len(target), len(arr)\n        if m > n:\n            return False\n        t = Counter(target)\n        a = Counter(arr)\n        for k, v in a.items():\n            if k in t and v == t[k]:\n                continue\n            else:\n                return False\n        return True"}
{"prompt": "def hasAllCodes(self, s: str, k: int) -> bool:                \n        return len({s[i:i+k] for i in range(len(s)-k+1)}) == 2 ** k"}
{"prompt": "def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n        #Let m = len(prereqs) and z = len(queries)\n        #Time: O(m + n + n*n + z) -> O(n^2)\n        #Space: O(n*n + n + n*n + n + z) -> O(n^2)\n        \n        \n        #process the prerequisites and build an adjacency list graph\n        #where edges go from prerequisite to the course that depends on the prereq!\n        n = numCourses\n        #Adjacency List graph!\n        adj = [set() for _ in range(n)]\n        #indegrees array!\n        indegrees = [0] * n\n        #tell us every ith node's set of ancestors or all prereqs to take ith course!\n        ancestors = [set() for _ in range(n)]\n        #iterate through prereqs and update indegrees array as well as the adj list!\n        for i in range(len(prerequisites)):\n            prereq, main = prerequisites[i][0], prerequisites[i][1]\n            adj[prereq].add(main)\n            indegrees[main] += 1\n        \n        queue = deque()\n        #iterate through the indegrees array and add all courses that have no \n        #ancestors(no prerequisites to take it!)\n        for a in range(len(indegrees)):\n            #ath course can be taken without any prereqs -> first to be processed in\n            #the Kahn's BFS algo!\n            if(indegrees[a] == 0):\n                queue.append(a)\n        #proceed with Kahn's algo!\n        while queue:\n            cur_course = queue.pop()\n            neighbors = adj[cur_course]\n            for neighbor in neighbors:\n                #neighbor has one less incoming edge!\n                indegrees[neighbor] -= 1\n                #current course is a prerequisite to every neighboring node!\n                ancestors[neighbor].add(cur_course)\n                #but also, all prereqs of cur_course is also indirectly a prereq\n                #to each and every neighboring courses!\n                ancestors[neighbor].update(ancestors[cur_course])\n                #if neighboring node suddenly becomes can take with no prereqs,\n                #add it to the queue!\n                if(indegrees[neighbor] == 0):\n                    queue.append(neighbor)\n        #once the algorithm ends, our ancestors array will have info regarding\n        #prerequisites in order to take every course from 0 to n-1!\n        output = []\n        for query in queries:\n            prereq2, main2 = query[0], query[1]\n            all_prereqs = ancestors[main2]\n            #check if prereq2 is an ancestor or required prereq course to take main2!\n            if(prereq2 in all_prereqs):\n                output.append(True)\n                continue\n            else:\n                output.append(False)\n                \n        \n        return output"}
{"prompt": "def cherryPickup(self, grid: List[List[int]]) -> int:\n        rows, cols = len(grid), len(grid[0])\n        \n        dp = [[[0]*(cols + 2) for _ in range(cols + 2)] for _ in range(rows + 1)]\n        \n        def get_next_max(row, col_r1, col_r2):\n            res = 0\n            for next_col_r1 in (col_r1 - 1, col_r1, col_r1 + 1):\n                for next_col_r2 in (col_r2 - 1, col_r2, col_r2 + 1):\n                    res = max(res, dp[row + 1][next_col_r1 + 1][next_col_r2 + 1])\n\n            return res\n        \n        for row in reversed(range(rows)):\n            for col_r1 in range(min(cols, row + 2)):\n                for col_r2 in range(max(0, cols - row - 1), cols):\n\n                    reward = grid[row][col_r1] + grid[row][col_r2]\n                    if col_r1 == col_r2:\n                        reward /= 2\n                    \n                    dp[row][col_r1 + 1][col_r2 + 1] = reward + get_next_max(row, col_r1, col_r2)\n                    \n        return dp[0][1][cols]"}
{"prompt": "def maxProduct(self, nums: List[int]) -> int:\n        # approach 1: find 2 max numbers in 2 loops. T = O(n). S = O(1)\n\t\t# approach 2: sort and then get the last 2 max elements. T = O(n lg n). S = O(1)\n\t\t# approach 3: build min heap of size 2. T = O(n lg n). S = O(1)\n\t\t# python gives only min heap feature. heaq.heappush(list, item). heapq.heappop(list)\n        \n        heap = [-1]\n        for num in nums:\n            if num > heap[0]:\n                if len(heap) == 2:\n                    heapq.heappop(heap)\n                heapq.heappush(heap, num)\n                \n        return (heap[0]-1) * (heap[1]-1)"}
{"prompt": "def maxArea(self, h: int, w: int, hc: List[int], vc: List[int]) -> int:\n        \n        hc.sort()\n        vc.sort()\n        \n        maxh = hc[0]\n        maxv = vc[0]\n        \n        for i in range(1, len(hc)):\n            maxh = max(maxh, hc[i] - hc[i-1])\n        maxh = max(maxh, h - hc[-1])\n        \n        for i in range(1, len(vc)):\n            maxv = max(maxv, vc[i] - vc[i-1])\n        maxv = max(maxv, w - vc[-1])\n        \n        return maxh*maxv % (10**9 + 7)"}
{"prompt": "def minReorder(self, n: int, connections: List[List[int]]) -> int:\n        cmap = {0}\n        count = 0\n        dq = deque(connections)\n        while dq:\n            u, v = dq.popleft()\n            if v in cmap:\n                cmap.add(u)\n            elif u in cmap:\n                cmap.add(v)\n                count += 1\n            else:\n                dq.append([u, v])\n        return count"}
{"prompt": "def getProbability(self, balls: List[int]) -> float:\n        n = sum(balls)//2\n        \n        @cache \n        def fn(i, s0, s1, c0, c1):\n            \"\"\"Return number of ways to distribute boxes successfully (w/o considering relative order).\"\"\"\n            if s0 > n or s1 > n: return 0 # impossible \n            if i == len(balls): return int(c0 == c1)\n            ans = 0 \n            for x in range(balls[i]+1): \n                ans += fn(i+1, s0+x, s1+balls[i]-x, c0+(x > 0), c1+(x < balls[i])) * comb(balls[i], x)\n            return ans\n        \n        return fn(0, 0, 0, 0, 0) / comb(2*n, n)"}
{"prompt": "def shuffle(self, nums: List[int], n: int) -> List[int]:\n        l=[]\n        for i in range(n):\n            l.append(nums[i])\n\t\t\tl.append(nums[n+i])\n        return l"}
{"prompt": "def getStrongest(self, arr: List[int], k: int) -> List[int]:\n        new_arr = []\n        arr.sort()\n        med = arr[int((len(arr) - 1)//2)]\n        for num in arr : \n            new_arr.append([int(abs(num - med)), num])\n            \n        new_arr = sorted(new_arr, key = lambda x : (x[0], x[1]))\n        \n        output, counter = [], 0\n        for i in reversed(range(len(new_arr))) : \n            output.append(new_arr[i][1])\n            counter += 1 \n            if counter == k : \n                return output \n            \n        return output"}
{"prompt": "def minCost1(self, houses: List[int], cost: List[List[int]], R: int, C: int, target: int) -> int:\n        # think as if we are traveling downward\n        # at any point, if switch our column then (target--)\n        \n        @functools.cache\n        def dp(x,y,k): # O(100*20*100) time space\n            if x == R:\n                return 0 if k == 0 else math.inf\n            elif k <= 0: \n                return math.inf\n            \n            # if this house is already colored, dont recolor!!\n            if houses[x] > 0 and houses[x] != y+1: return math.inf\n            \n            cur_cost = 0 if houses[x] == y+1 else cost[x][y] \n            \n            # now try all columns! O(20) time\n            res = math.inf\n            for c in range(C):\n                if c == y:\n                    res = min(res, cur_cost + dp(x+1,c,k))\n                else:\n                    res = min(res, cur_cost + dp(x+1,c,k-1))\n            # print('dp',x,y,k,'=',res)\n            return res\n        \n        ans = min(dp(0,y,target) for y in range(C))\n        \n        return -1 if ans == math.inf else ans"}
{"prompt": "def finalPrices(self, prices: List[int]) -> List[int]:\n        len_prices = len(prices)\n        i = 0\n        while i <= len_prices-2:\n            for j in range(i+1, len(prices)):\n                if prices[i] >= prices[j] and j > i:\n                    prices[i] = prices[i] - prices[j]\n                    break\n            \n            i += 1\n        \n        return prices"}
{"prompt": "def minSumOfLengths(self, arr: List[int], target: int) -> int:\n        l, windowSum, res = 0, 0, float('inf')\n        min_till = [float('inf')] * len(arr) # records smallest lenth of subarry with target sum up till index i.\n        for r, num in enumerate(arr): # r:right pointer and index of num in arr\n            windowSum += num\n            while windowSum > target: \n\t\t\t# when the sum of current window is larger then target, shrink the left end of the window one by one until windowSum <= target\n                windowSum -= arr[l]\n                l += 1\n\t\t\t# the case when we found a new target sub-array, i.e. current window\n            if windowSum == target:\n\t\t\t   # length of current window\n                curLen = r - l + 1\n\t\t\t\t# min_till[l - 1]: the subarray with min len up till the previous position of left end of the current window: \n\t\t\t\t# avoid overlap with cur window\n\t\t\t\t# new_sum_of_two_subarray = length of current window + the previous min length of target subarray without overlapping\n\t\t\t\t# , if < res, update res.\n                res = min(res, curLen + min_till[l - 1])\n\t\t\t\t# Everytime we found a target window, update the min_till of current right end of the window, \n\t\t\t\t# for future use when sum up to new length of sum_of_two_subarray and update the res.\n                min_till[r] = min(curLen, min_till[r - 1])\n            else:\n\t\t\t# If windowSum < target: window with current arr[r] as right end does not have any target subarry, \n\t\t\t# the min_till[r] doesn't get any new minimum update, i.e it equals to previous min_till at index r - 1. \n                min_till[r] = min_till[r - 1]\n        return res if res < float('inf') else -1\n\t\nTime = O(n): when sliding the window, left and right pointers traverse the array once.\nSpace = O(n): we use one additional list min_till[] to record min length of target subarray till index i."}
{"prompt": "def minDistance(self, houses: List[int], k: int) -> int:\n    \n    n = len(houses)\n    houses.sort()\n    cost = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(i+1,n):\n            mid_house = houses[(i+j)//2]\n            for t in range(i,j+1):\n                cost[i][j]+= abs(mid_house-houses[t])\n    \n    @lru_cache(None)\n    def dp(k,ind):\n        if k==0 and ind==n: return 0\n        if k==0 or ind==n: return float('inf')\n        res = float('inf')\n        for j in range(ind,n):\n            c = cost[ind][j]\n            res = min(res, c + dp(k-1,j+1))\n        \n        return res\n    \n    return dp(k,0)"}
{"prompt": "def runningSum(self, nums):\n        result = []\n        current_sum = 0\n        for i in range(0, len(nums)):\n            result.append(current_sum + nums[i])\n            current_sum = result[i]\n        return result"}
{"prompt": "def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n\n        count = Counter(arr)\n        ans = len(count)\n        for i in sorted(count.values()):\n            k -= i\n            if k < 0:\n                break\n            ans -= 1\n        return ans"}
{"prompt": "def checker(self,arr, d, m, k) -> bool:\n        '''\n        d -> days\n        m -> bouquets\n        k -> adjacent flowers\n        \n        return bool\n        '''\n        arr = [10**9] + arr + [10**9] #appending array with maximum values\n        idx = []\n        for i in range(len(arr)):\n            if arr[i] > d:\n                idx.append(i)\n        cnt = 0\n        for i in range(len(idx)-1):\n            # how many bouquet can we make out of an interval of valid flowers \n            cnt += (idx[i+1] - idx[i] - 1) // k\n        \n        # return if count >= m\n        return cnt >= m\n\n    def minDays(self, arr: List[int], m: int, k: int) -> int:\n        if m*k > len(arr):\n            return -1\n        lo, hi = 1, max(arr)\n        \n        while(hi >= lo):\n            mid = (hi+lo)//2\n            if(self.checker(arr, mid, m, k) == True):\n                hi = mid\n            else:\n                lo = mid+1\n            if(hi == lo): break\n    \n        if self.checker(arr, lo, m, k):\n            return lo\n        else:\n            return hi"}
{"prompt": "def xorOperation(self, n: int, start: int) -> int:\n        ans=0\n        for i in range(n):\n            ans^=start+(2*i)\n        return ans"}
{"prompt": "def getFolderNames(self, names: List[str]) -> List[str]:\n        # names : array of names\n        # n : size of names\n        \n        # create folders at the i'th minute for each name = names[i]\n        # If name was used previously, append a suffix \"(k)\" - note parenthesis - where k is the smallest pos int\n        \n        # return an array of strings where ans[i] is the actual saved variant of names[i]\n        \n        n = len(names)\n        \n        dictNames = {}\n        ans = ['']*n\n        \n        # enumerate to grab index so we can return ans list in order\n        for idx, name in enumerate(names):\n            # check if we have seen this name before\n            if name in dictNames:\n                # if we have grab the next k using last successful low (k) suffix\n                k = dictNames[name]\n                # track the name we started so we can update the dict\n                namestart = name\n                # cycle through values of increasing k until we are not in a previously used name\n                while name in dictNames:\n                    name = namestart + f\"({k})\"\n                    k += 1\n                # update the name we started with to the new lowest value of k\n                dictNames[namestart] = k\n                # add the new name with k = 1 so if we see this name with the suffix\n                dictNames[name] = 1\n            else:\n                # we havent seen this name so lets start with 1\n                dictNames[name] = 1\n            # build the solution\n            ans[idx] = name\n        return ans"}
{"prompt": "def avoidFlood(self, rains: List[int]) -> List[int]:\n        pq = []\n        fill = set()\n        d = collections.defaultdict(list)\n        ans = []\n        \n        for i, rain in enumerate(rains):\n            d[rain].append(i)\n        \n        for rain in rains:\n            if rain > 0:\n                if rain in fill:\n                    return []\n                fill.add(rain)\n                d[rain].pop(0)\n                if d[rain]:\n                    heapq.heappush(pq, d[rain][0])\n                ans.append(-1)\n            else:\n                if pq:\n                    ind = heapq.heappop(pq)\n                    ans.append(rains[ind])\n                    fill.remove(rains[ind])\n                else:\n                    ans.append(1)\n        \n        return ans"}
{"prompt": "def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n        graph = dict()\n        for u, v, w in edges: \n            graph.setdefault(u, []).append((v, w))\n            graph.setdefault(v, []).append((u, w))\n            \n        ref = self.mst(n, graph)\n        critical, pseudo = [], []\n        for i in range(len(edges)):\n            if self.mst(n, graph, exclude=edges[i][:2]) > ref: critical.append(i)\n            elif self.mst(n, graph, init=edges[i]) == ref: pseudo.append(i)\n        return [critical, pseudo]\n            \n        \n    def mst(self, n, graph, init=None, exclude=None):\n        \"\"\"Return weight of MST of given graph using Prim's algo\"\"\"\n\n        def visit(u): \n            \"\"\"Mark node and put its edges to priority queue\"\"\"\n            marked[u] = True\n            for v, w in graph.get(u, []):\n                if exclude and u in exclude and v in exclude: continue\n                if not marked[v]: heappush(pq, (w, u, v))\n                    \n        ans = 0\n        marked = [False]*n\n        pq = [] #min prioirty queue\n        \n        if init: \n            u, v, w = init\n            ans += w\n            marked[u] = marked[v] = True\n            visit(u) or visit(v)\n        else:\n            visit(0)\n\n        while pq: \n            w, u, v = heappop(pq)\n            if marked[u] and marked[v]: continue\n            ans += w\n            if not marked[u]: visit(u)\n            if not marked[v]: visit(v)\n                \n        return ans if all(marked) else inf"}
{"prompt": "def average(self, salary: List[int]) -> float:\n        minimum = float(\"inf\")\n        maximum = float(\"-inf\")\n        \n        i = 0\n        sums = 0\n        while i<len(salary):\n            minimum = min(minimum, salary[i])\n            maximum = max(maximum, salary[i])\n            sums+=salary[i]\n            i+=1\n        \n        return (sums - (maximum+minimum))/(i-2)"}
{"prompt": "def kthFactor(self, n: int, k: int) -> int:\n        factors = []\n        for i in range(1,n+1):\n            if n % i == 0:\n                factors.append(i)\n        if k > len(factors):\n            return -1\n        else:\n            return factors[k-1]"}
{"prompt": "def longestSubarray(self, nums: List[int]) -> int:\n        m=0\n        l=len(nums)\n        one=True\n        for i in range(0,l):\n            if nums[i]==0:\n                one=False\n                left=i-1\n                right=i+1\n                ones=0\n                while left>=0:\n                    if nums[left]==1:\n                        ones=ones+1\n                        left=left-1\n                    else:\n                        break\n                while right<l:\n                    if nums[right]==1:\n                        ones=ones+1\n                        right=right+1\n                    else:\n                        break\n                if ones>m:\n                    m=ones\n        if one:\n            return l-1\n        return m"}
{"prompt": "def minNumberOfSemesters(self, n: int, dependencies: List[List[int]], k: int) -> int:\n        pre = [0]*n # prerequisites \n        for u, v in dependencies: \n            pre[v-1] |= 1 << (u-1) \n            \n        @cache\n        def fn(mask): \n            \"\"\"Return min semesters to take remaining courses.\"\"\"\n            if mask == (1 << n) - 1: return 0 # all courses taken \n            can = [] # available courses \n            for i in range(n): \n                if not mask &amp; 1 << i and mask &amp; pre[i] == pre[i]: \n                    can.append(i)\n            \n            ans = inf\n            for courses in combinations(can, min(k, len(can))): \n                temp = mask | reduce(lambda x, y: x | 1 << y, courses, 0)\n                ans = min(ans, 1 + fn(temp))\n            return ans \n        \n        return fn(0)"}
{"prompt": "def isPathCrossing(self, path: str) -> bool:\n        l = [(0,0)]\n        x,y = 0,0\n        for i in path:\n            if i == 'N':\n                y += 1\n            if i == 'S':\n                y -= 1\n            if i == 'E':\n                x += 1\n            if i == 'W':\n                x -= 1\n            if (x,y) in l:\n                return True\n            else:\n                l.append((x,y))\n        return False"}
{"prompt": "def canArrange(self, arr: List[int], k: int) -> bool:\n        freq = dict()\n        for x in arr: freq[x%k] = 1 + freq.get(x%k, 0)\n        return all(freq[x] == freq.get(xx:=(k-x)%k, 0) and (x != xx or freq[x]%2 == 0) for x in freq)"}
{"prompt": "def numSubseq(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        \n        nums.sort()\n        i, j = 0, n-1\n        \n        \n        res = 0 \n        NUM = 10**9+7\n        while i <= j:\n            if nums[i] + nums[j] > target:\n                j -= 1\n            elif nums[i] + nums[j] <= target:\n                res += pow(2, j-i, NUM)\n                i += 1\n            #else: # nums[i] + nums[j] == target\n                \n            \n            \n        return res % NUM"}
{"prompt": "def findMaxValueOfEquation(self, points: List[List[int]], k: int) -> int:\n        ans = -inf\n        hp = [] \n        for xj, yj in points:\n            while hp and xj - hp[0][1] > k: heappop(hp)\n            if hp: \n                ans = max(ans, xj + yj - hp[0][0])\n            heappush(hp, (xj-yj, xj))\n        return ans"}
{"prompt": "def canMakeArithmeticProgression(self, arr: List[int]) -> bool:\n        arr.sort()\n        return len(set(arr[i-1] - arr[i] for i in range(1, len(arr)))) == 1"}
{"prompt": "def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\n        if left and not right:\n            return max(left)\n        if not left and right:\n            return n - min(right)\n        if not left and not right:\n            return 0\n        if left and right:\n            return max(max(left), n - min(right))"}
{"prompt": "def numSubmat(self, mat: List[List[int]]) -> int:\n        m, n = len(mat), len(mat[0])\n        \n        #precipitate mat to histogram \n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] and i > 0: \n                    mat[i][j] += mat[i-1][j] #histogram \n        \n        ans = 0\n        for i in range(m):\n            stack = [] #mono-stack of indices of non-decreasing height\n            cnt = 0\n            for j in range(n):\n                while stack and mat[i][stack[-1]] > mat[i][j]: \n                    jj = stack.pop()                          #start\n                    kk = stack[-1] if stack else -1           #end\n                    cnt -= (mat[i][jj] - mat[i][j])*(jj - kk) #adjust to reflect lower height\n\n                cnt += mat[i][j] #count submatrices bottom-right at (i, j)\n                ans += cnt\n                stack.append(j)\n\n        return ans"}
{"prompt": "def minInteger(self, num: str, k: int) -> str:\n        n = len(num)\n        if k >= n*(n-1)//2: return \"\".join(sorted(num)) #special case\n        \n        #find smallest elements within k swaps \n        #and swap it to current position \n        num = list(num)\n        for i in range(n):\n            if not k: break \n            #find minimum within k swaps\n            ii = i\n            for j in range(i+1, min(n, i+k+1)): \n                if num[ii] > num[j]: ii = j \n            #swap the min to current position \n            if ii != i: \n                k -= ii-i\n                for j in range(ii, i, -1):\n                    num[j-1], num[j] = num[j], num[j-1]\n        return \"\".join(num)"}
{"prompt": "def reformatDate(self, date: str) -> str:\n        s = date.split() # Divides the elements into 3 individual parts\n        \n        monthDict = {'Jan': '01', 'Feb': '02', \n                     'Mar': '03', 'Apr': '04', \n                     'May': '05', 'Jun': '06', \n                     'Jul': '07', 'Aug': '08', \n                     'Sep': '09', 'Oct': '10', \n                     'Nov': '11', 'Dec': '12'}\n        \n        day = s[0][:-2] # Removes the last 2 elements of the day\n        month = s[1] \n        year = s[2]\n        \n        if int(day) < 10: # Adds 0 to the front of day if day < 10\n            day = '0' + day\n        \n        return ''.join(f'{year}-{monthDict[month]}-{day}') # Joins it all together. Month is used to draw out the corresponding number from the dict."}
{"prompt": "def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        ans = []\n        for i in range(len(nums)):\n            prefix = 0\n            for ii in range(i, len(nums)):\n                prefix += nums[ii]\n                ans.append(prefix)\n        ans.sort()\n        return sum(ans[left-1:right]) % 1_000_000_007"}
{"prompt": "def minDifference(self, nums: List[int]) -> int:\n        \n        n = len(nums)\n        # If nums are less than 3 all can be replace,\n        # so min diff will be 0, which is default condition\n        if n > 3:\n            \n            # Init min difference\n            min_diff = float(\"inf\")\n            \n            # sort the array\n            nums = sorted(nums)\n            \n            # Get the window size, this indicates, if we\n            # remove 3 element in an array how many element\n            # are left, consider 0 as the index, window\n            # size should be (n-3), but for array starting\n            # with 0 it should be ((n-1)-3)\n            window = (n-1)-3\n            \n            # Run through the entire array slinding the\n            # window and calculating minimum difference\n            # between the first and the last element of\n            # that window\n            for i in range(n):\n                if i+window >= n:\n                    break\n                else:\n                    min_diff = min(nums[i+window]-nums[i], min_diff)\n                    \n            # return calculated minimum difference\n            return min_diff\n        \n        return 0 # default condition"}
{"prompt": "def winnerSquareGame(self, n: int) -> bool:\n        dp = [False] * (n + 1)\n        squares = []\n        curSquare = 1\n        for i in range(1, n + 1):\n            if i == curSquare * curSquare:\n                squares.append(i)\n                curSquare += 1\n                dp[i] = True\n            else:\n                for square in squares:\n                    if not dp[i - square]:\n                        dp[i] = True\n                        break\n        return dp[n]"}
{"prompt": "def numIdenticalPairs(self, nums: List[int]) -> int:\n        hashMap = {}\n        res = 0\n        for number in nums:            \n            if number in hashMap:\n                res += hashMap[number]\n                hashMap[number] += 1\n            else:\n                hashMap[number] = 1\n        return res"}
{"prompt": "def numSub(self, s: str) -> int: \n            res = 0\n            s = s.split(\"0\")\n\n            for one in s:\n                if one == \"\":\n                    continue\n                    \n                n = len(one)\n                temp = (n / 2)*(2*n + (n-1)*-1)\n                    \n                if temp >= 1000000007:\n                    res += temp % 1000000007\n                else:\n                    res += temp\n            return int(res)"}
{"prompt": "def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n        graph, prob = dict(), dict() #graph with prob\n        for i, (u, v) in enumerate(edges):\n            graph.setdefault(u, []).append(v)\n            graph.setdefault(v, []).append(u)\n            prob[u, v] = prob[v, u] = succProb[i]\n        \n        h = [(-1, start)] #Dijkstra's algo\n        seen = set()\n        while h: \n            p, n = heappop(h)\n            if n == end: return -p\n            seen.add(n)\n            for nn in graph.get(n, []):\n                if nn in seen: continue \n                heappush(h, (p * prob.get((n, nn), 0), nn))\n        return 0"}
{"prompt": "def getMinDistSum(self, positions: List[List[int]]) -> float:\n        #euclidean distance \n        fn = lambda x, y: sum(sqrt((x-xx)**2 + (y-yy)**2) for xx, yy in positions)\n        #centroid as starting point\n        x = sum(x for x, _ in positions)/len(positions)\n        y = sum(y for _, y in positions)/len(positions)\n        \n        ans = fn(x, y)\n        chg = 100 #change since 0 <= positions[i][0], positions[i][1] <= 100\n        while chg > 1e-6: #accuracy within 1e-5\n            zoom = True\n            for dx, dy in (-1, 0), (0, -1), (0, 1), (1, 0):\n                xx = x + chg * dx\n                yy = y + chg * dy\n                dd = fn(xx, yy)\n                if dd < ans: \n                    ans = dd \n                    x, y = xx, yy\n                    zoom = False \n                    break \n            if zoom: chg /= 2\n        return ans"}
{"prompt": "def numWaterBottles(self, numBottles: int, numExchange: int) -> int:\n        ans = r = 0\n        while numBottles:\n            ans += numBottles\n            numBottles, r = divmod(numBottles + r, numExchange)\n        return ans"}
{"prompt": "def countSubTrees(self, n: int, edges: List[List[int]], labels: str) -> List[int]:\n        ans = [0] * n\n        tree = collections.defaultdict(list)\n        for a, b in edges:                             # build tree\n            tree[a].append(b)\n            tree[b].append(a)\n        def dfs(node):                                 # dfs\n            nonlocal visited, ans, tree\n            c = collections.Counter(labels[node])\n            for nei in tree[node]:\n                if nei in visited: continue            # avoid revisit\n                visited.add(nei)\n                c += dfs(nei)                          # add counter (essentially adding a 26 elements dictionary)\n            ans[node] = c.get(labels[node])            # assign count of label to this node\n            return c\n        visited = set([0])\n        dfs(0)\n        return ans"}
{"prompt": "def maxNumOfSubstrings(self, s: str) -> List[str]:\n        locs = {}\n        for i, x in enumerate(s): \n            locs.setdefault(x, []).append(i)\n        \n        def fn(lo, hi): \n            \"\"\"Return expanded range covering all chars in s[lo:hi+1].\"\"\"\n            for xx in locs: \n                k0 = bisect_left(locs[xx], lo)\n                k1 = bisect_left(locs[xx], hi)\n                if k0 < k1 and (locs[xx][0] < lo or hi < locs[xx][-1]): \n                    lo = min(lo, locs[xx][0])\n                    hi = max(hi, locs[xx][-1])\n                    lo, hi = fn(lo, hi)\n            return lo, hi\n        \n        group = set()\n        for x in locs: \n            group.add(fn(locs[x][0], locs[x][-1]))\n        \n        ans = [] # ISMP (interval scheduling maximization problem)\n        prev = -1 \n        for lo, hi in sorted(group, key=lambda x: x[1]): \n            if prev < lo: \n                ans.append(s[lo:hi+1])\n                prev = hi \n        return ans"}
{"prompt": "def closestToTarget(self, arr: List[int], target: int) -> int:\n        ans, seen = inf, set()\n        for x in arr: \n            seen = {ss &amp; x for ss in seen} | {x}\n            ans = min(ans, min(abs(ss - target) for ss in seen))\n        return ans"}
{"prompt": "def countOdds(self, low: int, high: int) -> int:\n    if low % 2 == 0:\n      return (high-low+1)//2\n    return (high-low)//2 + 1"}
{"prompt": "def numOfSubarrays(self, arr: List[int]) -> int:\n        cumSum = odd = even = 0\n        for num in arr:\n            cumSum += num\n            if cumSum % 2:\n                odd += 1\n            else:\n                even += 1\n        return odd * (even + 1) % (pow(10, 9) + 7)"}
{"prompt": "def numSplits(self, s: str) -> int:\n\t\t# this is not neccessary, but speeds things up\n        length = len(s)\n        if length == 1:  # never splittable\n            return 0\n        elif length == 2:  # always splittable\n            return 1\n\t\t\n\t\t# we are recording the first and last occurence of each included letter\n        first = {}  # max size = 26\n        last = {}  # max size = 26\n\t\t\n        for index, character in enumerate(s):  # O(n)\n            if character not in first:\n                first[character] = index\n            last[character] = index\n\t\t\t\n\t\t# we are concatenating the collected indices into a list and sort them\n        indices = list(first.values()) + list(last.values())  # max length 26 + 26 = 52\n        indices.sort()  # sorting is constant O(1) because of the length limit above\n\t\t\n\t\t# all possible splits will be in the middle of this list\n        middle = len(indices)//2  # always an integer because indices has an even length\n\t\t\n\t\t# there are this many possible splits between the two 'median' numbers\n        return indices[middle] - indices[middle-1]"}
{"prompt": "def minNumberOperations(self, target: List[int]) -> int:\n        res = target[0]\n        \n        for i in range(1, len(target)):\n            if target[i] >= target[i - 1]:\n                res -= target[i - 1]\n                res += target[i]\n        \n        return res"}
{"prompt": "def restoreString(self, s: str, indices: List[int]) -> str:\n        res = [''] * len(s)\n        for i in range(len(s)):\n            res[indices[i]] = s[i]\n        return ''.join(i for i in res)"}
{"prompt": "def minFlips(self, target: str) -> int:\n        return len(list(groupby(\"0\" + target)))-1"}
{"prompt": "def countPairs(self, root: TreeNode, distance: int) -> int:\n        \n        def dfs(node):\n            \"\"\"Return (a list of) distances to leaves of sub-tree rooted at node.\"\"\"\n            nonlocal ans\n            if not node: return []\n            if node.left is node.right is None: return [0]\n            left,right = dfs(node.left), dfs(node.right)\n            ans += sum(2 + x + y <= distance for x in left for y in right)\n            return [1 + x for x in left + right]\n        \n        ans = 0\n        dfs(root)\n        return ans"}
{"prompt": "def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        rle = lambda x: x if x <= 1 else int(log10(x)) + 2 # rle length of a char repeated x times\n        \n        @cache \n        def fn(i, k, prev, cnt):\n            \"\"\"Return length of rle of s[i:] with k chars to be deleted.\"\"\"\n            if k < 0: return inf \n            if i == len(s): return 0 \n            ans = fn(i+1, k-1, prev, cnt) # delete current character \n            if prev == s[i]: \n                ans = min(ans, fn(i+1, k, s[i], cnt+1) + rle(cnt+1) - rle(cnt))\n            else: \n                ans = min(ans, fn(i+1, k, s[i], 1) + 1)\n            return ans \n        \n        return fn(0, k, \"\", 0)"}
{"prompt": "def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:\n        return sum(abs(arr[i] - arr[j]) <= a and abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c for i in range(len(arr)) for j in range(i+1, len(arr)) for k in range(j+1, len(arr)))"}
{"prompt": "def getWinner(self, arr: List[int], k: int) -> int:\n        win = cnt = 0 #winner &amp; count \n        for i, x in enumerate(arr): \n            if win < x: win, cnt = x, 0 #new winner in town \n            if i: cnt += 1 #when initializing (i.e. i == 0) count is 0\n            if cnt == k: break #early break \n        return win"}
{"prompt": "def minSwaps(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        #summarizing row into number \n        row = [0]*m \n        for i in range(m):\n            row[i] = next((j for j in reversed(range(n)) if grid[i][j]), 0)\n        \n        ans = 0\n        #sequentially looking for row to fill in \n        for k in range(m): \n            for i, v in enumerate(row): \n                if v <= k: #enough trailing zeros \n                    ans += i\n                    row.pop(i) #value used \n                    break \n            else: return -1 #cannot find such row \n        return ans"}
{"prompt": "def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        ans = i = ii = s = ss = 0\n        while i < len(nums1) and ii < len(nums2): \n            #update range sum &amp; move pointer \n            if nums1[i] < nums2[ii]: \n                s += nums1[i] \n                i += 1\n            elif nums1[i] > nums2[ii]:\n                ss += nums2[ii]\n                ii += 1\n            #add larger range sum to ans\n            #add common value &amp; move pointers\n            else: \n                ans += max(s, ss) + nums1[i]\n                s = ss = 0\n                i, ii = i+1, ii+1\n        #complete the range sum &amp; update ans \n        ans += max(s + sum(nums1[i:]), ss + sum(nums2[ii:])) \n        return ans % 1_000_000_007"}
{"prompt": "def findKthPositive(self, arr: List[int], k: int) -> int:\n        ss, x = set(arr), 1\n        while True: \n            if x not in ss: k -= 1\n            if not k: return x\n            x += 1"}
{"prompt": "def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        \n        cycles, extra = divmod(k, 26)\n        shifts = [cycles + (shift <= extra) for shift in range(26)]\n\n        for cs, ct in zip(s, t):\n            shift = (ord(ct) - ord(cs)) % 26\n            if shift == 0:\n                continue\n            if not shifts[shift]:\n                return False\n            shifts[shift] -= 1\n        \n        return True"}
{"prompt": "def minInsertions(self, s: str) -> int:\n        \"\"\"\n        (\n        \"\"\"\n        res = need = 0\n\n        for i in range(len(s)):\n            if s[i] == '(':\n                need += 2\n                if need % 2 == 1:\n                    res += 1\n                    need -= 1\n            if s[i] == ')':\n                need -= 1\n                if need == -1:\n                    res += 1\n                    need = 1\n        return res + need"}
{"prompt": "def longestAwesome(self, s: str) -> int:\n        # li = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]\n        li = [2**i for i in range(10)]\n        # checker = {0, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512}\n        checker = set(li)\n        checker.add(0)\n        # di: k = prefix xor, v = the first idx I got a new prefix_xor_value.\n        di = collections.OrderedDict({0: -1})\n        maxLength = prefix_xor = 0\n        \n        for i in range(len(s)):\n            prefix_xor ^= li[int(s[i])]\n            # Found a new prefix_xor_value\n            if prefix_xor not in di:\n                di[prefix_xor] = i\n            \n            # XOR operation with previous prefix_xor_value\n            for key in di.keys():\n                if i - di[key] <= maxLength:\n                    break\n\t\t\t\t# s[di[key] : i] is Awesome Substring\n                if key ^ prefix_xor in checker:\n                    maxLength = i - di[key]\n        return maxLength"}
{"prompt": "def makeGood(self, s: str) -> str:\n        stack = []\n        for c in s: \n            if stack and abs(ord(stack[-1]) - ord(c)) == 32: stack.pop() #pop \"bad\"\n            else: stack.append(c) #push \"good\"\n        return \"\".join(stack)"}
{"prompt": "def findKthBit(self, n: int, k: int) -> str:\n        if k == 1: return \"0\"\n        if k == 2**(n-1): return \"1\"\n        if k < 2**(n-1): return self.findKthBit(n-1, k)\n        return \"0\" if self.findKthBit(n-1, 2**n-k) == \"1\" else \"1\""}
{"prompt": "def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        ans = prefix = 0\n        seen = set([0]) #prefix sum seen so far ()\n        for i, x in enumerate(nums): \n            prefix += x\n            if prefix - target in seen:\n                ans += 1\n                seen.clear() #reset seen\n            seen.add(prefix)\n        return ans"}
{"prompt": "def minCost(self, n: int, cuts: List[int]) -> int:\n        \n        @lru_cache(None)\n        def fn(lo, hi): \n            \"\"\"Return cost of cutting [lo, hi].\"\"\"\n            cc = [c for c in cuts if lo < c < hi] #collect cuts within this region \n            if not cc: return 0\n            ans = inf\n            for mid in cc: ans = min(ans, fn(lo, mid) + fn(mid, hi))\n            return ans + hi - lo\n        \n        return fn(0, n)"}
{"prompt": "def threeConsecutiveOdds(self, arr: List[int]) -> bool:\n        count = 0\n        \n        for i in range(0, len(arr)):\n            if arr[i] %2 != 0:\n                count += 1\n                if count == 3:\n                    return True\n            else:\n                count = 0\n        return False"}
{"prompt": "def minOperations(self, n: int) -> int:\n        if(n%2!=0):\n            n=n//2\n            return n*(n+1)\n        else:\n            n=n//2\n            return n**2"}
{"prompt": "def maxDistance(self, position: List[int], m: int) -> int:\n        position.sort()\n        \n        def fn(d):\n            \"\"\"Return True if d is a feasible distance.\"\"\"\n            ans, prev = 0, -inf # where previous ball is put\n            for x in position:\n                if x - prev >= d: \n                    ans += 1\n                    if ans == m: return True\n                    prev = x\n            return False \n        \n\t\t# \"last True\" binary search (in contrast to \"first True\" binary search)\n        lo, hi = 1, position[-1] - position[0]\n        while lo < hi: \n            mid = lo + hi + 1 >> 1\n            if fn(mid): lo = mid\n            else: hi = mid - 1\n        return lo"}
{"prompt": "def minDays(self, n: int) -> int:\n        ans = 0\n        queue = [n]\n        seen = set()\n        while queue: #bfs \n            newq = []\n            for x in queue: \n                if x == 0: return ans \n                seen.add(x)\n                if x-1 not in seen: newq.append(x-1)\n                if x % 2 == 0 and x//2 not in seen: newq.append(x//2)\n                if x % 3 == 0 and x//3 not in seen: newq.append(x//3)\n            ans += 1\n            queue = newq"}
{"prompt": "def thousandSeparator(self, n: int) -> str:\n        return f\"{n:,}\".replace(\",\", \".\")"}
{"prompt": "def findSmallestSetOfVertices(self, n: int, edges: List[List[int]]) -> List[int]:\n        if not edges:\n            return []\n        \n        incoming_degrees = {i: 0 for i in range(n)}\n        \n        for x, y in edges:\n            incoming_degrees[y] += 1\n            \n        result = [k for k, v in incoming_degrees.items() if v == 0]\n        return result"}
{"prompt": "def minOperations(self, nums: List[int]) -> int:\n        return sum(bin(a).count('1') for a in nums) + len(bin(max(nums))) - 2 - 1"}
{"prompt": "def containsCycle(self, grid: List[List[str]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        \n        @lru_cache(None)\n        def fn(i, j, d): \n            \"\"\"Traverse the grid to find cycle via backtracking.\"\"\"\n            if grid[i][j] != \"BLACK\": \n                val = grid[i][j]\n                grid[i][j] = \"GRAY\" # mark visited in this trial\n                for ii, jj, dd in ((i-1, j, -2), (i, j-1, -1), (i, j+1, 1), (i+1, j, 2)):\n                    if 0 <= ii < m and 0 <= jj < n and d + dd != 0: # in range &amp; not going back \n                        if grid[ii][jj] == \"GRAY\": return True #cycle found \n                        if grid[ii][jj] == val: fn(ii, jj, dd)\n                grid[i][j] = val \n        \n        for i in range(m):\n            for j in range(n):\n                if fn(i, j, 0): return True\n                grid[i][j] = \"BLACK\" # mark \"no cycle\"\n        return False"}
{"prompt": "def mostVisited(self, n: int, rounds: List[int]) -> List[int]:\n        x, xx = rounds[0], rounds[-1]\n        return list(range(x, xx+1)) if x <= xx else list(range(1, xx+1)) + list(range(x, n+1))"}
{"prompt": "def maxCoins(self, piles: List[int]) -> int:\n        piles.sort(reverse=True)\n        sum = 0\n        for i in range(1,len(piles)-int(len(piles)/3),2):\n            sum += piles[i]\n            print(sum)\n        return sum"}
{"prompt": "def findLatestStep(self, arr: List[int], m: int) -> int:\n        span = [0]*(len(arr)+2)\n        freq = [0]*(len(arr)+1)\n        ans = -1\n        for i, x in enumerate(arr, 1): \n            freq[span[x-1]] -= 1\n            freq[span[x+1]] -= 1\n            span[x] = span[x-span[x-1]] = span[x+span[x+1]] = 1 + span[x-1] + span[x+1]\n            freq[span[x]] += 1\n            \n            if freq[m]: ans = i\n        return ans"}
{"prompt": "def stoneGameV(self, stoneValue: List[int]) -> int:\n        length = len(stoneValue)\n        if length == 1:\n            return 0\n        \n\t\t# Calculate sum\n        s = [0 for _ in range(length)]\n        s[0] = stoneValue[0]\n        for i in range(1, length):\n            s[i] = s[i-1] + stoneValue[i]\n\t\t\n\t\t# dp for best value, best_cut for where is the cut in (i, j), i, j inclusive\n        dp = [[0 for _ in range(length)] for _ in range(length)]\n        best_cut = [[0 for _ in range(length)] for _ in range(length)]\n        \n        for i in range(0, length-1):\n            dp[i][i+1] = min(stoneValue[i], stoneValue[i+1])\n            best_cut[i][i+1] = i\n            \n        for t in range(2, length):\n            for i in range(0, length-t):\n                tmp_dp = 0\n                tmp_cut = 0\n                left_bound = best_cut[i][i+t-1]\n                if left_bound > i:\n                    left_bound -= 1\n                right_bound = best_cut[i+1][i+t]\n                if right_bound < i+t-1:\n                    right_bound += 1\n                    \n                for k in range(left_bound, 1+right_bound):\n                    s1 = s[k] - s[i-1] if i > 0 else s[k]\n                    s2 = s[i+t] - s[k]\n                    if s1 < s2:\n                        tmp = s1 + dp[i][k]\n                        if tmp > tmp_dp:\n                            tmp_dp = tmp\n                            tmp_cut = k\n                    elif s1 > s2:\n                        tmp = s2 + dp[k+1][i+t]\n                        if tmp > tmp_dp:\n                            tmp_dp = tmp\n                            tmp_cut = k\n                    else:\n                        tmp1 = s1 + dp[i][k]\n                        tmp2 = s2 + dp[k+1][i+t]\n                        if tmp1 > tmp_dp:\n                            tmp_dp = tmp1\n                            tmp_cut = k\n                        if tmp2 > tmp_dp:\n                            tmp_dp = tmp2\n                            tmp_cut = k\n        \n                dp[i][i+t] = tmp_dp\n                best_cut[i][i+t] = tmp_cut\n                \n        return dp[0][length-1]"}
{"prompt": "def containsPattern(self, arr: List[int], m: int, k: int) -> bool:\n        for i in range(len(arr)-m+1):\n            count = 1\n            x = arr[i:i+m]\n            res = 1\n            for j in range(i+m,len(arr)-m+1,m):\n                if x == arr[j:j+m]:\n                    count += 1\n                else:\n                    res = max(res,count)\n                    count = 1\n                    x = arr[j:j+m]\n            res = max(res,count)\n            if res >= k:\n                return True\n        return False"}
{"prompt": "def getMaxLen(self, nums: List[int]) -> int:\n        ans = pos = neg = 0\n        for x in nums: \n            if x > 0: pos, neg = 1 + pos, 1 + neg if neg else 0\n            elif x < 0: pos, neg = 1 + neg if neg else 0, 1 + pos\n            else: pos = neg = 0 # reset \n            ans = max(ans, pos)\n        return ans"}
{"prompt": "def minDays(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0]) # dimension \n        grid = \"\".join(\"\".join(map(str, x)) for x in grid)\n        \n        @lru_cache(None)\n        def fn(s): \n            \"\"\"Return True if grid is disconnected.\"\"\"\n            row, grid = [], []\n            for i, c in enumerate(s, 1):\n                row.append(int(c))\n                if i%n == 0: \n                    grid.append(row)\n                    row = []\n                    \n            def dfs(i, j): \n                \"\"\"\"\"\"\n                grid[i][j] = 0\n                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j):\n                    if 0 <= ii < m and 0 <= jj < n and grid[ii][jj]: dfs(ii, jj)\n                return 1\n            return sum(dfs(i, j) for i in range(m) for j in range(n) if grid[i][j])\n        \n        #bfs \n        queue = [grid]\n        level = 0 \n        seen = {grid}\n        while queue: \n            tmp = []\n            for node in queue: \n                if fn(node) == 0 or fn(node) >= 2: return level \n                for i in range(m*n):\n                    if node[i] == \"1\": \n                        nn = node[:i] + \"0\" + node[i+1:]\n                        if nn not in seen: \n                            seen.add(nn)\n                            tmp.append(nn)\n            queue = tmp\n            level += 1"}
{"prompt": "def numOfWays(self, nums: List[int]) -> int:\n        \n        def fn(nums): \n            \"\"\"Post-order traversal.\"\"\"\n            if len(nums) <= 1: return len(nums) # boundary condition \n            ll = [x for x in nums if x < nums[0]]\n            rr = [x for x in nums if x > nums[0]]\n            left, right = fn(ll), fn(rr)\n            if not left or not right: return left or right\n            ans = comb(len(rr)+len(ll), len(rr))\n            return ans*left*right\n            \n        return (fn(nums)-1) % 1_000_000_007"}
{"prompt": "def diagonalSum(self, mat: List[List[int]]) -> int:\n        \"\"\"\n        The primary diagonal is formed by the elements A00, A11, A22, A33.\n        Condition for Primary Diagonal:\n            The row-column condition is row = column.\n\n        The secondary diagonal is formed by the elements A03, A12, A21, A30. \n        Condition for Secondary Diagonal:\n            The row-column condition is row = numberOfRows - column -1.\n        \"\"\"\n        s = 0\n        l , mid = len(mat), len(mat)//2\n        for i in range(l):\n            s += mat[i][i] # primary diagonal\n            s += mat[len(mat)-i-1][i] # secondary diagonal\n        \n        # If the mat is odd, then diagonal will coincide, so subtract the middle element\n        if l%2 != 0:\n            s -= mat[mid][mid]\n        \n        return s"}
{"prompt": "def numWays(self, s: str) -> int:\n        total = s.count('1')\n        if total % 3: return 0\n        n = len(s)\n        if not total: return (1+n-2) * (n-2) // 2 % 1000000007\n        avg, ans = total // 3, 0\n        cnt = first_part_right_zeros = last_part_left_zeros = 0\n        for i in range(n):\n            if s[i] == '1': cnt += 1\n            elif cnt == avg: first_part_right_zeros += 1\n            elif cnt > avg: break    \n        cnt = 0\n        for i in range(n-1, -1, -1):\n            if s[i] == '1': cnt += 1\n            elif cnt == avg: last_part_left_zeros += 1\n            elif cnt > avg: break    \n        return (first_part_right_zeros+1) * (last_part_left_zeros+1) % 1000000007"}
{"prompt": "def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        \n        def lowerbound(left, right, target):\n            while left < right:\n                mid = left + (right - left) // 2\n                \n                if arr[mid] == target:\n                    right = mid\n                elif arr[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid\n                \n            return left\n        \n        \n        N = len(arr)\n        \n        # find the longest ascending array on the left side\n        i = 0\n        while i + 1 < N and arr[i] <= arr[i+1]:\n            i += 1\n        \n        if i == N - 1:\n            # it is already in ascending order\n            return 0\n        \n        # find the longest ascending array on the right side\n        j = N - 1\n        while j - 1 >= 0 and arr[j] >= arr[j-1]:\n            j -= 1\n        \n        if j == 0:\n            # the entire array is in decending order\n            return N - 1\n        \n        # keep ascending array on right side or left side\n        result = min(N - (N - j), N - i -1)\n        \n        \n        # find the shortest unordered subarray in the middle \n        for k in range(i+1):\n            l = lowerbound(j, len(arr), arr[k])\n            result = min(result, l - (k + 1))\n        \n        \n        return result"}
{"prompt": "def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        @lru_cache(None)\n        def fn(n, x): \n            \"\"\"Return all possible routes from n to finish with x fuel.\"\"\"\n            if x < 0: return 0 # not going anywhere without fuel \n            ans = 0\n            if n == finish: ans += 1\n            for nn in range(len(locations)): \n                if nn != n: ans += fn(nn, x-abs(locations[n] - locations[nn]))\n            return ans \n        \n        return fn(start, fuel) % 1_000_000_007"}
{"prompt": "def modifyString(self, s: str) -> str:\n        s = list(s)\n        for i in range(len(s)):\n            if s[i] == \"?\": \n                for c in \"abc\": \n                    if (i == 0 or s[i-1] != c) and (i+1 == len(s) or s[i+1] != c): \n                        s[i] = c\n                        break \n        return \"\".join(s)"}
{"prompt": "def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\n        sqr1, sqr2 = defaultdict(int), defaultdict(int)\n        m, n = len(nums1), len(nums2)\n        for i in range(m):\n            sqr1[nums1[i]**2] += 1\n        for j in range(n):\n            sqr2[nums2[j]**2] += 1\n            \n        res = 0 \n        for i in range(m-1):\n            for j in range(i+1, m):\n                if nums1[i]*nums1[j] in sqr2:\n                    res += sqr2[nums1[i]*nums1[j]]\n                    \n        for i in range(n-1):\n            for j in range(i+1, n):\n                if nums2[i]*nums2[j] in sqr1:\n                    res += sqr1[nums2[i]*nums2[j]]\n        return res"}
{"prompt": "def minCost(self, s: str, cost: List[int]) -> int:\n        ans = prev = 0 # index of previously retained letter \n        for i in range(1, len(s)): \n            if s[prev] != s[i]: prev = i\n            else: \n                ans += min(cost[prev], cost[i])\n                if cost[prev] < cost[i]: prev = i\n        return ans"}
{"prompt": "def numSpecial(self, mat: List[List[int]]) -> int:\n        onesx = []\n        onesy = []\n        for ri, rv in enumerate(mat):\n            for ci, cv in enumerate(rv):\n                if cv == 1:\n                    onesx.append(ri)\n                    onesy.append(ci)\n        \n        count = 0\n        for idx in range(len(onesx)):\n            if onesx.count(onesx[idx]) == 1:\n                if onesy.count(onesy[idx]) == 1:\n                    count += 1\n        return count"}
{"prompt": "def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\n\n        def find_preferred_friends(x: int) -> List[int]:\n            \"\"\"\n            Returns friends of x that have a higher preference than partner.\n            \"\"\"\n\t\t\tpartner = partners[x]  # Find the partner of x.\n            x_friends = friend_prefs[x]  # Find all the friends of x.\n            partner_ranking = x_friends[partner]  # Get the partner's ranking amongst those friends.\n            return list(x_friends)[:partner_ranking]  # Return all friends with a preferred lower ranking.\n\n        def is_unhappy(x: int) -> bool:\n            \"\"\"\n            Returns True if person x is unhappy, otherwise False.\n            \"\"\"\n            # Find the partner for person x.\n            partner = partners[x]  \n            # Find the friends that person x prefers more than this partner.\n            preferred_friends = find_preferred_friends(x)  \n            # A friend is unhappy with their partner if there is another friend with a higher preference \n            # and that friend prefers them over their partner.\n            return any(friend_prefs[friend][x] <= friend_prefs[friend][partners[friend]] \n                       for friend in preferred_friends)\n\n        # Create dictionary to lookup friend preference for any person.\n        friend_prefs = {\n            person: {friend: pref for pref, friend in enumerate(friends)}\n            for person, friends in enumerate(preferences)\n        }\n\t\t# Example:\n\t\t# {0: {1: 0, 3: 1, 2: 2},\n\t    #  1: {2: 0, 3: 1, 0: 2},\n\t    #  2: {1: 0, 3: 1, 0: 2},\n\t    #  3: {0: 0, 2: 1, 1: 2}}\n \n        # Create dictionary to find anyone's partner.\n        partners = {}\n        for x, y in pairs:\n            partners[x] = y\n            partners[y] = x\n        \n\t\t# Count and return the number of unhappy people.\n        return sum(is_unhappy(person) for person in range(n))"}
{"prompt": "def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        manhattan = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n        n, c = len(points), collections.defaultdict(list)\n        for i in range(n):\n            for j in range(i+1, n):\n                d = manhattan(points[i], points[j])\n                c[i].append((d, j))\n                c[j].append((d, i))\n        cnt, ans, visited, heap = 1, 0, [0] * n, c[0]\n        visited[0] = 1\n        heapq.heapify(heap)\n        while heap:\n            d, j = heapq.heappop(heap)\n            if not visited[j]:\n                visited[j], cnt, ans = 1, cnt+1, ans+d\n                for record in c[j]: heapq.heappush(heap, record)\n            if cnt >= n: break        \n        return ans"}
{"prompt": "def isTransformable(self, s: str, t: str) -> bool:\n        if sorted(s) != sorted(t): return False # edge case \n        \n        pos = [deque() for _ in range(10)]\n        for i, ss in enumerate(s): pos[int(ss)].append(i)\n            \n        for tt in t: \n            i = pos[int(tt)].popleft()\n            for ii in range(int(tt)): \n                if pos[ii] and pos[ii][0] < i: return False # cannot swap \n        return True"}
{"prompt": "def sumOddLengthSubarrays(self, arr: List[int]) -> int:\n        s=0\n        for i in range(len(arr)):\n            for j in range(i,len(arr),2):\n                s+=sum(arr[i:j+1])\n        return s"}
{"prompt": "def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\n        chg = [0]*len(nums) # change \n        for i, j in requests: \n            chg[i] += 1\n            if j+1 < len(nums): chg[j+1] -= 1\n        for i in range(1, len(nums)): chg[i] += chg[i-1] # cumulated change\n        return sum(n*c for n, c in zip(sorted(nums), sorted(chg))) % 1_000_000_007"}
{"prompt": "def minSubarray(self, nums: List[int], p: int) -> int:\n    dp = defaultdict(int)\n    dp[0] = -1\n    target = sum(nums) % p\n    curSum = 0\n    result = len(nums)\n    \n    if sum(nums) % p == 0: return 0\n    \n    for i in range(len(nums)):\n        curSum += nums[i]\n        \n        curMod = curSum % p\n        \n        temp = (curSum - target) % p\n        \n        if temp in dp:\n            if i - dp[temp] < result:\n                result = i - dp[temp]\n        \n        dp[curMod] = i\n    \n    return result if result < len(nums) else -1"}
{"prompt": "def isPrintable(self, targetGrid: List[List[int]]) -> bool:\n        visited = [0] * 61\n        graph = collections.defaultdict(set)\n        m, n = len(targetGrid), len(targetGrid[0])\n        for c in range(1, 61):\n            l,r,t,b = n,-1,m,-1\n\t\t\t#to specify the covered range of color c\n            for i in range(m):\n                for j in range(n):\n                    if targetGrid[i][j] == c:\n                        l = min(l, j)\n                        r = max(r, j)\n                        t = min(t, i)\n                        b = max(b, i)\n\t\t\t#to find the contained colors\n            for i in range(t, b + 1):\n                for j in range(l, r + 1):\n                    if targetGrid[i][j] != c:\n                        graph[targetGrid[i][j]].add(c)\n        \n\t\t# to find if there is a cycle \n        def dfs(graph,i):\n            if visited[i] == -1:\n                return False\n            if visited[i] == 1:\n                return True \n            visited[i] = -1\n            for j in graph[i]:\n                if not dfs(graph,j):\n                    return False\n            visited[i] = 1\n            return True\n        \n        for c in range(61):\n            if not dfs(graph,c):\n                return False\n        return True"}
{"prompt": "def reorderSpaces(self, text):\n        word_list = text.split()\n        words, spaces = len(word_list), text.count(\" \")\n        \n        if words > 1:\n            q, r = spaces//(words-1), spaces%(words-1)\n            return (\" \" * q).join(word_list) + \" \" * r\n        else:\n            return \"\".join(word_list) + \" \" * spaces"}
{"prompt": "def maxUniqueSplit(self, s: str) -> int:\n        ans, n = 0, len(s)\n        def dfs(i, cnt, visited):\n            nonlocal ans, n\n            if i == n: ans = max(ans, cnt); return  # stop condition\n            for j in range(i+1, n+1):    \n                if s[i:j] in visited: continue      # avoid re-visit/duplicates\n                visited.add(s[i:j])                 # update visited set\n                dfs(j, cnt+1, visited)              # backtracking\n                visited.remove(s[i:j])              # recover visited set for next possibility\n        dfs(0, 0, set())                            # function call\n        return ans"}
{"prompt": "def maxProductPath(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        \n        @lru_cache(None)\n        def fn(i, j): \n            \"\"\"Return maximum &amp; minimum products ending at (i, j).\"\"\"\n            if i == 0 and j == 0: return grid[0][0], grid[0][0]\n            if i < 0 or j < 0: return -inf, inf\n            if grid[i][j] == 0: return 0, 0\n            mx1, mn1 = fn(i-1, j) # from top\n            mx2, mn2 = fn(i, j-1) # from left \n            mx, mn = max(mx1, mx2)*grid[i][j], min(mn1, mn2)*grid[i][j]\n            return (mx, mn) if grid[i][j] > 0 else (mn, mx)\n        \n        mx, _ = fn(m-1, n-1)\n        return -1 if mx < 0 else mx % 1_000_000_007"}
{"prompt": "def connectTwoGroups(self, cost: List[List[int]]) -> int:\n        m, n = len(cost), len(cost[0])\n        mn = [min(x) for x in zip(*cost)] # min cost of connecting points in 2nd group \n        \n        @lru_cache(None)\n        def fn(i, mask):\n            \"\"\"Return min cost of connecting group1[i:] and group2 represented as mask.\"\"\"\n            if i == m: return sum(mn[j] for j in range(n) if not (mask &amp; (1<<j)))\n            return min(cost[i][j] + fn(i+1, mask | 1<<j) for j in range(n))\n                \n        return fn(0, 0)"}
{"prompt": "def minOperations(self, logs: List[str]) -> int:\n        ans = 0\n        for log in logs: \n            if log == \"./\": continue\n            elif log == \"../\": ans = max(0, ans-1) # parent directory\n            else: ans += 1 # child directory \n        return ans"}
{"prompt": "def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        ans = -1\n        most = pnl = waiting = 0\n        for i, x in enumerate(customers): \n            waiting += x # more people waiting in line \n            waiting -= (chg := min(4, waiting)) # boarding \n            pnl += chg * boardingCost - runningCost \n            if most < pnl: ans, most = i+1, pnl\n        q, r = divmod(waiting, 4)\n        if 4*boardingCost > runningCost: ans += q\n        if r*boardingCost > runningCost: ans += 1\n        return ans"}
{"prompt": "def maximumRequests(self, n: int, req: List[List[int]]) -> int:\n        tot = len(req)\n        for i in range(tot, 0, -1):\n            comb = list(itertools.combinations([j for j in range(tot)], i))\n            for c in comb:\n                net = [0 for j in range(n)]\n                for idx in c:\n                    net[req[idx][0]] -= 1\n                    net[req[idx][1]] += 1\n                if net == [0 for j in range(n)]:\n                    return i\n        return 0"}
{"prompt": "def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        key_time = {}\n        for index, name in enumerate(keyName):\n            key_time[name] = key_time.get(name, [])\n            key_time[name].append(int(keyTime[index].replace(\":\", \"\")))\n        ans = []\n        for name, time_list in key_time.items():\n            time_list.sort()\n            n = len(time_list)\n            for i in range(n-2):\n                if time_list[i+2] - time_list[i] <= 100:\n                    ans.append(name)\n                    break\n        return sorted(ans)"}
{"prompt": "def restoreMatrix(self, rowSum: List[int], colSum: List[int]) -> List[List[int]]:\n        def backtrack(y, x):\n            choice = min(rowSum[y], colSum[x])\n            result[y][x] = choice\n            rowSum[y] -= choice\n            colSum[x] -= choice\n            if y == 0 and x == 0:\n                return\n\n            elif not rowSum[y]:\n                backtrack(y - 1, x)\n            elif not colSum[x]:\n                backtrack(y, x - 1)\n\n        Y, X = len(rowSum), len(colSum)\n        result = [[0 for _ in range(X)] for _ in range(Y)]\n        backtrack(Y-1, X-1)\n        return result"}
{"prompt": "def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\n        busy = [] # min-heap\n        free = list(range(k)) # min-heap \n        freq = [0]*k\n        \n        for i, (ta, tl) in enumerate(zip(arrival, load)): \n            while busy and busy[0][0] <= ta: \n                _, ii = heappop(busy)\n                heappush(free, i + (ii - i) % k) # circularly relocate it\n            if free: \n                ii = heappop(free) % k \n                freq[ii] += 1\n                heappush(busy, (ta+tl, ii))\n        \n        mx = max(freq)\n        return [i for i, x in enumerate(freq) if x == mx]"}
{"prompt": "def specialArray(self, nums: List[int]) -> int:\n        nums.sort()\n        n = len(nums)\n\n        if n<=nums[0]:\n            return n\n        \n        for i in range(1,n):\n            count = n-i       #counts number of elements in nums greater than equal i\n            if nums[i]>=(count) and (count)>nums[i-1]:\n                return count \n        return -1"}
{"prompt": "def isEvenOddTree(self, root: TreeNode) -> bool:\n        even = 1 # even level \n        queue = deque([root])\n        while queue: \n            newq = []\n            prev = -inf if even else inf\n            for _ in range(len(queue)): \n                node = queue.popleft()\n                if even and (node.val&amp;1 == 0 or prev >= node.val) or not even and (node.val&amp;1 or prev <= node.val): return False \n                prev = node.val \n                if node.left: queue.append(node.left)\n                if node.right: queue.append(node.right)\n            even ^= 1\n        return True"}
{"prompt": "def visiblePoints(self, points: List[List[int]], angle: int, l: List[int]) -> int:\n        \n        array = []\n        nloc = 0\n        for p in points:\n            if p == l:\n                nloc += 1\n            else:\n                array.append(math.degrees(atan2(p[1]-l[1], p[0]-l[0])))\n        array.sort()\n        angles = array + [a+360 for a in array]\n        left, maxm = 0, 0\n        for right, a in enumerate(angles):\n            if a-angles[left] > angle:\n                left += 1\n            maxm = max(right-left+1, maxm)\n        \n        return maxm + nloc"}
{"prompt": "def minimumOneBitOperations(self, n: int) -> int:\n        \"\"\"\n        to flip the bits to turn the number to zero\n        \n        Interpretation of Rules:\n        - recursive:\n            to turn a leading one of i bits to zero, the only way is to turn the i-1 bits to a leading one pattern\n            and to turn the i-1 bits leading zero to zero, the only way is to turn the i-2 bits to a leading one pattern\n            and so on, which is a recursive process\n            \n            (10000.. -> 11000.. -> 01000..), (01000.. -> 01100.. -> 00100), ..., (..010 -> ..011 -> ..001 -> ..000)\n            \n        - reversable:\n        \n            Let's make some observations to check if there's any pattern:\n\n            - 2: 10 -> 11 -> 01 -> 00\n            - 4: 100 -> 101 -> 111 -> 110 -> 010 -> 011 -> 001 -> 000\n            - 8: 1000 -> 1001 -> 1011 -> 1010 -> 1110 -> 1111 -> 1101 -> 1100 -> 0100 -> (reversing 100 to 000) -> 0000\n            ...\n            \n            based on the observation, turning every i bits leading one to zero, is turning the i-1 bits from 00.. to 10..\n            and then back to 00.., which is a reverable process, and with the recursive process we can conclude that\n            turning any length of 00..M-> 10.. is a reversable process\n        \n        - all unique states:\n            since it is recursive and reversable, and we are flipping every bit between 1 and 0 programtically 10.. <-> 00..\n            we can conclude that every intermediate state in a process is unique (2**i unique states, so we need 2**i - 1 steps)\n        \n                for i bits 10.. <-> 00.. - numer of operations f(i) = 2**i - 1\n            \n            this also aligns with the observation above that f(i) = 2*f(i-1) - 1 (-1 for no operation needed to achieve the initial 000)\n        \n        Process:\n        to turn any binary to 0, we can turning the 1s to 0s one by one from lower bit to higher bit\n        and because turning a higher bit 1 to 0, would passing the unique state including the lower bit 1s\n        we can reverse those operations needed for the higher bit 100.. to the unique state including the lower bit 1s\n        \n        e.g. turning 1010100 to 0\n        - 1010(100) -> 1010(000), we will need 2**3 - 1 operations\n        - 10(10000) -> 10(00000), we will need (2**5 - 1) - (2**3 - 1) operations\n        we will be passing the state 10(10100), which is ready available from the last state\n        so we can save/reverse/deduct the operations needed for 1010(000) <-> 1010(100)\n        - ...\n        \n            so for any binary, f(binary) would tell us how many operations we need for binary <-> 000..\n            and for any more 1s, 100{binary} we can regard it as a process of 100.. <-> 100{binary} <-> 000{000..}\n            which is 100.. <-> 000.. (2**i - 1) saving the operations 100{000..} <-> 100{binary} (f(binary))\n            = (2**i - 1) - f(last_binary)\n            \n        \"\"\"\n        binary = format(n, \"b\")\n\n        N, res = len(binary), 0\n        \n        for i in range(1, N+1):\n            if binary[-i] == \"1\": res = 2**i-1 - res\n                \n        return res"}
{"prompt": "def maxDepth(self, s: str) -> int:\n        depths = [0]\n        \n        count = 0\n        for i in s:\n            if(i == '('):\n                count += 1\n            elif(i == ')'):\n                count -= 1\n            depths.append(count)\n        \n        return max(depths)"}
{"prompt": "def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n        graph = {}\n        for u, v in roads:\n            graph.setdefault(u, set()).add(v)\n            graph.setdefault(v, set()).add(u)\n        \n        ans = 0\n        for i in range(n): \n            for j in range(i+1, n):\n                val = len(graph.get(i, set())) + len(graph.get(j, set())) - (j in graph.get(i, set()))\n                ans = max(ans, val)\n        return ans"}
{"prompt": "def checkPalindromeFormation(self, a: str, b: str) -> bool:\n        \n        fn = lambda x: x == x[::-1] # check for palindrome \n        \n        i = 0\n        while i < len(a) and a[i] == b[~i]: i += 1\n        if fn(a[:i] + b[i:]) or fn(a[:-i] + b[-i:]): return True \n        \n        i = 0\n        while i < len(a) and a[~i] == b[i]: i += 1\n        if fn(b[:i] + a[i:]) or fn(b[:-i] + a[-i:]): return True \n        \n        return False"}
{"prompt": "def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:\n        # Create Tree as adjacency list\n        neigh: List[List[int]] = [[] for _ in range(n)]\n        for u, v in edges:\n            neigh[u - 1].append(v - 1)\n            neigh[v - 1].append(u - 1)\n\n        distance_array: List[int] = [0] * n\n\n        def find_tree_center(vertices: List[int], adj_list: List[List[int]]) -> int:\n            \"\"\"Given a tree, return a central vertex (minimum radius vertex) with BFS\"\"\"\n\n            num_neighbors: List[int] = list(map(len, adj_list))\n            leaf_nodes: Deque[int] = collections.deque((x for x in range(len(vertices)) if num_neighbors[x] == 1))\n            while len(leaf_nodes) > 1:\n                leaf = leaf_nodes.popleft()\n                for neighbor in adj_list[leaf]:\n                    num_neighbors[neighbor] -= 1\n                    if num_neighbors[neighbor] == 1:\n                        leaf_nodes.append(neighbor)\n            return leaf_nodes[0]\n\n        def merge_into_parent(parent_subtrees: Dict[Tuple[int, int], int],\n                              child_subtrees: Dict[Tuple[int, int], int]) -> None:\n\n            \"\"\" Helper function to merge two disjoint rooted trees T_parent and T_child rooted at 'parent' and 'child',\n               into one tree rooted at 'parent', by adding an edge from 'parent' to 'child'.\n               Called once for each edge in our tree. parent_subtrees[i, j] is the count of rooted subtrees\n               of T_parent that contain 'parent', have diameter i, and height j.\n               Worst case complexity: O(n^4) per call\n            \"\"\"\n\n            for (diam_for_parent, height_for_parent), count_from_parent in list(parent_subtrees.items()):\n\n                for (diam_for_child, height_for_child), count_from_child in child_subtrees.items():\n\n                    new_diameter = max(diam_for_parent, diam_for_child, height_for_parent + height_for_child + 1)\n                    new_height = max(height_for_parent, height_for_child + 1)\n                    parent_subtrees[new_diameter, new_height] = parent_subtrees.get((new_diameter, new_height), 0) + count_from_child * count_from_parent\n\n            return None\n\n        def compute_subtree_counts(current_vertex: int,\n                                   last_vertex: int = -1) -> Dict[Tuple[int, int], int]:\n            \"\"\"Recursively counts subtrees rooted at current_vertex using DFS,\n            with edge from current_vertex to 'last_vertex' (parent node) cut off\"\"\"\n            subtree_counts: Dict[Tuple[int, int], int] = {(0, 0): 1}\n\n            for child_vertex in neigh[current_vertex]:\n                if child_vertex == last_vertex:\n                    continue\n\n                merge_into_parent(parent_subtrees=subtree_counts,\n                                  child_subtrees=compute_subtree_counts(current_vertex=child_vertex,\n                                                                        last_vertex=current_vertex))\n\n            for (diameter, height), subtree_count in subtree_counts.items():\n                distance_array[diameter] += subtree_count\n\n            return subtree_counts\n\n        # Optimization: Use a max-degree vertex as our root to minimize recursion depth\n        max_degree_vertex: int = find_tree_center(vertices=list(range(n)),\n                                                  adj_list=neigh)\n\n        compute_subtree_counts(current_vertex=max_degree_vertex)\n\n        return distance_array[1:]"}
{"prompt": "def trimMean(self, arr: List[int]) -> float:\n        arr.sort()\n\n        return statistics.mean(arr[int(len(arr)*5/100):len(arr)-int(len(arr)*5/100)])"}
{"prompt": "def bestCoordinate(self, towers: List[List[int]], radius: int) -> List[int]:\n        mx = -inf\n        for x in range(51):\n            for y in range(51): \n                val = 0\n                for xi, yi, qi in towers: \n                    d = sqrt((x-xi)**2 + (y-yi)**2)\n                    if d <= radius: val += int(qi/(1 + d))\n                if val > mx: \n                    ans = [x, y]\n                    mx = val\n        return ans"}
{"prompt": "def numberOfSets(self, n: int, k: int) -> int:\n        \n        @cache\n        def fn(n, k):\n            \"\"\"Return number of sets.\"\"\"\n            if n <= k: return 0 \n            if k == 0: return 1\n            return 2*fn(n-1, k) + fn(n-1, k-1) - fn(n-2, k)\n        \n        return fn(n, k) % 1_000_000_007"}
{"prompt": "def maxLengthBetweenEqualCharacters(self, s: str) -> int:\n        ans = -1\n        seen = {}\n        for i, c in enumerate(s): \n            if c in seen: ans = max(ans, i - seen[c] - 1)\n            seen.setdefault(c, i)\n        return ans"}
{"prompt": "def findLexSmallestString(self, s: str, a: int, b: int) -> str:\n        op1 = lambda s: \"\".join(str((int(c)+a)%10) if i&amp;1 else c for i, c in enumerate(s))\n        op2 = lambda s: s[-b:] + s[:-b]\n        \n        seen = set()\n        stack = [s]\n        while stack: \n            s = stack.pop()\n            seen.add(s)\n            if (ss := op1(s)) not in seen: stack.append(ss)\n            if (ss := op2(s)) not in seen: stack.append(ss)\n        return min(seen)"}
{"prompt": "def bestTeamScore(self, scores: List[int], ages: List[int]) -> int:\n        '''\n        Using example scores = [1,2,3,5] and ages = [8,9,10,1]\n        \n        data is   [(1, 5), (8, 1), (9, 2), (10, 3)]\n        and dp is [5, 1, 2, 3]\n        \n        when curr player is (1, 5)\n            there are no prev players -> so leave dp of curr as-is\n            \n        when curr player is (8, 1)\n            prev player's score is not less than curr player score\n            nor is previous player's age same as curr player age -> so leave dp of curr as-is\n        \n        when curr player is (9, 2)\n            prev player (1, 5) has score NOT less than, and age NOT equal to ... skipping\n            prev player (8, 1) has score YES less than ... so we do something!\n                since the accumulated dp of prev player + curr's score is GREATER than curr's accumulated dp value:\n                    we update curr's accumulated dp value to be instead sum of prev player's dp value and curr's score\n                    \n        when curr player is (10, 3)\n            prev player (1, 5) has score NOT less, and age NTO equal to ... skipping\n            prev player (8, 1) has score YES less, so update curr's dp value from 3 -> 3+1 = 4\n            prev player (9, 2) has score YES less, so update curr's dp value from 4 -> 4+2 = 6\n            \n        finally we return the max of all dp values for the dream team.\n        '''\n        # Sort by age and score ASC\n        data = sorted(zip(ages, scores), key=lambda x:(x[0], x[1]))\n        # Initialize dp with scores for each player\n        dp = [score for age, score in data]\n        N = len(data)\n        \n        # For every current player\n        for curr in range(N):\n            # Compare every previous player\n            for prev in range(0, curr):\n                # And if previous player score is less OR previous player is same age\n                if (data[prev][1] <= data[curr][1] or data[curr][0] == data[prev][0]):\n                    # Then update dp value for current player to be the max of either\n                    #  -> the current score as it is OR\n                    #  -> the current score PLUS the dp value of previous player\n                    dp[curr] = max(dp[curr], data[curr][1] + dp[prev])\n\n        return max(dp)"}
{"prompt": "def slowestKey(self, r: List[int], k: str) -> str:\n        times = {r[0]: [k[0]]}\n        \n        for i in range(1 , len(r)):\n            t = r[i] - r[i - 1]\n            if(t in times):\n                times[t].append(k[i])\n            else:\n                times[t] = [k[i]]\n        \n        keys = times[max(times.keys())]\n        \n        return max(keys)"}
{"prompt": "def checkArithmeticSubarrays(self, nums: List[int], l: List[int], r: List[int]) -> List[bool]:\n        ans = []\n        \n        def find_diffs(arr):\n            \n            arr.sort()\n\n            dif = []\n            \n            for i in range(len(arr) - 1):\n                dif.append(arr[i] - arr[i + 1])\n            \n            return len(set(dif)) == 1\n        \n        for i , j in zip(l , r):\n            ans.append(find_diffs(nums[i:j + 1]))\n        \n        return ans"}
{"prompt": "def minimumEffortPath(self, heights: List[List[int]]) -> int:\n        m, n = len(heights), len(heights[0])\n        \n        queue = {(0, 0): 0} # (0, 0) maximum height so far \n        seen = {(0, 0): 0} # (i, j) -> heights \n        ans = inf \n        \n        while queue: \n            newq = {} # new dictionary \n            for (i, j), h in queue.items(): \n                if i == m-1 and j == n-1: ans = min(ans, h)\n                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \n                    if 0 <= ii < m and 0 <= jj < n: \n                        hh = max(h, abs(heights[i][j] - heights[ii][jj]))\n                        if hh < seen.get((ii, jj), inf): \n                            seen[(ii, jj)] = hh \n                            newq[(ii, jj)] = hh\n            queue = newq \n        return ans"}
{"prompt": "def matrixRankTransform(self, matrix: List[List[int]]) -> List[List[int]]:\n        m, n = len(matrix), len(matrix[0]) # dimension \n        # mapping from value to index \n        mp = {} \n        for i in range(m):\n            for j in range(n): \n                mp.setdefault(matrix[i][j], []).append((i, j))\n        \n        def find(p):\n            \"\"\"Find root of p.\"\"\"\n            if p != parent[p]:\n                parent[p] = find(parent[p])\n            return parent[p]\n        \n        rank = [0]*(m+n)\n        ans = [[0]*n for _ in range(m)]\n        \n        for k in sorted(mp): # from minimum to maximum \n            parent = list(range(m+n))\n            for i, j in mp[k]: \n                ii, jj = find(i), find(m+j) # find \n                parent[ii] = jj # union \n                rank[jj] = max(rank[ii], rank[jj]) # max rank \n            \n            seen = set()\n            for i, j in mp[k]:\n                ii = find(i)\n                if ii not in seen: rank[ii] += 1\n                seen.add(ii)\n                rank[i] = rank[m+j] = ans[i][j] = rank[ii]\n        return ans"}
{"prompt": "def frequencySort(self, nums: List[int]) -> List[int]:\n        return sorted(sorted(nums,reverse=1),key=nums.count)"}
{"prompt": "def maxWidthOfVerticalArea(self, points: List[List[int]]) -> int:\n        l = []\n        for i in points:\n            l.append(i[0])\n        a = 0\n        l.sort()\n        for i in range(len(l)-1):\n            if l[i+1] - l[i] > a:\n                a = l[i+1] - l[i]\n        return a"}
{"prompt": "def countSubstrings(self, s: str, t: str) -> int:\n        m, n = len(s), len(t) \n        \n        @cache\n        def fn(i, j, k): \n            \"\"\"Return number of substrings ending at s[i] and t[j] with k=0/1 difference.\"\"\"\n            if i < 0 or j < 0: return 0 \n            if s[i] == t[j]: return fn(i-1, j-1, k) + (k==0)\n            else: return 0 if k == 0 else 1 + fn(i-1, j-1, 0)\n        \n        return sum(fn(i, j, 1) for i in range(m) for j in range(n))"}
{"prompt": "def numWays(self, words: List[str], target: str) -> int:\n        freq = [defaultdict(int) for _ in range(len(words[0]))]\n        for word in words: \n            for i, c in enumerate(word): \n                freq[i][c] += 1\n        \n        @cache\n        def fn(i, k): \n            \"\"\"Return number of ways to form target[i:] w/ col k.\"\"\"\n            if i == len(target): return 1\n            if k == len(words[0]): return 0 \n            return freq[k][target[i]]*fn(i+1, k+1) + fn(i, k+1)\n        \n        return fn(0, 0) % 1_000_000_007"}
{"prompt": "def canFormArray(self, arr: List[int], pieces: List[List[int]]) -> bool:\n        mp = {x[0]: x for x in pieces}\n        i = 0\n        while i < len(arr): \n            if (x := arr[i]) not in mp or mp[x] != arr[i:i+len(mp[x])]: return False \n            i += len(mp[x])\n        return True"}
{"prompt": "def countVowelStrings(self, n: int) -> int:        \n        dp = [[0] * 6 for _ in range(n+1)]\n        for i in range(1, 6):\n            dp[1][i] = i\n        \n        for i in range(2, n+1):\n            dp[i][1]=1\n            for j in range(2, 6):\n                dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        \n        return dp[n][5]"}
{"prompt": "def furthestBuilding(self, heights: List[int], bricks: int, ladders: int) -> int:\n        # prepare: use a min heap to store each difference(climb) between two contiguous buildings\n        # strategy: use the ladders for the longest climbs and the bricks for the shortest climbs\n        \n        min_heap = []\n        n = len(heights)\n        \n        for i in range(n-1):\n            climb = heights[i+1] - heights[i]\n            \n            if climb <= 0:\n                continue\n            \n            # we need to use a ladder or some bricks, always take the ladder at first\n            if climb > 0:\n                heapq.heappush(min_heap, climb)\n            \n            # ladders are all in used, find the current shortest climb to use bricks instead!\n            if len(min_heap) > ladders:\n                # find the current shortest climb to use bricks\n                brick_need = heapq.heappop(min_heap)\n                bricks -= brick_need\n            \n            if bricks < 0:\n                return i\n        \n        return n-1"}
{"prompt": "def kthSmallestPath(self, destination: List[int], k: int) -> str:\n        m, n = destination # m \"V\" &amp; n \"H\" in total \n        ans = \"\"\n        while n: \n            kk = comb(m+n-1, n-1) # (m+n-1 choose n-1) instructions starting with \"H\"  \n            if kk >= k: \n                ans += \"H\"\n                n -= 1\n            else: \n                ans += \"V\"\n                m -= 1\n                k -= kk \n        return ans + m*\"V\""}
{"prompt": "def getMaximumGenerated(self, n: int) -> int:\n        max_nums = [0, 1, 1, 2, 2, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 11, 11, 11, 11, 11, 11, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21]\n        return max_nums[n]"}
{"prompt": "def minDeletions(self, s: str) -> int:\n        freq = {} # frequency table \n        for c in s: freq[c] = 1 + freq.get(c, 0)\n        \n        ans = 0\n        seen = set()\n        for k in sorted(freq.values(), reverse=True): \n            while k in seen: \n                k -= 1 \n                ans += 1\n            if k: seen.add(k)\n        return ans"}
{"prompt": "def maxProfit(self, inventory: List[int], orders: int) -> int:\n        inventory.sort(reverse=True) # inventory high to low \n        inventory += [0]\n        ans = 0\n        k = 1\n        for i in range(len(inventory)-1): \n            if inventory[i] > inventory[i+1]: \n                if k*(inventory[i] - inventory[i+1]) < orders: \n                    ans += k*(inventory[i] + inventory[i+1] + 1)*(inventory[i] - inventory[i+1])//2 # arithmic sum \n                    orders -= k*(inventory[i] - inventory[i+1])\n                else: \n                    q, r = divmod(orders, k)\n                    ans += k*(2*inventory[i] - q + 1) * q//2 + r*(inventory[i] - q)\n                    return ans % 1_000_000_007\n            k += 1"}
{"prompt": "def decrypt(self, code: List[int], k: int) -> List[int]:\n        if k == 0:\n            return [0] * len(code)\n        data = code + code\n        result = [sum(data[i + 1: i + 1 + abs(k)]) for i in range(len(code))]\n\t\t# result = []\n        # for i in range(len(code)):\n        #     result.append(sum(data[i + 1: i + 1 + abs(k)]))\n        if 0 > k:\n            return result[k - 1:] + result[:k - 1]\n        return result"}
{"prompt": "def minimumDeletions(self, s: str) -> int:\n        # track the minimum number of deletions to make the current string balanced ending with 'a', 'b'\n        end_a, end_b = 0,0 \n        for val in s:\n            if val == 'a':\n                # to end with 'a', nothing to do with previous ending with 'a'\n                # to end with 'b', need to delete the current 'a' from previous ending with 'b'\n                end_b += 1\n            else:\n                # to end with 'a', need to delete the current 'b' from previous ending with 'a'\n                # to end with 'b', nothing to do, so just pick smaller of end_a, end_b\n                end_a, end_b = end_a+1, min(end_a, end_b)\n        return min(end_a, end_b)"}
{"prompt": "def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\n    \n    forbidden = set(forbidden)\n    limit = max(x,max(forbidden))+a+b\n    seen = set()\n    q = [(0,0,False)]\n    while q:\n        p,s,isb = q.pop(0)\n        if p>limit or p<0 or p in forbidden or (p,isb) in seen:\n            continue\n        \n        if p==x:\n            return s\n        \n        q.append((p+a,s+1,False))\n        if not isb:\n            q.append((p-b,s+1,True))\n        seen.add((p,isb))\n    \n    return -1"}
{"prompt": "def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\n        freq = {}\n        for x in nums: freq[x] = 1 + freq.get(x, 0)\n        \n        vals = sorted(freq.values(), reverse=True)\n        quantity.sort(reverse=True) # pruning - large values first  \n        \n        def fn(i): \n            \"\"\"Return True if possible to distribute quantity[i:] to remaining.\"\"\"\n            if i == len(quantity): return True \n            seen = set()\n            for k in range(len(vals)): \n                if vals[k] >= quantity[i] and vals[k] not in seen: \n                    seen.add(vals[k]) # pruning - unqiue values \n                    vals[k] -= quantity[i]\n                    if fn(i+1): return True \n                    vals[k] += quantity[i] # backtracking\n                    \n        return fn(0)"}
{"prompt": "def closeStrings(self, word1: str, word2: str) -> bool:\n        cnt1, cnt2 = Counter(word1), Counter(word2)\n        return cnt1.keys() == cnt2.keys() and sorted(cnt1.values()) == sorted(cnt2.values())"}
{"prompt": "def minOperations(self, nums: List[int], x: int) -> int:\n        mp = {0: 0}\n        prefix = 0\n        for i, num in enumerate(nums, 1): \n            prefix += num\n            mp[prefix] = i \n            \n        ans = mp.get(x, inf)\n        for i, num in enumerate(reversed(nums), 1): \n            x -= num\n            if x in mp and mp[x] + i <= len(nums): ans = min(ans, i + mp[x])\n        return ans if ans < inf else -1"}
{"prompt": "def getMaxGridHappiness(self, m: int, n: int, introvertsCount: int, extrovertsCount: int) -> int:\n        \n        @cache\n        def fn(prev, i, j, intro, extro): \n            \"\"\"Return max grid happiness at (i, j).\"\"\"\n            if i == m: return 0 # no more position\n            if j == n: return fn(prev, i+1, 0, intro, extro)\n            if intro == extro == 0: return 0 \n            \n            prev0 = prev[:j] + (0,) + prev[j+1:]\n            ans = fn(prev0, i, j+1, intro, extro)\n            if intro: \n                val = 120 \n                if i and prev[j]: # neighbor from above \n                    val -= 30 \n                    if prev[j] == 1: val -= 30 \n                    else: val += 20 \n                if j and prev[j-1]: # neighbor from left \n                    val -= 30 \n                    if prev[j-1] == 1: val -= 30 \n                    else: val += 20 \n                prev0 = prev[:j] + (1,) + prev[j+1:]\n                ans = max(ans, val + fn(prev0, i, j+1, intro-1, extro))\n            if extro: \n                val = 40 \n                if i and prev[j]: \n                    val += 20 \n                    if prev[j] == 1: val -= 30 \n                    else: val += 20 \n                if j and prev[j-1]: \n                    val += 20 \n                    if prev[j-1] == 1: val -= 30 \n                    else: val += 20 \n                prev0 = prev[:j] + (2,) + prev[j+1:]\n                ans = max(ans, val + fn(prev0, i, j+1, intro, extro-1))\n            return ans \n        \n        return fn((0,)*n, 0, 0, introvertsCount, extrovertsCount)"}
{"prompt": "def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        return ''.join(word1) == ''.join(word2)"}
{"prompt": "def getSmallestString(self, n: int, k: int) -> str:\n        res, k, i = ['a'] * n, k - n, n - 1\n        while k:\n            k += 1\n            if k/26 >= 1:\n                res[i], k, i = 'z', k - 26, i - 1\n            else:\n                res[i], k = chr(k + 96), 0\n\n        return ''.join(res)"}
{"prompt": "def waysToMakeFair(self, nums: List[int]) -> int:\n\t\tif len(nums) == 1:\n\t\t\treturn 1\n\n\t\tif len(nums) == 2:\n\t\t\treturn 0\n\n\t\tprefixEven = sum(nums[2::2])\n\t\tprefixOdd = sum(nums[1::2])\n\t\tresult = 0\n\n\t\tif prefixEven == prefixOdd and len(set(nums)) == 1:\n\t\t\tresult += 1\n\n\t\tfor i in range(1,len(nums)):\n\t\t\tif i == 1:\n\t\t\t\tprefixOdd, prefixEven = prefixEven, prefixOdd \n\n\t\t\tif i > 1:\n\t\t\t\tif i % 2 == 0:\n\t\t\t\t\tprefixEven -= nums[i-1]\n\t\t\t\t\tprefixEven += nums[i-2]\n\n\t\t\t\telse:\n\t\t\t\t\tprefixOdd -= nums[i-1]\n\t\t\t\t\tprefixOdd += nums[i-2]\n\n\t\t\tif prefixOdd == prefixEven:\n\t\t\t\tresult += 1\n\n\t\treturn result"}
{"prompt": "def minimumEffort(self, tasks: List[List[int]]) -> int:\n        tasks.sort(key=lambda x: x[0]-x[1])\n        def ok(mid):\n            for actual, minimum in tasks:\n                if minimum > mid or actual > mid: return False\n                if minimum <= mid: mid -= actual\n            return True\n        l, r = 0, 10 ** 9\n        while l <= r:\n            mid = (l+r) // 2\n            if ok(mid): r = mid - 1\n            else: l = mid + 1\n        return l"}
{"prompt": "def maxRepeating(self, sequence: str, word: str) -> int:\n        i = 0\n        while word*(i+1) in sequence:\n            i+=1\n        return i"}
{"prompt": "def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\n        curr=list1\n        for count in range(b):\n            if count==a-1:      # travel to a node and   --> step 1\n                start=curr      # then save pointer in start\n            curr=curr.next   # continue travel to b node  --> step 2\n        start.next=list2     # point start to list2   --> step3\n        while list2.next:    # travel list2   --> step 4\n            list2=list2.next\n        list2.next=curr.next  # map end of list2 to b\n        return list1"}
{"prompt": "def minimumMountainRemovals(self, lst: List[int]) -> int:\n\t\tl = len(lst)\n\t\tdp = [0] * l\n\t\tdp1 = [0] * l\n\n\t\tfor i in range(l):   # for increasing subsequence\n\t\t\tmaxi = 0\n\t\t\tfor j in range(i):\n\t\t\t\tif lst[i] > lst[j]:\n\t\t\t\t\tif dp[j] > maxi:\n\t\t\t\t\t\tmaxi = dp[j]\n\n\t\t\tdp[i] = maxi + 1\n\n\t\tfor i in range(l - 1, -1, -1):  # for decreasing subsequence\n\t\t\tmaxi1 = 0\n\t\t\tfor j in range(l - 1, i, -1):\n\t\t\t\tif lst[i] > lst[j]:\n\t\t\t\t\tif dp1[j] > maxi1:\n\t\t\t\t\t\tmaxi1 = dp1[j]\n\n\t\t\tdp1[i] = maxi1 + 1\n\n\t\tans = 0\n\t\tfor i in range(l):\n\t\t\tif dp[i] > 1 and dp1[i] > 1:\n\t\t\t\ttemp = dp[i] + dp1[i] - 1\n\t\t\t\tif temp > ans:\n\t\t\t\t\tans = temp\n\n\t\treturn l - ans"}
{"prompt": "def maximumWealth(self, accounts: List[List[int]]) -> int:\n        return max([sum(acc) for acc in accounts])"}
{"prompt": "def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\n        stack = [] # (increasing) mono-stack \n        for i, x in enumerate(nums): \n            while stack and stack[-1] > x and len(stack) + len(nums) - i > k: stack.pop()\n            if len(stack) < k: stack.append(x)\n        return stack"}
{"prompt": "def minMoves(self, nums: List[int], limit: int) -> int:\n        n = len(nums)\n        overlay_arr = [0] * (2*limit+2)\n        for i in range(n//2):\n            left_boundary = min(nums[i], nums[n-1-i]) + 1\n            no_move_value = nums[i] + nums[n-1-i]\n            right_boundary = max(nums[i], nums[n-1-i]) + limit\n            overlay_arr[left_boundary] -= 1\n            overlay_arr[no_move_value] -= 1\n            overlay_arr[no_move_value+1] += 1\n            overlay_arr[right_boundary+1] += 1\n        curr_moves = n   #initial assumption of two moves for each pair\n        res = float(\"inf\")\n\t\t# start Sweeping\n        for i in range(2, 2*limit+1):\n            curr_moves += overlay_arr[i]\n            res = min(res, curr_moves)\n        return res"}
{"prompt": "def minimumDeviation(self, nums: List[int]) -> int:\n\n\t\tfrom sortedcontainers import SortedList\n\n\t\tfor i in range(len(nums)):\n\n\t\t\tif nums[i]%2!=0:\n\t\t\t\tnums[i]=nums[i]*2\n\n\t\tnums = SortedList(nums)\n\n\t\tresult = 100000000000\n\n\t\twhile True:\n\t\t\tmin_value = nums[0]\n\t\t\tmax_value = nums[-1]\n\n\t\t\tif max_value % 2 == 0:\n\t\t\t\tnums.pop()\n\t\t\t\tnums.add(max_value // 2)\n\t\t\t\tmax_value = nums[-1]\n\t\t\t\tmin_value = nums[0]\n\n\t\t\t\tresult = min(result , max_value - min_value)\n\t\t\telse:\n\t\t\t\tresult = min(result , max_value - min_value)\n\t\t\t\tbreak\n\n\t\treturn result"}
{"prompt": "def interpret(self, command: str) -> str:\n        return command.replace('()','o').replace('(al)','al')"}
{"prompt": "def maxOperations(self, nums: List[int], k: int) -> int:\n        counter = defaultdict(int)\n        \n        count = 0\n        for x in nums:\n            comp = k - x\n            if counter[comp]>0:\n                counter[comp]-=1\n                count+=1\n            else:\n                counter[x] +=1\n        \n        return count"}
{"prompt": "def concatenatedBinary(self, n: int) -> int:\n        return int(\"\".join([bin(i)[2:] for i in range(1,n+1)]),2)%(10**9+7)"}
{"prompt": "def minimumIncompatibility(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        \n        def fn(i, cand): \n            \"\"\"Populate stack and compute minimum incompatibility.\"\"\"\n            nonlocal ans \n            if cand + len(nums) - i - sum(not x for x in stack) > ans: return \n            if i == len(nums): ans = cand\n            else: \n                for ii in range(k): \n                    if len(stack[ii]) < len(nums)//k and (not stack[ii] or stack[ii][-1] != nums[i]) and (not ii or stack[ii-1] != stack[ii]): \n                        stack[ii].append(nums[i])\n                        if len(stack[ii]) == 1: fn(i+1, cand)\n                        else: fn(i+1, cand + stack[ii][-1] - stack[ii][-2])\n                        stack[ii].pop()\n        \n        ans = inf\n        stack = [[] for _ in range(k)]\n        fn(0, 0)\n        return ans if ans < inf else -1"}
{"prompt": "def countConsistentStrings(self, allowed: str, words: List[str]) -> int:\n        return sum(set(allowed) >= set(i) for i in words)"}
{"prompt": "def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:\n        pre_sum = [0]\n        for num in nums:                                     # calculate prefix sum\n            pre_sum.append(pre_sum[-1] + num)\n        n = len(nums)                                        # render the output\n        return [(num*(i+1) - pre_sum[i+1]) + (pre_sum[-1]-pre_sum[i] - (n-i)*num) for i, num in enumerate(nums)]"}
{"prompt": "def stoneGameVI(self, alice: List[int], bob: List[int]) -> int:\n        n = len(alice)\n        arr = [alice[i] + bob[i] for i in range(n)]\n        s = sum(bob)\n        res = 0\n        k = (n+1)//2\n        arr.sort(reverse=True)\n        for i in range(0, n, 2):\n            res += arr[i]\n        \n        \n        if res > s:\n            return 1\n        elif res == s:\n            return 0 \n        else:\n            return -1"}
{"prompt": "def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\n        dp = [0] + [inf]*len(boxes)\n        trips = 2\n        ii = 0\n        for i in range(len(boxes)):\n            maxWeight -= boxes[i][1]\n            if i and boxes[i-1][0] != boxes[i][0]: trips += 1\n            while maxBoxes < i - ii + 1 or maxWeight < 0 or ii < i and dp[ii] == dp[ii+1]:\n                maxWeight += boxes[ii][1]\n                if boxes[ii][0] != boxes[ii+1][0]: trips-=1\n                ii += 1\n            dp[i+1] = dp[ii] + trips\n        return dp[-1]"}
{"prompt": "def numberOfMatches(self, n: int) -> int:\n\n\t\t# the logic is, among n teams only 1 team will won, so n-1 teams will lose\n\t\t# hence there will be n-1 match (so that n-1 teams can lose) \n\n\t\treturn n-1"}
{"prompt": "def minPartitions(self, n: str) -> int:\n        return int(max(n))"}
{"prompt": "def stoneGameVII(self, stones: List[int]) -> int:\n        dp = [[0 for _ in range(len(stones))] for _ in range(len(stones))]     # dp table n x n\n        run_sum = [0]                            # running sum -> sum [i..j] = run_sum[j] - run_sum[i]\n        s = 0\n        \n\t\t## Calculation of running sum\n        for i in stones:\n            s += i\n            run_sum.append(s)\n\t\t\n        n = len(stones) \n        \n        for k in range(1, n):               # no. of stones left\n            for i in range(0, n - k):   # from each starting point\n                remove_i_stone = (run_sum[i+k+1] - run_sum[i+1])    # score after removing i th stone\n                remove_j_stone = (run_sum[i+k] - run_sum[i])             # score after removing j th stone\n                \n                if (n-(k+1))%2 == 0:        # alice's move \n                    dp[i][i+k] = max(remove_i_stone + dp[i+1][i+k],\n                                    remove_j_stone + dp[i][i+k-1])\n                else:                       # bob's move\n                    dp[i][i+k] = min(-remove_i_stone + dp[i+1][i+k],\n                                    - remove_j_stone + dp[i][i+k-1])\n                    \n        return dp[0][n - 1]"}
{"prompt": "def maxHeight(self, cuboids: List[List[int]]) -> int:\n        cuboids = sorted([sorted(cub) for cub in cuboids], reverse=True)   # sort LxWxH in cube, then sort cube reversely\n        ok = lambda x, y: (x[0] >= y[0] and x[1] >= y[1] and x[2] >= y[2]) # make a lambda function to verify whether y can be put on top of x\n        n = len(cuboids)\n        dp = [cu[2] for cu in cuboids]                                     # create dp array\n        ans = max(dp)\n        for i in range(1, n):                                              # iterate over each cube\n            for j in range(i):                                             # compare with previous calculated cube\n                if ok(cuboids[j], cuboids[i]):                             # update dp[i] if cube[i] can be put on top of cube[j]\n                    dp[i] = max(dp[i], dp[j] + cuboids[i][2])              # always get the maximum\n            ans = max(ans, dp[i])                                          # record the largest value\n        return ans"}
{"prompt": "def reformatNumber(self, number: str) -> str:\n        number = number.replace(\"-\", \"\").replace(\" \", \"\") # removing - and space \n        ans = []\n        for i in range(0, len(number), 3): \n            if len(number) - i != 4: ans.append(number[i:i+3])\n            else: \n                ans.extend([number[i:i+2], number[i+2:]])\n                break \n        return \"-\".join(ans)"}
{"prompt": "def maximumUniqueSubarray(self, nums: List[int]) -> int:\n        counter=defaultdict(int) # track count of  elements in the window\n        res=i=tot=0\n\t\t\n        for j in range(len(nums)):\n            x=nums[j]   \n            tot+=x\n            counter[x]+=1\n            # adjust the left bound of sliding window until you get all unique elements\n            while i < j and counter[x]>1: \n                counter[nums[i]]-=1\n                tot-=nums[i]\n                i+=1\n            \n            res=max(res, tot)            \n        return res"}
{"prompt": "def maxResult(self, nums: List[int], k: int) -> int:\n        pq = [] # max heap \n        for i in reversed(range(len(nums))): \n            while pq and pq[0][1] - i > k: heappop(pq)\n            ans = nums[i] - pq[0][0] if pq else nums[i]\n            heappush(pq, (-ans, i))\n        return ans"}
{"prompt": "def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\n        \n        parent = [i for i in range(n+1)]\n    \n        rank = [0 for i in range(n+1)]\n\n        def find(parent, x):\n\n            if parent[x] == x:\n                return x\n            parent[x] = find(parent, parent[x])\n            return parent[x]\n\n        def union(parent, a, b):\n\n            a = find(parent, a)\n            b = find(parent, b)\n\n            if a == b:\n                return \n\n            if rank[a] < rank[b]:\n                parent[a] = b\n            elif rank[a] > rank[b]:\n                parent[b] = a\n            else:\n                parent[b] = a\n                rank[a] += 1\n                \n        edgeList.sort(key = lambda x: x[2])\n        res = [0] * len(queries)\n        queries = [[i, ch] for i, ch in enumerate(queries)]\n        queries.sort(key = lambda x: x[1][2])\n        \n        ind = 0\n        for i, (a, b, w) in queries:\n            \n            while ind < len(edgeList) and edgeList[ind][2] < w:\n                union(parent, edgeList[ind][0], edgeList[ind][1])\n                ind += 1\n                \n            res[i] = find(parent, a) == find(parent, b)\n        return res"}
{"prompt": "def countStudents(self, students: List[int], sandwiches: List[int]) -> int:\n        curr = 0\n        \n        while students:\n            if(students[0] == sandwiches[0]):\n                curr = 0\n                students.pop(0)\n                sandwiches.pop(0)\n            else:\n                curr += 1\n                students.append(students.pop(0))\n            \n            if(curr >= len(students)):\n                break\n        \n        return len(students)"}
{"prompt": "def averageWaitingTime(self, customers: List[List[int]]) -> float:\n        arr = []\n        \n        time = 0\n        \n        for i , j in customers:\n            if(i > time):\n                time = i + j\n            else:\n                time += j\n            arr.append(time - i)\n        \n        return sum(arr) / len(arr)"}
{"prompt": "lass Solution:\n    def maximumBinaryString(self, s: str) -> str:\n        #count of 0\n        c=0\n        #final ans string will contain only one zero.therefore shift the first 0  to c places.Initialize ans string with all 1s\n        lst=[\"1\"]*len(s)\n        for i in range (0,len(s)):\n            if s[i]==\"0\":\n                c+=1\n        for i in range (0,len(s)):\n\t\t#finding the ist 0\n            if s[i]==\"0\":\n                lst[i+c-1]=\"0\"\n                return \"\".join(lst)\n        return s"}
{"prompt": "def minMoves(self, nums: List[int], k: int) -> int:\n        ii = val = 0 \n        ans = inf\n        loc = [] # location of 1s\n        for i, x in enumerate(nums): \n            if x: \n                loc.append(i)\n                m = (ii + len(loc) - 1)//2 # median \n                val += loc[-1] - loc[m] - (len(loc)-ii)//2 # adding right \n                if len(loc) - ii > k: \n                    m = (ii + len(loc))//2 # updated median \n                    val -= loc[m] - loc[ii] - (len(loc)-ii)//2 # removing left \n                    ii += 1\n                if len(loc)-ii == k: ans = min(ans, val) # len(ones) - ii effective length\n        return ans"}
{"prompt": "def halvesAreAlike(self, s: str) -> bool:\n        vowels = set('aeiouAEIOU')\n        count = 0\n        for i in range(len(s)//2):\n            if s[i] in vowels:\n                count+=1\n            if s[-i-1] in vowels:\n                count-=1\n\n        return count == 0"}
{"prompt": "def eatenApples(self, apples: List[int], days: List[int]) -> int:\n        ans = 0\n        \n        pq = [] # min-heap \n        for i, (x, d) in enumerate(zip(apples, days)): \n            while pq and pq[0][0] <= i: heappop(pq) # rotten \n            if x: heappush(pq, (i+d, x))\n            if pq: \n                ii, x = heappop(pq)\n                if x-1: heappush(pq, (ii, x-1))\n                ans += 1\n        \n        i += 1\n        while pq: \n            ii, x = heappop(pq)\n            x = min(x, ii-i)\n            ans += x\n            i += x \n        return ans"}
{"prompt": "def findBall(self, grid: List[List[int]]) -> List[int]:\n        m, n = len(grid), len(grid[0])\n        @cache\n        def helper(r, c):\n            if r == m:\n                return c\n            elif grid[r][c] == 1 and c+1 < n and grid[r][c+1] == 1:\n                return helper(r+1, c+1)\n            elif grid[r][c] == -1 and 0 <= c-1 and grid[r][c-1] == -1:\n                return helper(r+1, c-1)\n            else:\n                return -1\n            \n        return [helper(0, j) for j in range(n)]"}
{"prompt": "def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        nums.sort()\n        queries = sorted((m, x, i) for i, (x, m) in enumerate(queries))\n        ans = [-1]*len(queries)\n        \n        trie = {}\n        k = 0\n        for m, x, i in queries: \n            while k < len(nums) and nums[k] <= m: \n                node = trie\n                val = bin(nums[k])[2:].zfill(32)\n                for c in val: node = node.setdefault(int(c), {})\n                node[\"#\"] = nums[k]\n                k += 1\n            if trie: \n                node = trie\n                val = bin(x)[2:].zfill(32)\n                for c in val: node = node.get(1-int(c)) or node.get(int(c))\n                ans[i] = x ^ node[\"#\"]\n        return ans"}
{"prompt": "def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\n        boxTypes.sort(key=lambda x:x[1],reverse=1)\n        s=0\n        for i,j in boxTypes:\n            i=min(i,truckSize)\n            s+=i*j\n            truckSize-=i\n            if truckSize==0:\n                break\n        return s"}
{"prompt": "def countPairs(self, deliciousness: List[int]) -> int:\n        ans = 0\n        freq = defaultdict(int)\n        for x in deliciousness: \n            for k in range(22): ans += freq[2**k - x]\n            freq[x] += 1\n        return ans % 1_000_000_007"}
{"prompt": "def waysToSplit(self, nums: List[int]) -> int:\n        prefix = [0]\n        for x in nums: prefix.append(prefix[-1] + x)\n        \n        ans = 0\n        for i in range(1, len(nums)): \n            j = bisect_left(prefix, 2*prefix[i])\n            k = bisect_right(prefix, (prefix[i] + prefix[-1])//2)\n            ans += max(0, min(len(nums), k) - max(i+1, j))\n        return ans % 1_000_000_007"}
{"prompt": "def minOperations(self, target: List[int], arr: List[int]) -> int:\n        loc = {x: i for i, x in enumerate(target)}\n        stack = []\n        for x in arr: \n            if x in loc: \n                i = bisect_left(stack, loc[x])\n                if i < len(stack): stack[i] = loc[x]\n                else: stack.append(loc[x])\n        return len(target) - len(stack)"}
{"prompt": "def totalMoney(self, n: int) -> int:\n        res,k=0,0\n        for i in range(n):\n            if i%7==0:\n                k+=1\n            res+=k+(i%7)\n        return res"}
{"prompt": "def maximumGain(self, s: str, x: int, y: int) -> int:\n\t\t# to calculate first, high value of x or y\n        a, b = 'ab', 'ba'\n        if y > x:\n            b, a, y, x = a, b, x, y\n\n        answer = 0\n        \n        for word in [a, b]:\n            stack = []\n\n            i = 0\n            while i < len(s):\n                stack.append(s[i])\n                \n                n = len(stack)\n                prefix = stack[n-2] + stack[n-1]\n                # if see the prefix ab or ba move from stack and increment the answer\n                if prefix == word:\n                    answer += x\n                    stack.pop()\n                    stack.pop()\n                i += 1\n            # change the x point to y for 2nd iteration\n            x = y\n            \n            # assign new letters with already removed prefix\n            s = ''.join(stack)\n        return answer"}
{"prompt": "def constructDistancedSequence(self, n: int) -> List[int]:\n        \n        arr = [0]*(2*n-1)     # the array we want to put numbers. 0 means no number has been put here\n        i = 0                 # current index to put a number                \n        vi = [False] * (n+1)  # check if we have used that number\n        \n\t\t# backtracking\n        def dfs(arr, i, vi):\n\t\t    # if we already fill the array successfully, return True\n            if i >= (2*n-1):\n                return True\n\t\t\t\t\n\t\t\t# try each number from n to 1\n            for x in range(n, 0, -1):\n\t\t\t    # two cases:\n\t\t\t    # x > 1, we check two places. Mind index out of bound here.\n\t\t\t    # x = 1, we only check one place\n\t\t\t\t# arr[i] == 0 means index i is not occupied\n                if (x > 1 and ((not (arr[i] == 0 and (i+x < 2*n-1) and arr[i+x] == 0)) or vi[x]))  \\\n\t\t\t\t\tor (x == 1 and (arr[i] != 0 or vi[x])):\n                    continue\n\t\t\t\t\n\t\t\t\t# if it can be placed, then place it\n                if x > 1:\n                    arr[i] = x\n                    arr[i+x] = x\n                else:\n                    arr[i] = x\n                vi[x] = True\n\t\t\t\t\n\t\t\t\t# find the next available place\n                nexti = i+1\n                while nexti < 2*n-1 and arr[nexti]:\n                    nexti += 1\n\t\t\t\t\n\t\t\t\t# place the next one\n                if dfs(arr, nexti, vi):\n\t\t\t\t\t# if it success, it is already the lexicographically largest one, we don't search anymore\n                    return True\n\t\t\t\t\t\n\t\t\t\t# backtracking... restore the state\n                if x > 1:\n                    arr[i] = 0\n                    arr[i+x] = 0\n                else:\n                    arr[i] = 0\n                vi[x] = False\n\t\t\t\n\t\t\t# we could not find a solution, return False\n            return False\n\t\t\n        dfs(arr, i, vi)\n        return arr"}
{"prompt": "def checkWays(self, pairs: List[List[int]]) -> int:\n        graph = {}\n        for x, y in pairs: \n            graph.setdefault(x, set()).add(y)\n            graph.setdefault(y, set()).add(x)\n        \n        ans = 1 \n        ancestors = set()\n        for n in sorted(graph, key=lambda x: len(graph[x]), reverse=True): \n            p = min(ancestors &amp; graph[n], key=lambda x: len(graph[x]), default=None) # immediate ancestor \n            ancestors.add(n)\n            if p: \n                if graph[n] - (graph[p] | {p}): return 0 # impossible to have more than ancestor\n                if len(graph[n]) == len(graph[p]): ans = 2\n            elif len(graph[n]) != len(graph)-1: return 0\n        return ans"}
{"prompt": "def decode(self, encoded: List[int], first: int) -> List[int]:\n        return [first] + [first:= first ^ x for x in encoded]"}
{"prompt": "def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        l = head  # left node\n        for _ in range(k-1):\n            l = l.next\n        # the rest of the code logic here"}
{"prompt": "def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:\n        def gen_adjacency():\n            adj = {}\n            for i in range(len(source)):\n                adj[i] = []\n            for a, b in allowedSwaps:\n                adj[a].append(b)\n                adj[b].append(a)\n            return adj\n        \n        def dfs(i):\n            visited.add(i)\n            this_group.add(i)\n            for neigh in adj[i]:\n                if neigh not in visited:\n                    dfs(neigh)\n\n        adj = gen_adjacency()\n        visited = set()\n        common_counts = 0\n        for i in adj:\n            if i not in visited:\n                this_group = set()\n                dfs(i)\n                s_counts = collections.Counter([source[i] for i in this_group])\n                t_counts = collections.Counter([target[i] for i in this_group])\n                common = set(s_counts).intersection(t_counts)\n                for common_int in common:\n                    common_counts += min(s_counts[common_int], t_counts[common_int])\n        ans = len(source) - common_counts\n        return ans"}
{"prompt": "def minimumTimeRequired(self, jobs: List[int], k: int) -> int:\n        jobs.sort(reverse=True)\n        \n        def fn(i):\n            \"\"\"Assign jobs to worker and find minimum time.\"\"\"\n            nonlocal ans \n            if i == len(jobs): ans = max(time)\n            else: \n                for kk in range(k): \n                    if not kk or time[kk-1] > time[kk]: \n                        time[kk] += jobs[i]\n                        if max(time) < ans: fn(i+1)\n                        time[kk] -= jobs[i]\n            \n        ans = inf\n        time = [0]*k\n        fn(0)\n        return ans"}
{"prompt": "def countGoodRectangles(self, rectangles: List[List[int]]) -> int:\n        freq = {}\n        for l, w in rectangles: \n            x = min(l, w)\n            freq[x] = 1 + freq.get(x, 0)\n        return freq[max(freq)]"}
{"prompt": "def tupleSameProduct(self, nums: List[int]) -> int:\n        ans = 0\n        freq = {}\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)): \n                key = nums[i] * nums[j]\n                ans += freq.get(key, 0)\n                freq[key] = 1 + freq.get(key, 0)\n        return 8*ans"}
{"prompt": "def largestSubmatrix(self, matrix: List[List[int]]) -> int:\n        m, n, ans = len(matrix), len(matrix[0]), 0\n        \n        for j in range(n):\n            for i in range(1, m):\n                matrix[i][j] += matrix[i-1][j] if matrix[i][j] else 0\n                \n        for i in range(m): \n            matrix[i].sort(reverse=1)\n            for j in range(n):\n                ans = max(ans, (j+1)*matrix[i][j])\n        return ans"}
{"prompt": "def canMouseWin(self, grid: List[str], catJump: int, mouseJump: int) -> bool:\n        dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n        m, n = len(grid), len(grid[0])\n        mouse_pos = cat_pos = None\n\t\tavailable = 0 # available steps for mouse and cat\n\t\t# Search the start pos of mouse and cat\n        for i in range(m):\n            for j in range(n):\n\t\t\t\tif grid[i][j] != '#':\n                    available += 1\n                if grid[i][j] == 'M':\n                    mouse_pos = (i, j)\n                elif grid[i][j] == 'C':\n                    cat_pos = (i, j)\n        \n        @functools.lru_cache(None)\n        def dp(turn, mouse_pos, cat_pos):\n            # if turn == m * n * 2:\n\t\t\t# We already search the whole grid (9372 ms 74.3 MB)\n\t\t\tif turn == available * 2:\n\t\t\t\t# We already search the whole touchable grid (5200 ms 57.5 MB)\n                return False\n            if turn % 2 == 0:\n                # Mouse\n                i, j = mouse_pos\n                for di, dj in dirs:\n                    for jump in range(mouseJump + 1):\n\t\t\t\t\t\t# Note that we want to do range(mouseJump + 1) instead of range(1, mouseJump + 1)\n\t\t\t\t\t\t# considering the case that we can stay at the same postion for next turn.\n                        new_i, new_j = i + di * jump, j + dj * jump\n                        if 0 <= new_i < m and 0 <= new_j < n and grid[new_i][new_j] != '#':\n\t\t\t\t\t\t\t# Valid pos\n                            if dp(turn + 1, (new_i, new_j), cat_pos) or grid[new_i][new_j] == 'F':\n                                return True\n                        else:\n\t\t\t\t\t\t\t# Stop extending the jump since we cannot go further\n                            break\n                return False\n            else:\n                # Cat\n                i, j = cat_pos\n                for di, dj in dirs:\n                    for jump in range(catJump + 1):\n                        new_i, new_j = i + di * jump, j + dj * jump\n                        if 0 <= new_i < m and 0 <= new_j < n and grid[new_i][new_j] != '#':\n                            if not dp(turn + 1, mouse_pos, (new_i, new_j)) or (new_i, new_j) == mouse_pos or grid[new_i][new_j] == 'F':\n\t\t\t\t\t\t\t# This condition will also handle the case that the cat cannot jump through the mouse\n                                return False\n                        else:\n                            break\n                return True\n\t\t\t\t\n        return dp(0, mouse_pos, cat_pos)"}
{"prompt": "def largestAltitude(self, gain):\n        \"\"\"\n        :type gain: List[int]\n        :rtype: int\n        \"\"\"\n\t\t#initialize a variable to store the end output\n        result = 0\n\t\t#initialize a variable to keep track of the altitude at each iteration\n        current_altitude=0\n\t\t#looping through each of the gains\n        for g in gain:\n\t\t#updating the current altitude based on the gain\n            current_altitude += g\n\t\t\t#if the current altitude is greater than the highest altitude recorded then assign it as the result. This done iteratively, allows us to find the highest altitude\n            if current_altitude > result:\n                result = current_altitude\n        return result"}
{"prompt": "def minimumTeachings(self, n: int, languages: List[List[int]], friendships: List[List[int]]) -> int:\n        m = len(languages)\n        languages = [set(x) for x in languages]\n        \n        mp = {}\n        for u, v in friendships: \n            if not languages[u-1] &amp; languages[v-1]: \n                for i in range(n):\n                    if i+1 not in languages[u-1]: mp.setdefault(u-1, set()).add(i)\n                    if i+1 not in languages[v-1]: mp.setdefault(v-1, set()).add(i)\n        \n        ans = inf\n        for i in range(n): \n            val = 0\n            for k in range(m): \n                if i in mp.get(k, set()): val += 1\n            ans = min(ans, val)\n        return ans"}
{"prompt": "def decode(self, encoded: List[int]) -> List[int]:\n        n = len(encoded)+1\n        XOR = 0\n        for i in range(1,n+1):\n            XOR = XOR^i\n        \n        s = 0\n        for i in range(1,n,2):\n            s = s^encoded[i]\n        res = [0]*n\n        res[0] = XOR^s\n        \n        for j in range(1,n):\n            res[j] = res[j-1]^encoded[j-1]\n        return res"}
{"prompt": "def waysToFillArray(self, queries: List[List[int]]) -> List[int]:\n        # brute DP O(NK) where N is max(q[0]) and K is max(q[1])\n        @cache\n        def dp(n,k):\n            \n            if k == 1 or n == 1: return 1\n            ways = 0\n            for factor in range(1, k+1):\n                if k % factor == 0:\n                    ways += dp(n-1, k//factor) # or take the '3' part\n                    ways %= (10**9+7)\n            return ways % (10**9+7)\n        \n        res = [0] * len(queries)\n        for i,(n, k) in enumerate(queries):\n            res[i] = dp(n,k)\n        \n        return res\n            \n        # better solution -> find out how many prime factors a number has.\n        # how many ways to group P numbers into N groups (since array has N values only)\n        # but you can group in lesser groups and keep 1 1 1 1 as padding in array :("}
{"prompt": "def maximumTime(self, time: str) -> str:\n        time = list(time)\n        for i in range(len(time)): \n            if time[i] == \"?\": \n                if i == 0: time[i] = \"2\" if time[i+1] in \"?0123\" else \"1\"\n                elif i == 1: time[i] = \"3\" if time[0] == \"2\" else \"9\"\n                elif i == 3: time[i] = \"5\"\n                else: time[i] = \"9\"\n        return \"\".join(time)"}
{"prompt": "def minCharacters(self, a: str, b: str) -> int:\n        pa, pb = [0]*26, [0]*26\n        for x in a: pa[ord(x)-97] += 1\n        for x in b: pb[ord(x)-97] += 1\n        \n        ans = len(a) - max(pa) + len(b) - max(pb) # condition 3\n        for i in range(25): \n            pa[i+1] += pa[i]\n            pb[i+1] += pb[i]\n            ans = min(ans, pa[i] + len(b) - pb[i]) # condition 2\n            ans = min(ans, len(a) - pa[i] + pb[i]) # condition 1\n        return ans"}
{"prompt": "def kthLargestValue(self, matrix: List[List[int]], k: int) -> int:\n        m, n = len(matrix), len(matrix[0]) # dimensions \n        \n        ans = []\n        for i in range(m): \n            for j in range(n): \n                if i: matrix[i][j] ^= matrix[i-1][j]\n                if j: matrix[i][j] ^= matrix[i][j-1]\n                if i and j: matrix[i][j] ^= matrix[i-1][j-1]\n                ans.append(matrix[i][j])\n        return sorted(ans)[-k]"}
{"prompt": "def minimumBoxes(self, n: int) -> int:\n        x = int((6*n)**(1/3))\n        if x*(x+1)*(x+2) > 6*n: x -= 1\n        \n        ans = x*(x+1)//2\n        n -= x*(x+1)*(x+2)//6\n        k = 1\n        while n > 0: \n            ans += 1\n            n -= k\n            k += 1\n        return ans"}
{"prompt": "def countBalls(self, lowLimit: int, highLimit: int) -> int:\n        freq = defaultdict(int)\n        for x in range(lowLimit, highLimit+1):\n            freq[sum(int(xx) for xx in str(x))] += 1\n        return max(freq.values())"}
{"prompt": "def restoreArray(self, adjacentPairs: List[List[int]]) -> List[int]:\n        graph = {}\n        for u, v in adjacentPairs: \n            graph.setdefault(u, []).append(v)\n            graph.setdefault(v, []).append(u)\n        \n        ans = []\n        seen = set()\n        stack = [next(x for x in graph if len(graph[x]) == 1)]\n        while stack: \n            n = stack.pop()\n            ans.append(n)\n            seen.add(n)\n            for nn in graph[n]: \n                if nn not in seen: stack.append(nn)\n        return ans"}
{"prompt": "def canEat(self, candiesCount: List[int], queries: List[List[int]]) -> List[bool]:\n        prefix = [0]\n        for x in candiesCount: prefix.append(prefix[-1] + x) # prefix sum \n        return [prefix[t] < (day+1)*cap and day < prefix[t+1] for t, day, cap in queries]"}
{"prompt": "def checkPartitioning(self, s: str) -> bool:\n        mp = {}\n        for i in range(2*len(s)-1): \n            lo, hi = i//2, (i+1)//2\n            while 0 <= lo <= hi < len(s) and s[lo] == s[hi]: \n                mp.setdefault(lo, set()).add(hi)\n                lo -= 1\n                hi += 1\n        \n        @lru_cache(None)\n        def fn(i, k): \n            \"\"\"Return True if s[i:] can be split into k palindromic substrings.\"\"\"\n            if k < 0: return False \n            if i == len(s): return k == 0\n            return any(fn(ii+1, k-1) for ii in mp[i])\n        \n        return fn(0, 3)"}
{"prompt": "def sumOfUnique(self, nums: List[int]) -> int:\n        hashmap = {}\n        for i in nums:\n            if i in hashmap.keys():\n                hashmap[i] += 1\n            else:\n                hashmap[i] = 1\n        sum = 0\n        for k, v in hashmap.items():\n            if v == 1: sum += k\n        return sum"}
{"prompt": "def maxAbsoluteSum(self, nums: List[int]) -> int:\n        ans = mx = mn = 0\n        for x in nums: \n            mx = max(mx + x, 0)\n            mn = min(mn + x, 0)\n            ans = max(ans, mx, -mn)\n        return ans"}
{"prompt": "def minimumLength(self, s: str) -> int:\n        dd = deque(s)\n        while len(dd) >= 2 and dd[0] == dd[-1]:\n            ch = dd[0]\n            while dd and dd[0] == ch: dd.popleft()\n            while dd and dd[-1] == ch: dd.pop()\n        return len(dd)"}
{"prompt": "def maxValue(self, events: List[List[int]], k: int) -> int:\n        \n        # The number of events\n        n = len(events)\n        # Sort the events in chronological order\n        events.sort()\n        \n        # k is the number of events we can attend\n        # end is the last event we attended's END TIME\n        # event_index is the current event we are checking\n        @lru_cache(None)\n        def dp(end: int, event_index: int, k: int):\n            \n            # No more events left or we have checked all possible events\n            if k == 0 or event_index == n:\n                return 0\n            \n            event = events[event_index]\n            event_start, event_end, event_value = event\n            # Can we attend this event?\n            # Does its start time conflict with the previous events end time?\n            # If the start time is the same as the end time we cannot end as well (view example 2)\n            if event_start <= end:\n                # Could not attend, check the next event\n                return dp(end, event_index + 1, k)\n            \n            # We made it here, so we can attend!\n            # Two possible options, we either attend (add the value) or do not attend this event\n            # Value for attending versus the value for skipping\n            attend = event_value + dp(event_end, event_index + 1, k - 1)\n            skip = dp(end, event_index + 1, k)\n            \n            # Get the best option\n            return max(attend, skip)\n            \n        # Clear cache to save memory\n        dp.cache_clear()\n        return dp(0, 0, k)"}
{"prompt": "def check(self, nums: List[int]) -> bool:\n        i = 0\n        while i<len(nums)-1:\n            if nums[i]>nums[i+1]: break    # used to find the rotated position\n            i+=1\n        \n        rotated = nums[i+1:]+nums[:i+1]\n        for i,e in enumerate(rotated):\n            if i<len(rotated)-1 and e>rotated[i+1]:   # check that rerotated array sorted or not\n                return False\n        return True"}
{"prompt": "def maximumScore(self, a: int, b: int, c: int) -> int:\n        a, b, c = sorted((a, b, c))\n        if a + b < c: return a + b\n        return (a + b + c)//2"}
{"prompt": "def largestMerge(self, word1: str, word2: str) -> str:\n        ans = []\n        i1 = i2 = 0\n        while i1 < len(word1) and i2 < len(word2): \n            if word1[i1:] > word2[i2:]: \n                ans.append(word1[i1])\n                i1 += 1\n            else: \n                ans.append(word2[i2])\n                i2 += 1\n        return \"\".join(ans) + word1[i1:] + word2[i2:]"}
{"prompt": "def minAbsDifference(self, nums: List[int], goal: int) -> int:\n        \n        def fn(nums):\n            ans = {0}\n            for x in nums: \n                ans |= {x + y for y in ans}\n            return ans \n        \n        nums0 = sorted(fn(nums[:len(nums)//2]))\n        \n        ans = inf\n        for x in fn(nums[len(nums)//2:]): \n            k = bisect_left(nums0, goal - x)\n            if k < len(nums0): ans = min(ans, nums0[k] + x - goal)\n            if 0 < k: ans = min(ans, goal - x - nums0[k-1])\n        return ans"}
{"prompt": "def minOperations(self, s: str) -> int:\n        count = 0\n        count1 = 0\n        for i in range(len(s)):\n            if i % 2 == 0:\n                if s[i] == '1':\n                    count += 1\n                if s[i] == '0':\n                    count1 += 1\n            else:\n                if s[i] == '0':\n                    count += 1\n                if s[i] == '1':\n                    count1 += 1\n        return min(count, count1)"}
{"prompt": "def countHomogenous(self, s: str) -> int:\n        res, count, n = 0, 1, len(s)\n        for i in range(1,n):\n            if s[i]==s[i-1]:\n                count+=1\n            else:\n                if count>1:\n                    res+=(count*(count-1)//2)\n                count=1    \n        if count>1:\n            res+=(count*(count-1)//2)\n        return (res+n)%(10**9+7)"}
{"prompt": "def minimumSize(self, nums: List[int], maxOperations: int) -> int:\n        lo, hi = 1, 1_000_000_000\n        while lo < hi: \n            mid = lo + hi >> 1\n            if sum((x-1)//mid for x in nums) <= maxOperations: hi = mid\n            else: lo = mid + 1\n        return lo"}
{"prompt": "def minTrioDegree(self, n: int, edges: List[List[int]]) -> int:\n        graph = [[False]*n for _ in range(n)]\n        degree = [0]*n\n        \n        for u, v in edges: \n            graph[u-1][v-1] = graph[v-1][u-1] = True\n            degree[u-1] += 1\n            degree[v-1] += 1\n        \n        ans = inf\n        for i in range(n): \n            for j in range(i+1, n):\n                if graph[i][j]: \n                    for k in range(j+1, n):\n                        if graph[j][k] and graph[k][i]: \n                            ans = min(ans, degree[i] + degree[j] + degree[k] - 6)\n        return ans if ans < inf else -1"}
{"prompt": "def longestNiceSubstring(self, s: str) -> str:\n        ans = \"\"\n        for i in range(len(s)):\n            for ii in range(i+1, len(s)+1):\n                if all(s[k].swapcase() in s[i:ii] for k in range(i, ii)): \n                    ans = max(ans, s[i:ii], key=len)\n        return ans"}
{"prompt": "def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\n        i = 0\n        for grp in groups: \n            for ii in range(i, len(nums)):\n                if nums[ii:ii+len(grp)] == grp: \n                    i = ii + len(grp)\n                    break \n            else: return False\n        return True"}
{"prompt": "def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\n        m, n = len(isWater), len(isWater[0]) # dimensions \n        queue = [(i, j) for i in range(m) for j in range(n) if isWater[i][j]]\n        \n        ht = 0\n        ans = [[0]*n for _ in range(m)]\n        seen = set(queue)\n        \n        while queue: \n            newq = []\n            for i, j in queue: \n                ans[i][j] = ht\n                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \n                    if 0 <= ii < m and 0 <= jj < n and (ii, jj) not in seen: \n                        newq.append((ii, jj))\n                        seen.add((ii, jj))\n            queue = newq\n            ht += 1\n        return ans"}
{"prompt": "def getCoprimes(self, nums: List[int], edges: List[List[int]]) -> List[int]:\n        tree = {} # tree as adjacency list \n        for u, v in edges: \n            tree.setdefault(u, []).append(v)\n            tree.setdefault(v, []).append(u)\n        \n        ans = [-1]*len(nums)\n        path = {} # val -> list of position &amp; depth \n        seen = {0}\n        \n        def fn(k, i): \n            \"\"\"Populate ans via dfs.\"\"\"\n            ii = -1 \n            for x in path:\n                if gcd(nums[k], x) == 1: # coprime \n                    if path[x] and path[x][-1][1] > ii: \n                        ans[k] = path[x][-1][0]\n                        ii = path[x][-1][1]\n                        \n            path.setdefault(nums[k], []).append((k, i))\n            for kk in tree.get(k, []): \n                if kk not in seen: \n                    seen.add(kk)\n                    fn(kk, i+1)\n            path[nums[k]].pop()\n            \n            \n        fn(0, 0)\n        return ans"}
{"prompt": "def mergeAlternately(self, word1: str, word2: str) -> str:\n        \n        res=''\n        \n        for i in range(min(len(word1),len(word2))):\n            res += word1[i] + word2[i]\n            \n        return res + word1[i+1:] + word2[i+1:]"}
{"prompt": "def minOperations(self, boxes: str) -> List[int]:\n        ans = [0]*len(boxes)\n        leftCount, leftCost, rightCount, rightCost, n = 0, 0, 0, 0, len(boxes)\n        for i in range(1, n):\n            if boxes[i-1] == '1': leftCount += 1\n            leftCost += leftCount # each step move to right, the cost increases by # of 1s on the left\n            ans[i] = leftCost\n        for i in range(n-2, -1, -1):\n            if boxes[i+1] == '1': rightCount += 1\n            rightCost += rightCount\n            ans[i] += rightCost\n        return ans"}
{"prompt": "def maximumScore(self, nums: List[int], multipliers: List[int]) -> int:\n        n, m = len(nums), len(multipliers)\n        dp = [[0]*m for _ in range(m+1)]\n        \n        for i in reversed(range(m)):\n            for j in range(i, m): \n                k = i + m - j - 1\n                dp[i][j] = max(nums[i] * multipliers[k] + dp[i+1][j], nums[j-m+n] * multipliers[k] + dp[i][j-1])\n        \n        return dp[0][-1]"}
{"prompt": "def longestPalindrome(self, word1: str, word2: str) -> int:\n        \n        @cache\n        def fn(lo, hi):\n            \"\"\"Return length of longest palindromic subsequence.\"\"\"\n            if lo >= hi: return int(lo == hi)\n            if word[lo] == word[hi]: return 2 + fn(lo+1, hi-1)\n            return max(fn(lo+1, hi), fn(lo, hi-1))\n        \n        ans = 0\n        word = word1 + word2\n        for x in ascii_lowercase: \n            i = word1.find(x) \n            j = word2.rfind(x)\n            if i != -1 and j != -1: ans = max(ans, fn(i, j + len(word1)))\n        return ans"}
{"prompt": "def countMatches(self, items: List[List[str]], ruleKey: str, ruleValue: str) -> int:\n        d = {'type': 0, 'color': 1, 'name': 2}\n        return sum(1 for item in items if item[d[ruleKey]] == ruleValue)"}
{"prompt": "def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n        \n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i == len(toppingCosts): return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans"}
{"prompt": "def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\n        if 6*len(nums1) < len(nums2) or 6*len(nums2) < len(nums1): return -1 # impossible \n        \n        if sum(nums1) < sum(nums2): nums1, nums2 = nums2, nums1\n        s1, s2 = sum(nums1), sum(nums2)\n            \n        nums1 = [-x for x in nums1] # max-heap \n        heapify(nums1)\n        heapify(nums2)\n        \n        ans = 0\n        while s1 > s2: \n            x1, x2 = nums1[0], nums2[0]\n            if -1-x1 > 6-x2: # change x1 to 1\n                s1 += x1 + 1\n                heapreplace(nums1, -1)\n            else: \n                s2 += 6 - x2\n                heapreplace(nums2, 6)\n            ans += 1\n        return ans"}
{"prompt": "def getCollisionTimes(self, cars: List[List[int]]) -> List[float]:\n        # Stack: go from back and use stack to get ans\n        # Time: O(n)\n        # Space: O(n)\n        \n        stack = [] # index\n        ans = [-1] * len(cars)\n        for i in range(len(cars)-1,-1,-1):\n            # remove cars that are faster than current car since it will never collide\n            while stack and cars[i][1] <= cars[stack[-1]][1]: \n                stack.pop()\n\n            while stack: # if car left, we can compute collide time with current car. \n                collision_t = (cars[stack[-1]][0] - cars[i][0]) / (cars[i][1] - cars[stack[-1]][1])\n                # if current car's collide time is greater than previous car's collide time \n                # (previous collided before current), then we have to find previous car's previous car\n                # to compute collide time with that car, so we pop from stack and re-process\n                # Otherwise, we add that collide time to answer and break\n                if ans[stack[-1]] == -1 or collision_t <= ans[stack[-1]]:\n                    ans[i] = collision_t\n                    break\n                stack.pop()\n            stack.append(i)\n        return ans"}
{"prompt": "def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:\n        minDist = math.inf\n        ans = -1\n        for i in range(len(points)):\n            if points[i][0]==x or points[i][1]==y:\n                manDist = abs(points[i][0]-x)+abs(points[i][1]-y)\n                if manDist<minDist:\n                    ans = i\n                    minDist = manDist\n        return ans"}
{"prompt": "def checkPowersOfThree(self, n: int) -> bool:\n        while n:\n            n, rem = divmod(n, 3)\n            if rem == 2:\n                return False\n        return True"}
{"prompt": "def beautySum(self, s: str) -> int:\n        ans = 0 \n        for i in range(len(s)):\n            freq = [0]*26\n            for j in range(i, len(s)):\n                freq[ord(s[j])-97] += 1\n                ans += max(freq) - min(x for x in freq if x)\n        return ans"}
{"prompt": "def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:\n        degree = [0]*n\n        freq = defaultdict(int)\n        for u, v in edges: \n            degree[u-1] += 1\n            degree[v-1] += 1\n            freq[min(u-1, v-1), max(u-1, v-1)] += 1\n        \n        vals = sorted(degree)\n        \n        ans = []\n        for query in queries: \n            cnt = 0 \n            lo, hi = 0, n-1\n            while lo < hi: \n                if query < vals[lo] + vals[hi]: \n                    cnt += hi - lo # (lo, hi), (lo+1, hi), ..., (hi-1, hi) all valid\n                    hi -= 1\n                else: lo += 1\n            for u, v in freq: \n                if degree[u] + degree[v] - freq[u, v] <= query < degree[u] + degree[v]: cnt -= 1\n            ans.append(cnt)\n        return ans"}
{"prompt": "def checkOnesSegment(self, s: str) -> bool:\n        return \"01\" not in s"}
{"prompt": "def minElements(self, nums: List[int], limit: int, goal: int) -> int:\n        return math.ceil(abs(goal - sum(nums)) / limit)"}
{"prompt": "def countRestrictedPaths(self, n: int, edges: List[List[int]]) -> int:\n        graph = {} # graph as adjacency list \n        for u, v, w in edges: \n            graph.setdefault(u, []).append((v, w))\n            graph.setdefault(v, []).append((u, w))\n        \n        queue = [n]\n        dist = {n: 0}\n        while queue: \n            newq = []\n            for u in queue: \n                for v, w in graph[u]:\n                    if v not in dist or dist[u] + w < dist[v]: \n                        dist[v] = dist[u] + w\n                        newq.append(v)\n            queue = newq\n        \n        @cache\n        def fn(u): \n            \"\"\"Return number of restricted paths from u to n.\"\"\"\n            if u == n: return 1 # boundary condition \n            ans = 0\n            for v, _ in graph[u]: \n                if dist[u] > dist[v]: ans += fn(v)\n            return ans \n        \n        return fn(1) % 1_000_000_007"}
{"prompt": "def minChanges(self, nums: List[int], k: int) -> int:\n        freq = defaultdict(lambda: defaultdict(int))\n        for i, x in enumerate(nums): freq[i%k][x] += 1 # freq by row\n        \n        n = 1 << 10\n        dp = [0] + [-inf]*(n-1)\n        for i in range(k): \n            mx = max(dp)\n            tmp = [0]*n\n            for x, c in enumerate(dp): \n                for xx, cc in freq[i].items(): \n                    tmp[x^xx] = max(tmp[x^xx], c + cc, mx)\n            dp = tmp \n        return len(nums) - dp[0]"}
{"prompt": "def areAlmostEqual(self, s1: str, s2: str) -> bool:\n        diff = [[x, y] for x, y in zip(s1, s2) if x != y]\n        return not diff or len(diff) == 2 and diff[0][::-1] == diff[1]"}
{"prompt": "def findCenter(self, edges: List[List[int]]) -> int:\n        \n        \"\"\" From the Constraints: A valid STAR GRAPH is confirmed. \n\t\tThat means the center will be common to every edges. \n\t\tTherefore we can get the center by comparing only first 2 elements\"\"\"\n        \n        for i in range (1):\n            \n            # Check if first element of first edge mathches with any element of second edges\n            \n            if edges[i][0] == edges [i+1][0] or edges[i][0] == edges[i+1][1]:\n                return edges[i][0]\n            \n            #Otherwise second element of first edge will be the answer\n            else:\n                return edges[i][1]"}
{"prompt": "def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\n\t\t\n\t\tn = len(classes)\n\t\t\n\t\timpacts = [0]*n\n\t\tminRatioIndex = 0\n\t\t\n\t\t# calculate and store impacts for each class in form of tuples -> (-impactValue, passCount, totalCount)\n\t\tfor i in range(n):\n\t\t\tpassCount = classes[i][0]\n\t\t\ttotalCount = classes[i][1]\n\t\t\t\n\t\t\t# calculate the impact  for class i\n\t\t\tcurrentRatio = passCount/totalCount\n\t\t\texpectedRatioAfterUpdate = (passCount+1)/(totalCount+1)\n\t\t\timpact = expectedRatioAfterUpdate - currentRatio\n\t\t\t\n\t\t\timpacts[i] = (-impact, passCount, totalCount)  # note the - sign for impact\n\t\t\t\n\t\theapq.heapify(impacts)\n\t\t\n\t\twhile(extraStudents > 0):\n\t\t\t# pick the next class with greatest impact \n\t\t\t_, passCount, totalCount = heapq.heappop(impacts)\n\t\t\t\n\t\t\t# assign a student to the class\n\t\t\tpassCount+=1\n\t\t\ttotalCount+=1\n\t\t\t\n\t\t\t# calculate the updated impact  for current class\n\t\t\tcurrentRatio = passCount/totalCount\n\t\t\texpectedRatioAfterUpdate = (passCount+1)/(totalCount+1)\n\t\t\timpact = expectedRatioAfterUpdate - currentRatio\n\t\t\t\n\t\t\t# insert updated impact back into the heap\n\t\t\theapq.heappush(impacts, (-impact, passCount, totalCount))\n\t\t\textraStudents -= 1\n\t\t\n\t\tresult = 0\n\t\t\t\n\t\t# for all the updated classes calculate the total passRatio \n\t\tfor _, passCount, totalCount in impacts:\n\t\t\tresult += passCount/totalCount\n\t\t\t\n\t\t# return the average pass ratio\n\t\treturn result/n"}
{"prompt": "def maximumScore(self, nums: List[int], k: int) -> int:\n        ans = mn = nums[k]\n        lo = hi = k\n        while 0 <= lo-1 or hi+1 < len(nums): \n            if lo == 0 or hi+1 < len(nums) and nums[lo-1] < nums[hi+1]: \n                hi += 1\n                mn = min(mn, nums[hi])\n            else: \n                lo -= 1\n                mn = min(mn, nums[lo])\n            ans = max(ans, mn * (hi-lo+1))\n        return ans"}
{"prompt": "def secondHighest(self, s: str) -> int:\n        s=set(s)\n        a=[]\n        for i in s:\n            if i.isnumeric() :\n                a.append(int(i))\n        a.sort()\n        if len(a)<2:\n            return -1\n        return a[len(a)-2]"}
{"prompt": "def getMaximumConsecutive(self, coins: List[int]) -> int:\n        coins.sort()\n        \n        res = 1\n        \n        for coin in coins:\n            if (res >= coin):\n                res += coin\n        \n        return res"}
{"prompt": "def maxScore(self, nums: List[int]) -> int:\n        \n        @cache\n        def fn(nums, k): \n            \"\"\"Return max score from nums at kth step.\"\"\"\n            if not nums: return 0 # boundary condition \n            ans = 0 \n            for i in range(len(nums)):\n                for j in range(i+1, len(nums)): \n                    rest = nums[:i] + nums[i+1:j] + nums[j+1:]\n                    ans = max(ans, k*gcd(nums[i], nums[j]) + fn(tuple(rest), k+1))\n            return ans\n        \n        return fn(tuple(nums), 1)"}
{"prompt": "def maxAscendingSum(self, nums: List[int]) -> int:\n        ans = 0\n        for i, x in enumerate(nums): \n            if not i or nums[i-1] >= nums[i]: val = 0 # reset val \n            val += nums[i]\n            ans = max(ans, val)\n        return ans"}
{"prompt": "def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\n        ans = 0\n        buy, sell = [], [] # max-heap &amp; min-heap \n        \n        for p, q, t in orders: \n            ans += q\n            if t: # sell order\n                while q and buy and -buy[0][0] >= p: # match \n                    pb, qb = heappop(buy)\n                    ans -= 2*min(q, qb)\n                    if q < qb: \n                        heappush(buy, (pb, qb-q))\n                        q = 0 \n                    else: q -= qb \n                if q: heappush(sell, (p, q))\n            else: # buy order \n                while q and sell and sell[0][0] <= p: # match \n                    ps, qs = heappop(sell)\n                    ans -= 2*min(q, qs)\n                    if q < qs: \n                        heappush(sell, (ps, qs-q))\n                        q = 0 \n                    else: q -= qs \n                if q: heappush(buy, (-p, q))\n            \n        return ans % 1_000_000_007"}
{"prompt": "def maxValue(self, n: int, index: int, maxSum: int) -> int:\n        res_i, crr_sum = 0, n\n        l, r, w_hill = index + 1, index - 1, 1 # left/right indices and width of the hill\n        while crr_sum <= maxSum:\n            l -= 1\n            r += 1\n            if l == index and r == index:\n                crr_sum += w_hill\n            else:\n                l_, r_ = max(l, 0), min(r, n - 1)\n\t\t\t\t'''\n\t\t\t\twhen the hill has the same width as the ground, \n\t\t\t\tsimply just speed up growing by adding the result \n\t\t\t\tof dividing (maxSum - crr_sum) by w_hill\n\t\t\t\t'''\n                if l < l_ and r > r_:\n                    rm = maxSum - crr_sum\n                    res_i += int(rm / w_hill) + 1\n                    break\n                else:\n                    w_hill = r_ - l_ + 1\n                    crr_sum += w_hill\n            res_i += 1\n        return res_i"}
{"prompt": "def numDifferentIntegers(self, word: str) -> int:\n        \n        word = re.findall('(\\d+)', word)\n        numbers = [int(i) for i in word]\n        \n        return len(set(numbers))"}
{"prompt": "def reinitializePermutation(self, n: int) -> int:\n        ans = 0\n        perm = list(range(n))\n        while True: \n            ans += 1\n            perm = [perm[n//2+(i-1)//2] if i&amp;1 else perm[i//2] for i in range(n)]\n            if all(perm[i] == i for i in range(n)): return ans"}
{"prompt": "def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\n        knowledge = dict(knowledge)\n        answer, start = [], None\n        for i, char in enumerate(s):\n            if char == '(': \n                start = i + 1\n            elif char == ')':\n                answer.append(knowledge.get(s[start:i], '?'))\n                start = None\n            elif start is None: \n                answer.append(char)\n        return ''.join(answer)"}
{"prompt": "def maxNiceDivisors(self, primeFactors: int) -> int:\n        mod = 1_000_000_007\n        if primeFactors % 3 == 0: return pow(3, primeFactors//3, mod)\n        if primeFactors % 3 == 1: return 1 if primeFactors == 1 else 4*pow(3, (primeFactors-4)//3, mod) % mod\n        return 2*pow(3, primeFactors//3, mod) % mod"}
{"prompt": "def squareIsWhite(self, c: str) -> bool:\n        if c[0] in 'aceg':\n            return int(c[1])%2==0\n        elif c[0] in 'bdfh':\n            return int(c[1])%2==1\n        return False"}
{"prompt": "def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\n        if len(sentence2)>len(sentence1):\n            return self.areSentencesSimilar(sentence2,sentence1)\n        sentence1=sentence1.split(\" \")\n        sentence2=sentence2.split(\" \")\n        s1=sentence1[:]\n        s2=sentence2[:]\n        while s1[0]==s2[0]:\n                s1.pop(0)\n                s2.pop(0)\n                if not s2:\n                    return True\n        if not s2:\n            return True\n        while s1[-1]==s2[-1]:\n                s1.pop()\n                s2.pop()\n                if not s2:\n                    return True\n        if not s2:\n            return True\n        return False"}
{"prompt": "def countNicePairs(self, nums: List[int]) -> int:\n        \n        # define constants\n        n = len(nums)\n        MOD = 10**9 + 7\n        \n        # handle scenario for no pairs\n        if n<=1:\n            return 0\n        \n        # utility method to calculate reverse of a number\n        # e.g. rev(123) -> 321\n        def rev(i):\n            new = 0\n            while(i!=0):\n                r = i%10\n                new = new*10+r\n                i = i//10\n            return new\n        \n        # calculate frequency of all the diffs\n        freq_counter = defaultdict(int)\n        for num in nums:\n            freq_counter[num-rev(num)] += 1\n        \n        # for all the frequencies calculate the number of paris\n        # which is basically nC2 (read as - \"n choose 2\") -> n*(n-1)/2\n        answer = 0\n        for freq in freq_counter.keys():\n            count = freq_counter[freq]\n            # note the modulo operation being performed to handle large answer\n            answer = (answer + (count*(count-1))//2)%MOD\n                          \n        return answer"}
{"prompt": "def maxHappyGroups(self, bs: int, gs: List[int]) -> int:\n        c = {i: 0 for i in range(bs)}\n        for g in gs:\n            c[g % bs] += 1\n        ret = c[0]\n        c[0] = 0\n        \n        \n        def get_keys(num):\n            keys = []\n            def rec(stack):\n                if len(stack) == num:\n                    if sum(stack) % bs == 0:\n                        keys.append(Counter(stack))\n                else:\n                    for i in range(stack[-1] if stack else bs - 1, - 1, - 1):\n                        stack.append(i)\n                        rec(stack)\n                        stack.pop()\n            rec([])\n            return keys\n        \n        def get_diff_keys(num):\n            keys = []\n            def rec(stack):\n                if len(stack) == num:\n                    if sum(stack) % bs == 0:\n                        keys.append(Counter(stack))\n                else:\n                    for i in range(stack[-1] - 1 if stack else bs - 1, - 1, - 1):\n                        stack.append(i)\n                        rec(stack)\n                        stack.pop()\n            rec([])\n            return keys\n        \n        for tc in range(2, bs):\n            for keys in get_diff_keys(tc):\n                add = min(c[key] // keys[key] for key in keys)\n                if add == 0: continue\n                ret += add\n                for key in keys:\n                    c[key] -= add * keys[key]\n        tc = 2\n        while True:\n            for keys in get_keys(tc):\n                add = min(c[key] // keys[key] for key in keys)\n                if add == 0: continue\n                ret += add\n                for key in keys:\n                    c[key] -= add * keys[key]\n            if tc > sum(c.values()): break\n            tc += 1\n        return ret + bool(sum(c.values()))\n            \n        ```"}
{"prompt": "def truncateSentence(self, s: str, k: int) -> str:\n        words = s.split(\" \")\n        return \" \".join(words[0:k])"}
{"prompt": "def findingUsersActiveMinutes(self, logs: List[List[int]], k: int) -> List[int]:\n        mp = {}\n        for i, t in logs: \n            mp.setdefault(i, set()).add(t)\n            \n        ans = [0]*k\n        for v in mp.values(): \n            if len(v) <= k: \n                ans[len(v)-1] += 1\n        return ans"}
{"prompt": "def minAbsoluteSumDiff(self, nums1: List[int], nums2: List[int]) -> int:\n\t\tn = len(nums1)\n\t\tdiff = []\n\t\tsum = 0\n\t\tfor i in range(n):\n\t\t\ttemp = abs(nums1[i]-nums2[i])\n\t\t\tdiff.append(temp)\n\t\t\tsum += temp\n\t\tnums1.sort()\n\t\tbest_diff = []\n\t\tfor i in range(n):\n\t\t\tidx = bisect.bisect_left(nums1, nums2[i])\n\t\t\tif idx != 0 and idx != n:\n\t\t\t\tbest_diff.append(\n\t\t\t\t\tmin(abs(nums2[i]-nums1[idx]), abs(nums2[i]-nums1[idx-1])))\n\t\t\telif idx == 0:\n\t\t\t\tbest_diff.append(abs(nums2[i]-nums1[idx]))\n\t\t\telse:\n\t\t\t\tbest_diff.append(abs(nums2[i]-nums1[idx-1]))\n\t\tsaved = 0\n\t\tfor i in range(n):\n\t\t\tsaved = max(saved, diff[i]-best_diff[i])\n\t\treturn (sum-saved) % ((10**9)+(7))"}
{"prompt": "def countDifferentSubsequenceGCDs(self, nums: List[int]) -> int:\n        nums = set(nums)\n        \n        ans = 0\n        m = max(nums)\n        for x in range(1, m+1): \n            g = 0\n            for xx in range(x, m+1, x): \n                if xx in nums: \n                    g = gcd(g, xx)\n            if g == x: ans += 1\n        return ans"}
{"prompt": "def arraySign(self, nums: List[int]) -> int:\n        ans = 1\n        for x in nums: \n            if x == 0: return 0 \n            if x < 0: ans *= -1\n        return ans"}
{"prompt": "def findTheWinner(self, n: int, k: int) -> int:\n        nums = list(range(n))\n        i = 0 \n        while len(nums) > 1: \n            i = (i + k-1) % len(nums)\n            nums.pop(i)\n        return nums[0] + 1"}
{"prompt": "def minSideJumps(self, obstacles: List[int]) -> int:\n        n = len(obstacles)\n        dp = [[sys.maxsize] * n for _ in range(3)]\n        dp[0][0]= 1\n        dp[1][0]= 0\n        dp[2][0]= 1\n        for i in range(1, n):\n            dp[0][i] = dp[0][i-1] if obstacles[i] != 1 else sys.maxsize\n            dp[1][i] = dp[1][i-1] if obstacles[i] != 2 else sys.maxsize\n            dp[2][i] = dp[2][i-1] if obstacles[i] != 3 else sys.maxsize\n            if obstacles[i] != 1:\n                for j in [1, 2]:\n                    dp[0][i] = min(dp[0][i], dp[j][i] + 1 if obstacles[i] != j+1 else sys.maxsize)\n            if obstacles[i] != 2:\n                for j in [0, 2]:\n                    dp[1][i] = min(dp[1][i], dp[j][i] + 1 if obstacles[i] != j+1 else sys.maxsize)\n            if obstacles[i] != 3:\n                for j in [0, 1]:\n                    dp[2][i] = min(dp[2][i], dp[j][i] + 1 if obstacles[i] != j+1 else sys.maxsize)\n        return min(dp[0][-1], dp[1][-1], dp[2][-1])"}
{"prompt": "def minOperations(self, nums: List[int]) -> int:\n        count = 0\n        for i in range(1,len(nums)):\n            if nums[i] <= nums[i-1]:\n                x = nums[i]\n                nums[i] += (nums[i-1] - nums[i]) + 1\n                count += nums[i] - x\n        return count"}
{"prompt": "def countPoints(self, points: List[List[int]], queries: List[List[int]]) -> List[int]:\n        return [sum(math.sqrt((x0-x1)**2 + (y0-y1)**2) <= r for x1, y1 in points) for x0, y0, r in queries]"}
{"prompt": "def getMaximumXor(self, nums: List[int], maximumBit: int) -> List[int]:\n        res = []\n        for i in range(1,len(nums)):\n            res.append(2**maximumBit - 1 - nums[i-1])\n            nums[i] = nums[i-1]^nums[i]\n        res.append(2**maximumBit - 1 - nums[-1])\n        return res[::-1]"}
{"prompt": "def makeStringSorted(self, s: str) -> int:\n        freq = [0]*26\n        for c in s: freq[ord(c) - 97] += 1\n        \n        MOD = 1_000_000_007\n        fac = cache(lambda x: x*fac(x-1)%MOD if x else 1)\n        ifac = cache(lambda x: pow(fac(x), MOD-2, MOD)) # Fermat's little theorem (a**(p-1) = 1 (mod p))\n        \n        ans, n = 0, len(s)\n        for c in s: \n            val = ord(c) - 97\n            mult = fac(n-1)\n            for k in range(26): mult *= ifac(freq[k])\n            for k in range(val): ans += freq[k] * mult\n            n -= 1\n            freq[val] -= 1\n        return ans % MOD"}
{"prompt": "def checkIfPangram(self, sentence: str) -> bool:\n        lst=[0]*26\n        for i in sentence:\n            lst[ord(i)-ord('a')]+=1\n        return 0 not in lst"}
{"prompt": "def maxIceCream(self, costs: List[int], coins: int) -> int:\n        '''\n        1. If the minimum of all costs is greater than amount of coins, the boy can't buy any bar, return 0\n        2. Else, sort the list of costs in a non-decreasing order\n        3. For each 'cost' in costs, if the cost is less than current coins\n                -increase the count of ice cream bars that can be bought by 1\n                -decrease the current coins amount by 'cost'\n        4. If the cost is greater than current coins, return the ice cream bar count value\n        '''\n        \n        if min(costs)>coins:        #minimum cost is greater than the coins available        \n            return 0                #can't buy any ice cream bar\n        \n        costs=sorted(costs)         #sort the list of costs in a non-decreasing order\n        res = 0                     #the resultant count of ice cream bars that can be bought\n        for cost in costs:\n            if cost<=coins:         #in this case, the boy can buy the ice cream bar\n                res+=1              #increase the ice cream bar count\n                coins-=cost         #spent an amount equal to 'cost', decrease current coins amount by cost\n            else:\n                break               #not enough coins, return the bars count\n            \n        return res"}
{"prompt": "def getOrder(self, tasks: List[List[int]]) -> List[int]:\n        dic=defaultdict(list)\n        \n        for i in range(len(tasks)):\n            dic[tasks[i][0]].append((tasks[i][1],i))\n        \n        \n        ans=[]\n        keys=sorted(dic.keys())\n        \n        while keys:\n            k=keys.pop(0)\n            pq=dic[k]\n            heapq.heapify(pq)\n            time=k\n            \n            while pq:\n                p_time,ind=heapq.heappop(pq)\n                ans.append(ind)\n                time+=p_time\n                while keys:\n                    if keys[0]>time:\n                        break\n                    for item in dic[keys.pop(0)]:\n                        heapq.heappush(pq,item)\n        return ans"}
{"prompt": "#example 1 \n    #result =[(1&amp;6)^(1&amp;5)^(2&amp;6)^(2&amp;5)^(3&amp;6)^(3&amp;5)]\n                \\     /     \\    /      \\     /\n    #           (1&amp;(6^5)) ^ (2&amp;(6^5)) ^ (3&amp;(6^5))   \n                   \\            |           /\n                    \\           |          /\n                     \\          |         /\n                      \\         |        /\n    #                  ((1^2^3) &amp; (6^5))\n    def getXORSum(self, a, b):\n        x = 0 \n        for i in range(len(a)):\n            x = x ^ a[i]\n        y = 0 \n        for j in range(len(b)):\n            y = y ^ b[j]\n        return x &amp; y"}
{"prompt": "def sumBase(self, n: int, k: int) -> int:\n        ans = 0\n        while n: \n            n, x = divmod(n, k)\n            ans += x\n        return ans"}
{"prompt": "def maxFrequency(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        n = len(nums)\n        sum_s_w = nums[0]\n        fin = 1\n        i=0\n        for j in range(1,n):\n            sum_s_w+=nums[j]\n            mx = nums[j]\n            while sum_s_w+k<mx*(j-i+1):\n                sum_s_w -= nums[i]\n                i += 1\n            fin = max(fin,j-i+1)\n        return fin"}
{"prompt": "def longestBeautifulSubstring(self, word: str) -> int:\n        vowels = \"aeiou\"\n        ans = 0\n        cnt = prev = -1 \n        for i, x in enumerate(word): \n            curr = vowels.index(x)\n            if cnt >= 0: # in the middle of counting \n                if 0 <= curr - prev <= 1: \n                    cnt += 1\n                    if x == \"u\": ans = max(ans, cnt)\n                elif x == \"a\": cnt = 1\n                else: cnt = -1 \n            elif x == \"a\": cnt = 1\n            prev = curr \n        return ans"}
{"prompt": "def maxBuilding(self, n: int, restrictions: List[List[int]]) -> int:\n        restrictions.extend([[1, 0], [n, n-1]])\n        restrictions.sort()\n        \n        for i in reversed(range(len(restrictions)-1)): \n            restrictions[i][1] = min(restrictions[i][1], restrictions[i+1][1] + restrictions[i+1][0] - restrictions[i][0])\n        \n        ans = 0 \n        for i in range(1, len(restrictions)): \n            restrictions[i][1] = min(restrictions[i][1], restrictions[i-1][1] + restrictions[i][0] - restrictions[i-1][0])\n            ans = max(ans, (restrictions[i-1][1] + restrictions[i][0] - restrictions[i-1][0] + restrictions[i][1])//2)\n        return ans"}
{"prompt": "def replaceDigits(self, s: str) -> str:\n\n        ans = \"\"\n\n        def shift(char, num):\n            return chr(ord(char) + int(num))\n\n        for index in range(len(s)):\n            ans += shift(s[index-1], s[index]) if index % 2 else s[index]\n\n        return ans"}
{"prompt": "def maximumElementAfterDecrementingAndRearranging(self, arr: List[int]) -> int:\n\t\tcounter = collections.Counter(arr)\n        available = sum(n > len(arr) for n in arr)\n        i = ans = len(arr)\n        while i > 0:\n            # This number is not in arr\n            if not counter[i]:\n                # Use another number to fill in its place. If we cannot, we have to decrease our max\n                if available: available -= 1               \n                else: ans -= 1\n            # Other occurences can be used for future.\n            else:\n                available += counter[i] - 1\n            i -= 1\n        return ans"}
{"prompt": "def closestRoom(self, rooms: List[List[int]], queries: List[List[int]]) -> List[int]:\n        ans = [0] * len(queries)\n        \n        # sort queries to handle largest size queries first\n        q = deque(sorted([(size, room, i) for i, (room, size) in enumerate(queries)], key=lambda a: (-a[0], a[1], a[2])))\n\n        # sort rooms by descending size\n        rooms = deque(sorted(rooms, key=lambda x: -x[1]))\n\n        # current available room ids\n        cands = []\n        \n        \n        while q:\n            size, room, i = q.popleft()\n            # add room ids to candidates as long as top of room size meet the requirements\n            while rooms and rooms[0][1] >= size:\n                bisect.insort(cands, rooms.popleft()[0])\n                    \n            # if no room size available, return -1\n            if not cands: ans[i] = -1\n                \n            # else use bisect to find optimal room ids\n            else:\n                loc = bisect.bisect_left(cands, room)\n                if loc == 0: ans[i] = cands[loc]\n                elif loc == len(cands): ans[i] = cands[-1]\n                else: ans[i] = cands[loc - 1] if room - cands[loc - 1] <= cands[loc] - room else cands[loc]\n        \n        return ans"}
{"prompt": "def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\n        ans = inf\n        for i, x in enumerate(nums): \n            if x == target: \n                ans = min(ans, abs(i - start))\n        return ans"}
{"prompt": "def splitString(self, s: str) -> bool:\n        \n        \"\"\"\n        Time = O(2^N)\n        Space = O(N) space from stack\n        \n        \"\"\"\n        def dfs(index: int, last: int) -> bool:\n            if index == len(s):\n                return True\n            \n\t\t\t# j: [index, len(s)-1]\n            for j in range(index, len(s)):\n\t\t\t\t# cur: [index, index] ~ [index, len(s)-1]\n                cur = int(s[index:j + 1])\n\t\t\t\t# last: [...,index-1]\n\t\t\t\t# cur: [index+1, j]\n\t\t\t\t# last = cur -> next: [j+1,...)\n\t\t\t\t# DFS condition: cur = last - 1 &amp;&amp; dfs(j+1, cur) == true\n                if cur == last - 1 and dfs(j + 1, cur):\n                    return True\n            return False\n        \n        for i in range(len(s) - 1):\n            last = int(s[:i+1])\n            if dfs(i + 1, last):\n                return True\n        return False"}
{"prompt": "def getMinSwaps(self, num: str, k: int) -> int:\n        num = list(num)\n        orig = num.copy()\n        \n        for _ in range(k): \n            for i in reversed(range(len(num)-1)): \n                if num[i] < num[i+1]: \n                    ii = i+1 \n                    while ii < len(num) and num[i] < num[ii]: ii += 1\n                    num[i], num[ii-1] = num[ii-1], num[i]\n                    lo, hi = i+1, len(num)-1\n                    while lo < hi: \n                        num[lo], num[hi] = num[hi], num[lo]\n                        lo += 1\n                        hi -= 1\n                    break \n        \n        ans = 0\n        for i in range(len(num)): \n            ii = i\n            while orig[i] != num[i]: \n                ans += 1\n                ii += 1\n                num[i], num[ii] = num[ii], num[i]\n        return ans"}
{"prompt": "def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\n    \n    intervals.sort(key = lambda x:x[1]-x[0])\n    q = sorted([qu,i] for i,qu in enumerate(queries))\n    res=[-1]*len(queries)\n\t\n    for left,right in intervals:\n        ind = bisect.bisect(q,[left])\n        while ind<len(q) and q[ind][0]<=right:\n            res[q.pop(ind)[1]]=right-left+1\n    return res"}
{"prompt": "def maximumPopulation(self, logs: List[List[int]]) -> int:\n        # the timespan 1950-2050 covers 101 years\n\t\tdelta = [0] * 101\n\n\t\t# to make explicit the conversion from the year (1950 + i) to the ith index\n        conversionDiff = 1950 \n\t\t\n        for l in logs:\n\t\t\t# the log's first entry, birth, increases the population by 1\n            delta[l[0] - conversionDiff] += 1 \n\t\t\t\n\t\t\t# the log's second entry, death, decreases the population by 1\n            delta[l[1] - conversionDiff] -= 1\n        \n        runningSum = 0\n        maxPop = 0\n        year = 1950\n\t\t\n\t\t# find the year with the greatest population\n        for i, d in enumerate(delta):\n            runningSum += d\n\t\t\t\n\t\t\t# since we want the first year this population was reached, only update if strictly greater than the previous maximum population\n            if runningSum > maxPop:\n                maxPop = runningSum\n                year = conversionDiff + i\n\t\t\t\t\n        return year"}
{"prompt": "def maxDistance(self, nums1: List[int], nums2: List[int]) -> int:\n        length1, length2 = len(nums1), len(nums2)\n        i,j = 0,0\n        \n        result = 0\n        while i < length1 and j < length2:\n            if nums1[i] > nums2[j]:\n                i+=1\n            else:\n                result = max(result,j-i)\n                j+=1\n            \n        return result"}
{"prompt": "def maxSumMinProduct(self, nums: List[int]) -> int:\n        prefix = [0]\n        for x in nums: prefix.append(prefix[-1] + x)\n        \n        ans = 0 \n        stack = []\n        for i, x in enumerate(nums + [-inf]): # append \"-inf\" to force flush all elements\n            while stack and stack[-1][1] >= x: \n                _, xx = stack.pop()\n                ii = stack[-1][0] if stack else -1 \n                ans = max(ans, xx*(prefix[i] - prefix[ii+1]))\n            stack.append((i, x))\n        return ans % 1_000_000_007"}
{"prompt": "def largestPathValue(self, colors, edges):\n        n=len(colors)\n        graph=defaultdict(list)\n        indegree=defaultdict(int)\n        \n        for u,v in edges:\n            graph[u].append(v)\n            indegree[v]+=1\n        \n        queue=[]    \n        dp=[[0]*26 for _ in range(n)]\n        colorvalues=[ord(c)-ord(\"a\") for c in colors]\n        for u in range(n):\n            if u not in indegree:\n                queue.append(u)\n                dp[u][colorvalues[u]]=1\n            \n        visited=0\n        while queue:\n            u=queue.pop()\n            visited+=1\n\n            for v in graph[u]:\n                for c in range(26):\n                    dp[v][c]=max(dp[v][c],dp[u][c] + (c==colorvalues[v]))\n                indegree[v]-=1\n                if indegree[v]==0:\n                    queue.append(v)\n                    del indegree[v]\n        if visited<n:\n            return -1\n        return max(max(x) for x in dp)\n\t\t```"}
{"prompt": "def sortSentence(self, s: str) -> str:\n        arr = [i[-1] + i[:-1] for i in s.split()]\n        \n        arr.sort()\n        \n        ans = \"\"\n        for i in arr:\n            ans += i[1:] + ' '\n        \n        return ans[:-1]"}
{"prompt": "def memLeak(self, memory1: int, memory2: int) -> List[int]:\n        i = 1\n        while max(memory1, memory2) >= i:\n            if memory1 >= memory2:\n                memory1 -= i\n            else:\n                memory2 -= i\n            i += 1\n        return [i, memory1, memory2]"}
{"prompt": "def rotateTheBox(self, box: List[List[str]]) -> List[List[str]]:\n        # move stones to right, row by row\n        for i in range(len(box)):\n            stone = 0\n            for j in range(len(box[0])):\n                if box[i][j] == '#': # if a stone\n                    stone += 1\n                    box[i][j] = '.'\n                elif box[i][j] == '*': # if a obstacle\n                    for m in range(stone):\n                        box[i][j-m-1] = '#'\n                    stone = 0\n            # if reaches the end of j, but still have stone\n            if stone != 0:\n                for m in range(stone):\n                        box[i][j-m] = '#'\n        \n        # rotate box, same as leetcode #48\n        box[:]  = zip(*box[::-1])\n        \n        return box"}
{"prompt": "def sumOfFlooredPairs(self, nums: List[int]) -> int:\n        sumP = 0 #To store the value of Sum of floor values\n        for i in nums: #Traverse every element in nums\n            for j in nums: #Traverse every element in nums\n                sumP += (j//i) #Simply do floor division and add the number to sumP\n        return sumP % (10**9 +7)#return the sumof the pairs"}
{"prompt": "def subsetXORSum(self, nums: List[int]) -> int:\n        ans = 0\n        for mask in range(1 << len(nums)): \n            val = 0\n            for i in range(len(nums)): \n                if mask &amp; 1 << i: val ^= nums[i]\n            ans += val\n        return ans"}
{"prompt": "def minSwaps(self, s: str) -> int:\n        ones = s.count(\"1\")\n        zeros = len(s) - ones \n        if abs(ones - zeros) > 1: return -1 # impossible\n        \n        def fn(x): \n            \"\"\"Return number of swaps if string starts with x.\"\"\"\n            ans = 0 \n            for c in s: \n                if c != x: ans += 1\n                x = \"1\" if x == \"0\" else \"0\"\n            return ans//2\n        \n        if ones > zeros: return fn(\"1\")\n        elif ones < zeros: return fn(\"0\")\n        else: return min(fn(\"0\"), fn(\"1\"))"}
{"prompt": "def rearrangeSticks(self, n: int, k: int) -> int:\n        \n        @cache \n        def fn(n, k): \n            \"\"\"Return number of ways to rearrange n sticks to that k are visible.\"\"\"\n            if n == k: return 1\n            if k == 0: return 0\n            return ((n-1)*fn(n-1, k) + fn(n-1, k-1)) % 1_000_000_007\n        \n        return fn(n, k)"}
{"prompt": "def checkZeroOnes(self, s: str) -> bool:\n        zero_in=temp=0\n        for i in s:\n            if i==\"0\":\n                temp+=1\n                if temp>zero_in:\n                    zero_in=temp\n            else:\n                temp=0\n        # Longest contiguous 0 in s is zero_in    \n        return \"1\"*(zero_in+1) in s #return boolean value"}
{"prompt": "def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\n\t\t# the speed upper is either the longest train ride: max(dist),\n\t\t# or the last train ride divide by 0.01: ceil(dist[-1] / 0.01).\n\t\t# notice: \"hour will have at most two digits after the decimal point\"\n        upper = max(max(dist), ceil(dist[-1] / 0.01))\n        # \n\t\t# the function to calcute total time consumed\n        total = lambda speed: sum(map(lambda x: ceil(x / speed), dist[:-1])) + (dist[-1] / speed)\n\t\t# the case of impossible to arrive office on time\n        if total(upper) > hour:\n            return -1\n        # \n\t\t# binary search: find the mimimal among \"all\" feasible answers\n        left, right = 1, upper\n        while left < right:            \n            mid = left + (right - left) // 2\n            if total(mid) > hour:\n                left = mid + 1 # should be larger\n            else:\n                right = mid # should explore a smaller one\n        return right"}
{"prompt": "def canReach(self, s: str, minJump: int, maxJump: int) -> bool:\n        prefix = [0, 1]\n        for i in range(1, len(s)): \n            prefix.append(prefix[-1])\n            lo = max(0, i-maxJump)\n            hi = max(0, i-minJump+1)\n            if s[i] == \"0\" and prefix[hi] - prefix[lo] > 0: prefix[-1] += 1\n        return prefix[-1] > prefix[-2]"}
{"prompt": "def stoneGameVIII(self, s: List[int]) -> int:\n        s, res = list(accumulate(s)), 0\n        for i in range(len(s) - 1, 0, -1):\n            res = s[i] if i == len(s) - 1 else max(res, s[i] - res)\n        return res"}
{"prompt": "def countGoodSubstrings(self, s: str) -> int:\n        count=0\n        for i in range(len(s)-2):\n            if(s[i]!=s[i+1] and s[i]!=s[i+2] and s[i+1]!=s[i+2]):\n                count+=1\n        return count"}
{"prompt": "def minPairSum(self, nums: List[int]) -> int:\n        pair_sum = []\n        nums.sort()\n        for i in range(len(nums)//2):\n            pair_sum.append(nums[i]+nums[len(nums)-i-1])\n        return max(pair_sum)"}
{"prompt": "def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\n    \n    def calc(l,r,u,d):\n        sc=0\n        c1=c2=(l+r)//2\n        expand=True\n        for row in range(u,d+1):\n            if c1==c2:\n                sc+=grid[row][c1]\n            else:\n                sc+=grid[row][c1]+grid[row][c2]\n            \n            if c1==l:\n                expand=False\n            \n            if expand:\n                c1-=1\n                c2+=1\n            else:\n                c1+=1\n                c2-=1\n        return sc\n        \n    \n    m=len(grid)\n    n=len(grid[0])\n    heap=[]\n    for i in range(m):\n        for j in range(n):\n            l=r=j\n            d=i\n            while l>=0 and r<=n-1 and d<=m-1:\n                sc=calc(l,r,i,d)\n                l-=1\n                r+=1\n                d+=2\n                if len(heap)<3:\n                    if sc not in heap:\n                        heapq.heappush(heap,sc)\n                else:\n                    if sc not in heap and sc>heap[0]:\n                        heapq.heappop(heap)\n                        heapq.heappush(heap,sc)\n    \n    heap.sort(reverse=True)\n    return heap"}
{"prompt": "def minimumXORSum(self, a: List[int], b: List[int]) -> int:\n        @cache\n        def dp(mask: int) -> int:\n            i = bin(mask).count(\"1\")\n            if i >= len(a):\n                return 0\n            return min((a[i] ^ b[j]) + dp(mask + (1 << j)) \n                       for j in range(len(b)) if mask &amp; (1 << j) == 0)\n        return dp(0)"}
{"prompt": "def isSumEqual(self, first: str, second: str, target: str) -> bool:\n        def op(s: str): return \"\".join(chr(ord(ch) - 49) for ch in s)\n        return int(op(first)) + int(op(second)) == int(op(target))"}
{"prompt": "def maxValue(self, n: str, x: int) -> str:\n        if int(n)>0:\n            ans = \"\"\n            flag = False\n            for i in range(len(n)):\n                if int(n[i])>=x:\n                    ans += n[i]\n                else:\n                    a = n[:i]\n                    b = n[i:]\n                    ans = a+str(x)+b\n                \n                    flag = True\n                    break\n            if not flag:\n                ans += str(x)\n        else:\n            n = n[1:]\n            ans = \"\"\n            flag = False\n            for i in range(len(n)):\n                if int(n[i])<=x:\n                    ans += n[i]\n                else:\n                    a = n[:i]\n                    b = n[i:]\n                    ans = a+str(x)+b\n            \n                    flag = True\n                    break\n            if not flag:\n                ans += str(x)\n            ans = \"-\"+ans\n        \n        return ans"}
{"prompt": "def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\n    \n    # sort the servers in order of weight, keeping index \n    server_avail = [(w,i) for i,w in enumerate(servers)]\n    heapify(server_avail)\n    tasks_in_progress = []\n    res = []\n    st=0\n    for j,task in enumerate(tasks):\n        #starting time of task\n        st = max(st,j)\n        \n        # if any server is not free then we can take start-time equal to end-time of task\n        if not server_avail:\n            st = tasks_in_progress[0][0]\n        \n        # pop the completed task's server and push inside the server avail\n        while tasks_in_progress and tasks_in_progress[0][0]<=st:\n            heapq.heappush(server_avail,heappop(tasks_in_progress)[1])\n            \n        # append index of used server in res\n        res.append(server_avail[0][1])\n        \n        # push the first available server in \"server_avail\" heap to \"tasks_in_progress\" heap\n        heapq.heappush(tasks_in_progress,(st+task,heappop(server_avail)))\n    \n    return res"}
{"prompt": "def minSkips(self, dist: List[int], speed: int, hoursBefore: int) -> int:\n        if sum(dist)/speed > hoursBefore: return -1 # impossible \n        \n        @cache\n        def fn(i, k): \n            \"\"\"Return min time (in distance) of traveling first i roads with k skips.\"\"\"\n            if k < 0: return inf # impossible \n            if i == 0: return 0 \n            return min(ceil((fn(i-1, k) + dist[i-1])/speed) * speed, dist[i-1] + fn(i-1, k-1))\n        \n        for k in range(len(dist)):\n            if fn(len(dist)-1, k) + dist[-1] <= hoursBefore*speed: return k"}
{"prompt": "@cache\n    def twoEggDrop(self, n: int) -> int:\n        return min((1 + max(i - 1, self.twoEggDrop(n - i)) for i in range (1, n)), default = 1)"}
{"prompt": "def findRotation(self, mat: List[List[int]], target: List[List[int]]) -> bool:\n        for _ in range(4): \n            if mat == target: return True\n            mat = [list(x) for x in zip(*mat[::-1])]\n        return False"}
{"prompt": "def reductionOperations(self, nums: List[int]) -> int:\n        ans = val = 0\n        nums.sort()\n        for i in range(1, len(nums)): \n            if nums[i-1] < nums[i]: val += 1\n            ans += val\n        return ans"}
{"prompt": "def minFlips(self, s: str) -> int:\n        prev = 0\n        start_1, start_0, start_1_odd, start_0_odd = 0,0,sys.maxsize,sys.maxsize\n        odd = len(s)%2\n        for val in s:\n            val = int(val)\n            if val == prev:\n                if odd:\n                    start_0_odd = min(start_0_odd, start_1)\n                    start_1_odd += 1\n                start_1 += 1\n            else:\n                if odd:\n                    start_1_odd = min(start_1_odd, start_0)\n                    start_0_odd += 1\n                start_0 += 1\n            prev = 1 - prev\n        return min([start_1, start_0, start_1_odd, start_0_odd])"}
{"prompt": "def minWastedSpace(self, packages: List[int], boxes: List[List[int]]) -> int:\n        packages.sort()\n        prefix = [0]\n        for x in packages: prefix.append(prefix[-1] + x)\n        \n        ans = inf \n        for box in boxes: \n            box.sort()\n            if packages[-1] <= box[-1]: \n                kk = val = 0 \n                for x in box: \n                    k = bisect_right(packages, x)\n                    val += (k - kk) * x - (prefix[k] - prefix[kk])\n                    kk = k\n                ans = min(ans, val)\n        return ans % 1_000_000_007 if ans < inf else -1"}
{"prompt": "def isCovered(self, ranges: List[List[int]], left: int, right: int) -> bool:\n        ranges = sorted(ranges)\n        for s,e in ranges:\n            if  s<=left<=e:\n                if s<=right<=e:\n                    return True\n                else:\n                    left=e+1\n        return False"}
{"prompt": "def chalkReplacer(self, chalk: List[int], k: int) -> int:\n        prefix_sum = [0 for i in range(len(chalk))]\n        prefix_sum[0] = chalk[0]\n        for i in range(1,len(chalk)):\n            prefix_sum[i] = prefix_sum[i-1] + chalk[i]\n        remainder = k % prefix_sum[-1]\n        \n        #apply binary search on prefix_sum array, target = remainder \n        start = 0\n        end = len(prefix_sum) - 1\n        while start <= end:\n            mid = start + (end - start) // 2\n            if remainder == prefix_sum[mid]:\n                return mid + 1\n            elif remainder < prefix_sum[mid]:\n                end = mid - 1\n            else:\n                start = mid + 1\n        return start"}
{"prompt": "def largestMagicSquare(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0]) # dimensions \n        rows = [[0]*(n+1) for _ in range(m)] # prefix sum along row\n        cols = [[0]*n for _ in range(m+1)] # prefix sum along column\n        \n        for i in range(m):\n            for j in range(n): \n                rows[i][j+1] = grid[i][j] + rows[i][j]\n                cols[i+1][j] = grid[i][j] + cols[i][j]\n        \n        ans = 1\n        for i in range(m): \n            for j in range(n): \n                diag = grid[i][j]\n                for k in range(min(i, j)): \n                    ii, jj = i-k-1, j-k-1\n                    diag += grid[ii][jj]\n                    ss = {diag}\n                    for r in range(ii, i+1): ss.add(rows[r][j+1] - rows[r][jj])\n                    for c in range(jj, j+1): ss.add(cols[i+1][c] - cols[ii][c])\n                    ss.add(sum(grid[ii+kk][j-kk] for kk in range(k+2))) # anti-diagonal\n                    if len(ss) == 1: ans = max(ans, k+2)\n        return ans"}
{"prompt": "def minOperationsToFlip(self, expression: str) -> int:\n        loc = {}\n        stack = []\n        for i in reversed(range(len(expression))):\n            if expression[i] == \")\": stack.append(i)\n            elif expression[i] == \"(\": loc[stack.pop()] = i \n        \n        def fn(lo, hi): \n            \"\"\"Return value and min op to change value.\"\"\"\n            if lo == hi: return int(expression[lo]), 1\n            if expression[hi] == \")\" and loc[hi] == lo: return fn(lo+1, hi-1) # strip parenthesis \n            mid = loc.get(hi, hi) - 1 \n            v, c = fn(mid+1, hi)\n            vv, cc = fn(lo, mid-1)\n            if expression[mid] == \"|\": \n                val = v | vv \n                if v == vv == 0: chg = min(c, cc)\n                elif v == vv == 1: chg = 1 + min(c, cc)\n                else: chg = 1 \n            else: # expression[k] == \"&amp;\"\n                val = v &amp; vv\n                if v == vv == 0: chg = 1 + min(c, cc)\n                elif v == vv == 1: chg = min(c, cc)\n                else: chg = 1\n            return val, chg\n                    \n        return fn(0, len(expression)-1)[1]"}
{"prompt": "def makeEqual(self, words: List[str]) -> bool:\n        map_ = {}\n        for word in words:\n            for i in word:\n                if i not in map_:\n                    map_[i] = 1\n                else:\n                    map_[i] += 1\n        n = len(words)\n        for k,v in map_.items():\n            if (v%n) != 0:\n                return False\n        return True"}
{"prompt": "def maximumRemovals(self, s: str, p: str, removable: List[int]) -> int:\n        mp = {x: i for i, x in enumerate(removable)}\n        \n        def fn(x):\n            \"\"\"Return True if p is a subseq of s after x removals.\"\"\"\n            k = 0 \n            for i, ch in enumerate(s): \n                if mp.get(i, inf) < x: continue \n                if k < len(p) and ch == p[k]: k += 1\n            return k == len(p)\n        \n        lo, hi = -1, len(removable)\n        while lo < hi: \n            mid = lo + hi + 1 >> 1\n            if fn(mid): lo = mid\n            else: hi = mid - 1\n        return lo"}
{"prompt": "def mergeTriplets(self, triplets: List[List[int]], target: List[int]) -> bool:\n        i = 1\n        cur = []\n        for a,b,c in triplets:\n            if a<=target[0] and b<=target[1] and c<= target[2]:\n                cur = [a,b,c]\n                break\n        if not cur:\n            return False\n        while i<len(triplets):\n            if cur == target:\n                return True\n            a,b,c = triplets[i]\n            x,y,z = cur\n            if max(a,x)<=target[0] and max(b,y)<=target[1] and max(c,z)<=target[2]:\n                cur = [max(a,x), max(b,y), max(c,z)]\n               \n            \n            i+= 1\n        if cur == target:\n            return True\n        return False"}
{"prompt": "def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:\n        firstPlayer, secondPlayer = firstPlayer-1, secondPlayer-1 # 0-indexed\n        \n        @cache\n        def fn(k, mask): \n            \"\"\"Return earliest and latest rounds.\"\"\"\n            can = deque()\n            for i in range(n): \n                if mask &amp; (1 << i): can.append(i)\n                    \n            cand = [] # eliminated player\n            while len(can) > 1: \n                p1, p2 = can.popleft(), can.pop()\n                if p1 == firstPlayer and p2 == secondPlayer or p1 == secondPlayer and p2 == firstPlayer: return [k, k] # game of interest \n                if p1 in (firstPlayer, secondPlayer): cand.append([p2]) # p2 eliminated \n                elif p2 in (firstPlayer, secondPlayer): cand.append([p1]) # p1 eliminated \n                else: cand.append([p1, p2]) # both could be elimited \n            \n            minn, maxx = inf, -inf\n            for x in product(*cand): \n                mask0 = mask\n                for i in x: mask0 ^= 1 << i\n                mn, mx = fn(k+1, mask0)\n                minn = min(minn, mn)\n                maxx = max(maxx, mx)\n            return minn, maxx\n        \n        return fn(1, (1<<n)-1)"}
{"prompt": "def findPeakGrid(self, mat: List[List[int]]) -> List[int]:\n        m, n = len(mat), len(mat[0])\n        l, r = 0, n\n        while l <= r:\n            mid = (l + r) // 2\n            cur_max, left = 0, False\n            for i in range(m):\n                if i > 0 and mat[i-1][mid] >= mat[i][mid]:\n                    continue\n                if i+1 < m and mat[i+1][mid] >= mat[i][mid]:   \n                    continue\n                if mid+1 < n and mat[i][mid+1] >= mat[i][mid]:   \n                    cur_max, left = mat[i][mid], not mat[i][mid] > cur_max\n                    continue\n                if mid > 0 and mat[i][mid-1] >= mat[i][mid]:   \n                    cur_max, left = mat[i][mid], mat[i][mid] > cur_max\n                    continue\n                return [i, mid]\n            if left:\n                r = mid-1\n            else:\n                l = mid+1\n        return []"}
{"prompt": "def largestOddNumber(self, num: str) -> str:\n        \n        for i in range(len(num) - 1, -1, -1) :\n            if num[i] in {'1','3','5','7','9'} :\n                return num[:i+1]\n        return ''"}
{"prompt": "def numberOfRounds(self, startTime: str, finishTime: str) -> int:\n        hs, ms = (int(x) for x in startTime.split(\":\"))\n        ts = 60 * hs + ms\n        hf, mf = (int(x) for x in finishTime.split(\":\"))\n        tf = 60 * hf + mf\n        if 0 <= tf - ts < 15: return 0 # edge case \n        return tf//15 - (ts+14)//15 + (ts>tf)*96"}
{"prompt": "def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\n    \n    m=len(grid1)\n    n=len(grid1[0])\n    \n    def dfs(i,j):\n        if i<0 or i>=m or j<0 or j>=n or grid2[i][j]==0:\n            return\n        \n        grid2[i][j]=0\n        dfs(i+1,j)\n        dfs(i,j+1)\n        dfs(i,j-1)\n        dfs(i-1,j)\n        \n    # removing all the non-common sub-islands\n    for i in range(m):\n        for j in range(n):\n            if grid2[i][j]==1 and grid1[i][j]==0:\n                dfs(i,j)\n    \n    c=0\n\t# counting sub-islands\n    for i in range(m):\n        for j in range(n):\n            if grid2[i][j]==1:\n                dfs(i,j)\n                c+=1\n    return c"}
{"prompt": "def minDifference(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        loc = {}\n        for i, x in enumerate(nums): loc.setdefault(x, []).append(i)\n        keys = sorted(loc)\n        \n        ans = []\n        for l, r in queries: \n            prev, val = 0, inf\n            for x in keys: \n                i = bisect_left(loc[x], l)\n                if i < len(loc[x]) and loc[x][i] <= r: \n                    if prev: val = min(val, x - prev)\n                    prev = x \n            ans.append(val if val < inf else -1)\n        return ans"}
{"prompt": "def canBeIncreasing(self, nums: List[int]) -> bool:\n        stack = []\n        for i in range(1, len(nums)): \n            if nums[i-1] >= nums[i]: stack.append(i)\n                \n        if not stack: return True \n        if len(stack) > 1: return False\n        i = stack[0]\n        return (i == 1 or nums[i-2] < nums[i]) or (i+1 == len(nums) or nums[i-1] < nums[i+1])"}
{"prompt": "def removeOccurrences(self, s: str, part: str) -> str:\n        lps = [0]\n        k = 0 \n        for i in range(1, len(part)): \n            while k and part[k] != part[i]: k = lps[k-1]\n            if part[k] == part[i]: k += 1\n            lps.append(k)\n        \n        stack = [(\"\", 0)]\n        for ch in s: \n            k = stack[-1][1]\n            while k and part[k] != ch: k = lps[k-1]\n            if part[k] == ch: k += 1\n            stack.append((ch, k))\n            if k == len(part): \n                for _ in range(len(part)): stack.pop()\n        return \"\".join(x for x, _ in stack)"}
{"prompt": "def maxAlternatingSum(self, nums: List[int]) -> int:\n    \n    ma=0\n    mi=0\n    for num in nums:\n        ma=max(ma,num-mi)\n        mi=min(mi,num-ma)\n        \n    return ma"}
{"prompt": "def maxProductDifference(self, nums: List[int]) -> int:\n        nums.sort()\n        return (nums[-1]*nums[-2])-(nums[0]*nums[1])"}
{"prompt": "def rotateGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\n        m, n = len(grid), len(grid[0]) # dimensions \n        \n        for r in range(min(m, n)//2): \n            i = j = r\n            vals = []\n            for jj in range(j, n-j-1):     vals.append(grid[i][jj])\n            for ii in range(i, m-i-1):     vals.append(grid[ii][n-j-1])\n            for jj in range(n-j-1, j, -1): vals.append(grid[m-i-1][jj])\n            for ii in range(m-i-1, i, -1): vals.append(grid[ii][j])\n                \n            kk = k % len(vals)\n            vals = vals[kk:] + vals[:kk]\n            \n            x = 0  \n            for jj in range(j, n-j-1):     grid[i][jj] = vals[x]; x += 1\n            for ii in range(i, m-i-1):     grid[ii][n-j-1] = vals[x]; x += 1\n            for jj in range(n-j-1, j, -1): grid[m-i-1][jj] = vals[x]; x += 1\n            for ii in range(m-i-1, i, -1): grid[ii][j] = vals[x]; x += 1\n        return grid"}
{"prompt": "def wonderfulSubstrings(self, word: str) -> int:\n        ans = mask = 0\n        freq = defaultdict(int, {0: 1})\n        for ch in word: \n            mask ^= 1 << ord(ch)-97\n            ans += freq[mask]\n            for i in range(10): ans += freq[mask ^ 1 << i]\n            freq[mask] += 1\n        return ans"}
{"prompt": "def waysToBuildRooms(self, prevRoom: List[int]) -> int:\n        tree = defaultdict(list)\n        for i, x in enumerate(prevRoom): tree[x].append(i)\n        \n        def fn(n): \n            \"\"\"Return number of nodes and ways to build sub-tree.\"\"\"\n            if not tree[n]: return 1, 1 # leaf \n            c, m = 0, 1\n            for nn in tree[n]: \n                cc, mm = fn(nn)\n                c += cc\n                m = (m * comb(c, cc) * mm) % 1_000_000_007\n            return c+1, m\n        \n        return fn(0)[1]"}
{"prompt": "def buildArray(self, nums: List[int]) -> List[int]:\n        return [nums[nums[i]] for i in range(len(nums))]"}
{"prompt": "def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\n        for i, t in enumerate(sorted((d+s-1)//s for d, s in zip(dist, speed))): \n            if i == t: return i\n        return len(dist)"}
{"prompt": "def countGoodNumbers(self, n: int) -> int:\n        '''\n        ans=1\n        MOD=int(10**9+7)\n        for i in range(n):\n            if i%2==0:\n                ans*=5\n            else:\n                ans*=4\n            ans%=MOD\n        return ans\n        '''\n        MOD=int(10**9+7)\n\n        fives,fours=n//2+n%2,n//2\n        # 5^fives*4^fours % MOD\n        # = 5^fives % MOD * 4^fours % MOD\n        return (pow(5,fives,MOD) * pow(4,fours,MOD)) % MOD"}
{"prompt": "```def countTriples(self, n: int) -> int:\n        count = 0\n        sqrt = 0\n        for i in range(1,n-1):\n            for j in range(i+1, n):\n                sqrt = ((i*i) + (j*j)) ** 0.5\n                if sqrt % 1 == 0 and sqrt <= n:\n                    count += 2\n        return (count)\n\t\t\n\n*Please Upvote if you like*"}
{"prompt": "def nearestExit(self, maze: List[List[str]], entrance: List[int]) -> int:\n        q = collections.deque([(*entrance, 0)])\n        m, n = len(maze), len(maze[0])\n        maze[entrance[0]][entrance[1]] == '+'    \n        while q:\n            x, y, c = q.popleft()\n            if (x == 0 or x == m-1 or y == 0 or y == n-1) and [x, y] != entrance:\n                return c\n            for i, j in [(x+_x, y+_y) for _x, _y in [(-1, 0), (1, 0), (0, -1), (0, 1)]]:\n                if 0 <= i < m and 0 <= j < n and maze[i][j] == '.':\n                    maze[i][j] = '+'\n                    q.append((i, j, c + 1))\n        return -1"}
{"prompt": "def sumGame(self, num: str) -> bool:\n        n = len(num)\n        q_cnt_1 = s1 = 0\n        for i in range(n//2):    # get digit sum and question mark count for the first half of `num`\n            if num[i] == '?':\n                q_cnt_1 += 1\n            else:    \n                s1 += int(num[i])\n        q_cnt_2 = s2 = 0\t\t\t\t\n        for i in range(n//2, n): # get digit sum and question mark count for the second half of `num`\n            if num[i] == '?':\n                q_cnt_2 += 1\n            else:    \n                s2 += int(num[i])\n        s_diff = s1 - s2         # calculate sum difference and question mark difference\n        q_diff = q_cnt_2 - q_cnt_1\n        return not (q_diff % 2 == 0 and q_diff // 2 * 9 == s_diff) # When Bob can't win, Alice wins"}
{"prompt": "def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\n        n = len(passingFees)\n        mat = {}\n        for x, y, time in edges:\n            if x not in mat: mat[x] = set()\n            if y not in mat: mat[y] = set()\n            mat[x].add((y, time))\n            mat[y].add((x, time))\n\n        h = [(passingFees[0], 0, 0)]\n        visited = set()\n        while h:\n            fees, time_so_far, city = heappop(h)\n            if time_so_far > maxTime: continue\n            if city == n - 1: return fees\n\n            if (city, time_so_far) in visited: continue\n            visited.add((city, time_so_far))\n            \n            for nxt, time_to_travel in mat[city]:\n                # Check if we are retracing a visited path\n                if (nxt, time_so_far - time_to_travel) in visited: continue\n                heappush(h, (fees + passingFees[nxt], time_so_far + time_to_travel, nxt))\n        return -1"}
{"prompt": "def getConcatenation(self, nums: List[int]) -> List[int]:\n        nums.extend(nums)\n        return nums"}
{"prompt": "def countPalindromicSubsequence(self, s):\n        d=defaultdict(list)\n        for i,c in enumerate(s):\n            d[c].append(i)\n        ans=0\n        for el in d:\n            if len(d[el])<2:\n                continue\n            a=d[el][0]\n            b=d[el][-1]\n            ans+=len(set(s[a+1:b]))\n        return(ans)"}
{"prompt": "def colorTheGrid(self, m: int, n: int) -> int:\n        \n        @cache\n        def fn(i, j, mask): \n            \"\"\"Return number of ways to color grid.\"\"\"\n            if j == n: return 1 \n            if i == m: return fn(0, j+1, mask)\n            ans = 0 \n            for x in 1<<2*i, 1<<2*i+1, 0b11<<2*i: \n                mask0 = mask ^ x\n                if mask0 &amp; 0b11<<2*i and (i == 0 or (mask0 >> 2*i) &amp; 0b11 != (mask0 >> 2*i-2) &amp; 0b11): \n                    ans += fn(i+1, j, mask0)\n            return ans % 1_000_000_007\n        \n        return fn(0, 0, 0)"}
{"prompt": "def canMerge(self, trees: List[TreeNode]) -> TreeNode:\n        roots, leaves, loners, n = {}, {}, set(), len(trees)\n        if n == 1:\n            return trees[0]\n        for tree in trees:\n            if not tree.left and not tree.right:\n                loners.add(tree.val)\n                continue\n            roots[tree.val] = tree\n            for node in [tree.left, tree.right]:\n                if node:\n                    if node.val in leaves:\n                        return None\n                    leaves[node.val] = node\n                \n        for loner in loners:\n            if loner not in leaves and loner not in roots:\n                return None\n            \n        orphan = None\n        for val, tree in roots.items():\n            if val not in leaves:\n                if orphan:\n                    return None\n                orphan = tree\n        if not orphan:\n            return None\n        \n        def build(node, small, big):\n            nonlocal roots\n            if not node:\n                return True\n            if small >= node.val or node.val >= big:\n                return False\n            \n            if node.val in roots:\n                node.left, node.right = roots[node.val].left, roots[node.val].right\n                del roots[node.val]\n            return build(node.left, small, node.val) and build(node.right, node.val, big)\n        del roots[orphan.val]\n        result = build(orphan.left, -inf, orphan.val) and build(orphan.right, orphan.val, inf)\n        return orphan if result and not roots.keys() else None"}
{"prompt": "def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\n        text = text.split()\n        length = len(text)\n        brokenLetters = set(brokenLetters)\n\n        for word in text:\n            for char in word:\n                if char in brokenLetters:\n                    length -= 1\n                    break\n\t\t\t\t\t\n        return length"}
{"prompt": "def addRungs(self, rungs: List[int], dist: int) -> int:\n        return sum((a - b - 1) // dist for a, b in zip(rungs, [0] + rungs))"}
{"prompt": "def maxPoints(self, points: List[List[int]]) -> int:\n        m, n = len(points), len(points[0])\n        \n        dp = points[0]\n        \n        left = [0] * n ## left side contribution\n        right = [0] * n ## right side contribution\n        \n        for r in range(1, m):\n            for c in range(n):\n                if c == 0:\n                    left[c] = dp[c]\n                else:\n                    left[c] = max(left[c - 1] - 1, dp[c])\n            \n            for c in range(n - 1, -1, -1):\n                if c == n-1:\n                    right[c] = dp[c]\n                else:\n                    right[c] = max(right[c + 1] - 1, dp[c])\n                    \n            for c in range(n):\n                dp[c] = points[r][c] + max(left[c], right[c])\n                \n        return max(dp)"}
{"prompt": "def areOccurrencesEqual(self, s: str) -> bool:\n        return len(set(Counter(s).values())) == 1"}
{"prompt": "def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\n        arrivals = []\n        departures = []\n        for ind, (x, y) in enumerate(times):\n            heappush(arrivals, (x, ind))\n            heappush(departures, (y, ind))\n        d = {}\n        occupied = [0] * len(times)\n        while True:\n            if arrivals and departures and arrivals[0][0] < departures[0][0]:\n                _, ind = heappop(arrivals)\n                d[ind] = occupied.index(0)\n                occupied[d[ind]] = 1\n                if ind == targetFriend:\n                    return d[ind]\n            elif arrivals and departures and arrivals[0][0] >= departures[0][0]:\n                _, ind = heappop(departures)\n                occupied[d[ind]] = 0"}
{"prompt": "def splitPainting(self, segments: List[List[int]]) -> List[List[int]]:\n\t\t# via this mapping, we can easily know which coordinates should be took into consideration.\n        mapping = defaultdict(int)\n        for s, e, c in segments:\n            mapping[s] += c\n            mapping[e] -= c\n        \n        res = []\n        prev, color = None, 0\n        for now in sorted(mapping):\n            if color: # if color == 0, it means this part isn't painted.\n                res.append((prev, now, color))\n            \n            color += mapping[now]\n            prev = now\n            \n        return res"}
{"prompt": "def canSeePersonsCount(self, heights: List[int]) -> List[int]:\n        ans = [0]*len(heights)\n        stack = [] # mono-stack \n        for i in reversed(range(len(heights))): \n            while stack and stack[-1] <= heights[i]: \n                ans[i] += 1\n                stack.pop()\n            if stack: ans[i] += 1\n            stack.append(heights[i])\n        return ans"}
{"prompt": "def getLucky(self, s: str, k: int) -> int:\n        s = \"\".join(str(ord(ch) - 96) for ch in s)\n        for _ in range(k): \n            x = sum(int(ch) for ch in s)\n            s = str(x)\n        return x"}
{"prompt": "def maximumNumber(self, num: str, change: List[int]) -> str:\n        num = list(num)\n        on = False \n        for i, ch in enumerate(num): \n            x = int(ch)\n            if x < change[x]: \n                on = True\n                num[i] = str(change[x])\n            elif x > change[x] and on: break\n        return \"\".join(num)"}
{"prompt": "def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\n        m = len(students)\n        \n        score = [[0]*m for _ in range(m)]\n        for i in range(m): \n            for j in range(m): \n                score[i][j] = sum(x == y for x, y in zip(students[i], mentors[j]))\n        \n        ans = 0 \n        for perm in permutations(range(m)): \n            ans = max(ans, sum(score[i][j] for i, j in zip(perm, range(m))))\n        return ans"}
{"prompt": "def deleteDuplicateFolder(self, paths: List[List[str]]) -> List[List[str]]:\n        paths.sort()\n        \n        tree = {\"#\": -1}\n        for i, path in enumerate(paths): \n            node = tree\n            for x in path: node = node.setdefault(x, {})\n            node[\"#\"] = i\n        \n        seen = {}\n        mark = set()\n        \n        def fn(n): \n            \"\"\"Return serialized value of sub-tree rooted at n.\"\"\"\n            if len(n) == 1: return \"$\" # leaf node \n            vals = []\n            for k in n: \n                if k != \"#\": vals.append(f\"${k}${fn(n[k])}\")\n            hs = \"\".join(vals)\n            if hs in seen: \n                mark.add(n[\"#\"])\n                mark.add(seen[hs])\n            if hs != \"$\": seen[hs] = n[\"#\"]\n            return hs\n        \n        fn(tree)\n        \n        ans = []\n        stack = [tree]\n        while stack: \n            n = stack.pop()\n            if n[\"#\"] >= 0: ans.append(paths[n[\"#\"]])\n            for k in n: \n                if k != \"#\" and n[k][\"#\"] not in mark: stack.append(n[k])\n        return ans"}
{"prompt": "def isThree(self, n: int) -> bool:\n        return sum(n%i == 0 for i in range(1, n+1)) == 3"}
{"prompt": "def numberOfWeeks(self, milestones: List[int]) -> int:\n        _sum, _max = sum(milestones), max(milestones)\n\t\t# (_sum - _max) is the sum of milestones from (2) the rest of projects, if True, we can form another project with the same amount of milestones as (1)\n\t\t# can refer to the section `Why the greedy strategy works?` for the proof\n        if _sum - _max >= _max:  \n            return _sum\n        return 2 * (_sum - _max) + 1  # start from the project with most milestones (_sum - _max + 1) and work on the the rest of milestones (_sum - _max)"}
{"prompt": "def minimumPerimeter(self, nap: int) -> int:\n        \n        \n#         here for n = 2 , there are two series :  \n#         (1) Diagnal points for n=3 , diagnal apples = 2*n = 6\n#         (2) there is series =   2,3,3 =  2+ (sigma(3)-sigma(2))*2\n        \n#         how to solve:\n            \n#             here 3  =  sigma(n+(n-1))-sigma(n) = sigma(2*n-1)-sigma(n) =  0.5*2n*(2n-1)-0.5*n*n-1\n#         (3) so our final 2,3,3 =   3*2+2 =   (0.5*2n*(2n-1)-0.5*n*n-1)*2+n\n#         (4) so final 2,3,3 =  3*n*n - 2*n\n#         (5) we have 4 times repitation of (2,3,3)  = 4*(2,3,3)  =   4*(3*n*n - 2*n)   =  12*n*n - 8*n\n#         (6) we have 4 diagnal points so their sum(4 diagnal)  = 4*(2*n)\n#         (7)  so final sum(total) = 4 diagnal sum + 4(2,3,3)    =   4(2*n)   + 12*n*n - 8*n    =  12*n*n\n        \n#         so at nth distance we have total  12*n*n  apples at the circumfrance\n        \n#         so net sum =  sigma(12*n*n)  = 2*n*(n+1)*(2*n+1)\n        \n        \n        n=1\n        val=2*n*(n+1)*(2*n+1)\n        while(val<nap):\n            n+=1\n            val=val=2*n*(n+1)*(2*n+1)\n        return n*8"}
{"prompt": "def countSpecialSubsequences(self, nums: List[int]) -> int:\n        total_zeros = 0 # number of subsequences of 0s so far\n        total_ones = 0 # the number of subsequences of 0s followed by 1s so far\n        total_twos = 0 # the number of special subsequences so far\n        \n        M = 1000000007\n        \n        for n in nums:\n            if n == 0:\n                # if we have found new 0 we can add it to any existing subsequence of 0s\n                # or use only this 0\n                total_zeros += (total_zeros + 1) % M\n            elif n == 1:\n                # if we have found new 1 we can add it to any existing subsequence of 0s or 0s and 1s\n                # to get a valid subsequence of 0s and 1s\n                total_ones += (total_zeros + total_ones) % M\n            else:\n                # if we have found new 2 we can add it to any existing subsequence of 0s and 1s 0r 0s,1s and 2s\n                # to get a valid subsequence of 0s,1s and 2s\n                total_twos += (total_ones + total_twos) % M\n        \n        return total_twos % M"}
{"prompt": "def makeFancyString(self, s: str) -> str:\n        stack = []\n        for letter in s:\n            if len(stack) > 1 and letter == stack[-1] == stack[-2]:\n                stack.pop()\n            stack.append(letter)\n        return ''.join(stack)"}
{"prompt": "def checkMove(self, board: List[List[str]], rMove: int, cMove: int, color: str) -> bool:\n        for di, dj in (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1): \n            i, j = rMove+di, cMove+dj\n            step = 0\n            while 0 <= i < 8 and 0 <= j < 8: \n                if board[i][j] == color and step: return True \n                if board[i][j] == \".\" or board[i][j] == color and not step: break \n                i, j = i+di, j+dj\n                step += 1\n        return False"}
{"prompt": "def minSpaceWastedKResizing(self, nums: List[int], k: int) -> int:\n        \n        @cache\n        def fn(i, k): \n            \"\"\"Return min waste from i with k ops.\"\"\"\n            if i == len(nums): return 0\n            if k < 0: return inf \n            ans = inf\n            rmx = rsm = 0\n            for j in range(i, len(nums)): \n                rmx = max(rmx, nums[j])\n                rsm += nums[j]\n                ans = min(ans, rmx*(j-i+1) - rsm + fn(j+1, k-1))\n            return ans \n        \n        return fn(0, k)"}
{"prompt": "def maxProduct(self, s: str) -> int:\n        n = len(s)\n        \n        # Manacher's algo\n        hlen = [0]*n # half-length\n        center = right = 0 \n        for i in range(n): \n            if i < right: hlen[i] = min(right - i, hlen[2*center - i])\n            while 0 <= i-1-hlen[i] and i+1+hlen[i] < len(s) and s[i-1-hlen[i]] == s[i+1+hlen[i]]: \n                hlen[i] += 1\n            if right < i+hlen[i]: center, right = i, i+hlen[i]\n        \n        prefix = [0]*n\n        suffix = [0]*n\n        for i in range(n): \n            prefix[i+hlen[i]] = max(prefix[i+hlen[i]], 2*hlen[i]+1)\n            suffix[i-hlen[i]] = max(suffix[i-hlen[i]], 2*hlen[i]+1)\n        \n        for i in range(1, n): \n            prefix[~i] = max(prefix[~i], prefix[~i+1]-2)\n            suffix[i] = max(suffix[i], suffix[i-1]-2)\n        \n        for i in range(1, n): \n            prefix[i] = max(prefix[i-1], prefix[i])\n            suffix[~i] = max(suffix[~i], suffix[~i+1])\n        \n        return max(prefix[i-1]*suffix[i] for i in range(1, n))"}
{"prompt": "def isPrefixString(self, s: str, words: List[str]) -> bool:\n        i = 0\n        for word in words: \n            if s[i:i+len(word)] != word: return False \n            i += len(word)\n            if i == len(s): return True \n        return False"}
{"prompt": "def minStoneSum(self, piles: List[int], k: int) -> int:\n        pq = [-x for x in piles]\n        heapify(pq)\n        for _ in range(k): heapreplace(pq, pq[0]//2)\n        return -sum(pq)"}
{"prompt": "def minSwaps(self, s: str) -> int:\n        res, bal = 0, 0\n        for ch in s:\n            bal += 1 if ch == '[' else -1\n            if bal == -1:\n                res += 1\n                bal = 1\n        return res"}
{"prompt": "def longestObstacleCourseAtEachPosition(self, obs: List[int]) -> List[int]:\n    local = []\n    res=[0 for _ in range(len(obs))]\n    for i in range(len(obs)):\n        n=obs[i]\n        if len(local)==0 or local[-1]<=n:\n            local.append(n)\n            res[i]=len(local)\n        else:\n            ind = bisect.bisect_right(local,n)\n            local[ind]=n\n            res[i]=ind+1\n    \n    return res"}
{"prompt": "def numOfStrings(self, patterns: List[str], word: str) -> int:\n        return sum(x in word for x in patterns)"}
{"prompt": "def rearrangeArray(self, nums: List[int]) -> List[int]:\n        nums.sort()\n        if len(nums)==3:\n            nums[1],nums[0] = nums[0],nums[1]\n            return nums\n        for i in range(1,len(nums)-1):\n            if nums[i]-nums[i-1] == nums[i+1]-nums[i]:\n                if i!=len(nums)-2:\n                    nums[i+1],nums[i+2] = nums[i+2],nums[i+1] \n                if i==len(nums)-2:\n                    nums[i+1],nums[0] = nums[0],nums[i+1]\n        return nums"}
{"prompt": "def minNonZeroProduct(self, p: int) -> int:\n        x = (1 << p) - 1\n        return pow(x-1, (x-1)//2, 1_000_000_007) * x % 1_000_000_007"}
{"prompt": "def latestDayToCross(self, row, col, cells):\n        l,h=0,len(cells)-1\n        ans=-1\n        while l<=h:\n            m=(l+h)>>1\n            if self.isPath(cells,m,row,col):\n                l=m+1\n                ans=m+1\n            else:\n                h=m-1\n        return ans\n    def isPath(self,cells,ind,row,col):\n        grid=[[0 for i in range(col)] for j in range(row)]\n        for i in range(ind+1):\n            x,y=cells[i]\n            grid[x-1][y-1]=1\n        vis=set()\n        for i in range(col):\n            if grid[0][i]!=1:\n                dq=deque()\n                dq.append((0,i))\n                dr=[(-1,0),(0,-1),(1,0),(0,1)]\n                while dq:\n                    x,y=dq.popleft()\n                    if x==row-1:\n                        return True\n                    for d in dr:\n                        dx,dy=d\n                        if 0<=x+dx<row and 0<=y+dy<col and grid[x+dx][y+dy]!=1 and (x+dx,y+dy) not in vis:\n                            vis.add((x+dx,y+dy))\n                            dq.append((x+dx,y+dy))\n        return False"}
{"prompt": "def validPath(self, n, edges, start, end):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type start: int\n        :type end: int\n        :rtype: bool\n        \"\"\"\n        visited = [False]*n\n        d = {}\n\t\t#store the undirected edges for both vertices\n        for i in edges:\n            if i[0] in d:\n                d[i[0]].append(i[1])\n            else:\n                d[i[0]] = [i[1]]\n                \n            if i[1] in d:\n                d[i[1]].append(i[0])\n            else:\n                d[i[1]] = [i[0]]\n        #create a queue as we will apply BFS\n        q = [start]\n        while q:\n            curr = q.pop(0)  #pop the first element as we do in queue\n            if curr == end:  #if its the end then we can return True\n                return True\n            elif curr in d and not visited[curr]: #else if it is not the end then check whether its visited or not\n                q.extend(d[curr])  #add the adjacent vertices of the current node to the queue\n            visited[curr] = True  #mark this curr vertex as visited = True, so that we dont visit this vertex again\n        return False  #return False if the queue gets empty and we dont reach the end"}
{"prompt": "def minTimeToType(self, word: str) -> int:\n        ans = len(word)\n        prev = \"a\"\n        for ch in word: \n            val = (ord(ch) - ord(prev)) % 26 \n            ans += min(val, 26 - val)\n            prev = ch\n        return ans"}
{"prompt": "def maxMatrixSum(self, matrix: List[List[int]]) -> int:\n        ans = mult = 0\n        val = inf \n        for i in range(len(matrix)): \n            for j in range(len(matrix)):\n                ans += abs(matrix[i][j])\n                val = min(val, abs(matrix[i][j]))\n                if matrix[i][j] < 0: mult ^= 1\n        return ans - 2*mult*val"}
{"prompt": "def countPaths(self, n: int, roads: List[List[int]]) -> int:\n        graph = {}\n        for u, v, time in roads: \n            graph.setdefault(u, {})[v] = time\n            graph.setdefault(v, {})[u] = time\n            \n        dist = [inf]*n\n        dist[-1] = 0\n        stack = [(n-1, 0)]\n        while stack: \n            x, t = stack.pop()\n            if t == dist[x]: \n                for xx in graph.get(x, {}): \n                    if t + graph[x][xx] < dist[xx]: \n                        dist[xx] = t + graph[x][xx]\n                        stack.append((xx, t + graph[x][xx]))\n                        \n        @cache\n        def fn(x):\n            \"\"\"Return \"\"\"\n            if x == n-1: return 1 \n            if dist[x] == inf: return 0 \n            ans = 0 \n            for xx in graph.get(x, {}): \n                if graph[x][xx] + dist[xx] == dist[x]: ans += fn(xx)\n            return ans % 1_000_000_007\n        \n        return fn(0)"}
{"prompt": "def numberOfCombinations(self, num: str) -> int:\n        n = len(num)\n        lcs = [[0]*(n+1) for _ in range(n)]\n        for i in reversed(range(n)): \n            for j in reversed(range(i+1, n)): \n                if num[i] == num[j]: lcs[i][j] = 1 + lcs[i+1][j+1]\n        \n        def cmp(i, j, d): \n            \"\"\"Return True if \"\"\"\n            m = lcs[i][j]\n            if m >= d: return True \n            return num[i+m] <= num[j+m]\n        \n        dp = [[0]*(n+1) for _ in range(n)]\n        for i in range(n): \n            if num[i] != \"0\": \n                for j in range(i+1, n+1): \n                    if i == 0: dp[i][j] = 1\n                    else: \n                        dp[i][j] = dp[i][j-1]\n                        if 2*i-j >= 0 and cmp(2*i-j, i, j-i): dp[i][j] += dp[2*i-j][i]\n                        if 2*i-j+1 >= 0 and not cmp(2*i-j+1, i, j-i-1): dp[i][j] += dp[2*i-j+1][i]\n        return sum(dp[i][n] for i in range(n)) % 1_000_000_007"}
{"prompt": "def findGCD(self, nums: List[int]) -> int:\n        gcd = lambda a, b: a if b == 0 else gcd(b, a % b)\n        return gcd(max(nums), min(nums))"}
{"prompt": "def findDifferentBinaryString(self, nums: List[str]) -> str:\n        return list(set(list((map(lambda x:\"\".join(list(map(str,x))),list(itertools.product([0,1],repeat=len(nums)))))))-set(nums))[0]"}
{"prompt": "def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\n        \n        # store the mxn size of the matrix\n        m = len(mat)\n        n = len(mat[0])\n        \n        dp = defaultdict(defaultdict)\n        \n        # Sorting each row of the array for more efficient pruning\n        # Note:this purely based on the observation on problem constraints (although interesting :))\n        for i in range(m):\n            mat[i] = sorted(mat[i])\n        \n        # returns minimum absolute starting from from row i to n-1 for the target\n        globalMin = float(\"inf\")\n        def findMinAbsDiff(i,prevSum):\n            nonlocal globalMin\n            if i == m:\n                globalMin = min(globalMin, abs(prevSum-target))\n                return abs(prevSum-target)\n            \n            # pruning step 1\n            # because the array is increasing &amp; prevSum &amp; target will always be positive\n            if prevSum-target > globalMin:\n                return float(\"inf\")\n            \n            \n            if (i in dp) and (prevSum in dp[i]):\n                return dp[i][prevSum]\n            \n            minDiff = float(\"inf\")\n            # for each candidate select that and backtrack\n            for j in range(n):\n                diff = findMinAbsDiff(i+1, prevSum+mat[i][j])\n                # pruning step 2 - break if we found minDiff 0 --> VERY CRTICIAL\n                if diff == 0:\n                    minDiff = 0\n                    break\n                minDiff = min(minDiff, diff)\n            \n            dp[i][prevSum] = minDiff\n            return minDiff\n        \n        return findMinAbsDiff(0, 0)"}
{"prompt": "def recoverArray(self, n: int, sums: List[int]) -> List[int]:\n        res = []  # Result set\n        sums.sort()\n        \n        while len(sums) > 1:\n            num = sums[-1] - sums[-2] # max - secondMax\n            countMap = Counter(sums) # Get count of each elements\n            excluding = [] # Subset sums that do NOT contain num\n            including = [] # Subset sums that contain num\n            \n            for x in sums:\n                if countMap.get(x) > 0:\n                    excluding.append(x)\n                    including.append(x+num)\n                    countMap[x] -= 1\n                    countMap[x+num] -= 1\n                    \n\t\t\t# Check validity of excluding set\t\n            if 0 in excluding:\n                sums = excluding\n                res.append(num)\n            else:\n                sums = including\n                res.append(-1*num)\n        \n        return res"}
{"prompt": "def minimumDifference(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        return min(nums[i+k-1]-nums[i] for i in range(len(nums)-k+1))"}
{"prompt": "def kthLargestNumber(self, nums: List[str], k: int) -> str:\n        nums = sorted(map(int, nums), reverse=True)\n        return str(nums[k-1])"}
{"prompt": "def minSessions(self, tasks: List[int], sessionTime: int) -> int:\n        subsets = []\n        self.ans = len(tasks)\n        \n        def func(idx):\n            if len(subsets) >= self.ans:\n                return\n            \n            if idx == len(tasks):\n                self.ans = min(self.ans, len(subsets))\n                return\n            \n            for i in range(len(subsets)):\n                if subsets[i] + tasks[idx] <= sessionTime:\n                    subsets[i] += tasks[idx]\n                    func(idx + 1)\n                    subsets[i] -= tasks[idx]\n            \n            subsets.append(tasks[idx])\n            func(idx + 1)\n            subsets.pop()\n        \n        func(0)\n        return self.ans"}
{"prompt": "def numberOfUniqueGoodSubsequences(self, binary: str) -> int:\n        \n        @cache\n        def fn(i, mask, v): \n            \"\"\"Return # unique good subsequences starting with 1.\"\"\"\n            if i == len(binary) or not mask: return v\n            x = int(binary[i])\n            if not mask &amp; (1<<x): return fn(i+1, mask, v)\n            return (fn(i+1, 3, 1) + fn(i+1, mask^(1<<x), v)) % 1_000_000_007\n        \n        return fn(0, 2, 0) + int(\"0\" in binary)"}
{"prompt": "def findMiddleIndex(self, nums: List[int]) -> int:\n        left = 0 # nums[0] + nums[1] + ... + nums[middleIndex-1]\n        right = sum(nums) # nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1]\n\n        for i, num in enumerate(nums): # we can use normal for loop as well.\n            right -= num # as we are trying to find out middle index so iteratively we`ll reduce the value of right to find the middle index\n            if left == right: # comparing the values for finding out the middle index.\n                return i # if there is any return the index whixh will be our required index.\n            left += num # we have to add the num iteratively. \n\n        return -1"}
{"prompt": "def findFarmland(self, land: List[List[int]]) -> List[List[int]]:\n        m, n = len(land), len(land[0])\n        ans = []\n        for i in range(m):\n            for j in range(n): \n                if land[i][j]: # found farmland\n                    mini, minj = i, j \n                    maxi, maxj = i, j \n                    stack = [(i, j)]\n                    land[i][j] = 0 # mark as visited \n                    while stack: \n                        i, j = stack.pop()\n                        for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \n                            if 0 <= ii < m and 0 <= jj < n and land[ii][jj]: \n                                stack.append((ii, jj))\n                                land[ii][jj] = 0 \n                                maxi = max(maxi, ii)\n                                maxj = max(maxj, jj)\n                    ans.append([mini, minj, maxi, maxj])\n        return ans"}
{"prompt": "def numberOfGoodSubsets(self, nums: List[int]) -> int:\n        freq = [0] * 31\n        for x in nums: freq[x] += 1\n        \n        masks = [0] * 31\n        for x in range(1, 31): \n            if x == 1: masks[x] = 0b10\n            else: \n                bits = 0\n                xx = x\n                for k in (2, 3, 5, 7, 11, 13, 17, 19, 23, 29): \n                    while xx % k == 0: \n                        if (bits >> k) &amp; 1: break # repeated factors \n                        bits ^= 1 << k\n                        xx //= k\n                    else: continue \n                    break \n                else: masks[x] = bits\n                    \n        @cache\n        def fn(x, m): \n            \"\"\"Return number of good subsets.\"\"\"\n            if x == 31: return int(m > 2)\n            ans = fn(x+1, m)\n            if freq[x] and masks[x]: \n                if x == 1: ans *= 2**freq[x]\n                elif not m &amp; masks[x]: ans += freq[x] * fn(x+1, m | masks[x])\n            return ans % 1_000_000_007\n        \n        return fn(1, 0)"}
{"prompt": "def countQuadruplets(self, nums: List[int]) -> int:\n        idx = defaultdict(list)\n        for i in range(len(nums)-1):\n            for j in range(i+1, len(nums)):\n                idx[nums[j]-nums[i]].append(i)\n        \n        count = 0 \n        for i in range(len(nums)-3):\n            for j in range(i+1, len(nums)-2):\n                count += sum(k > j for k in idx[nums[i]+nums[j]])\n                        \n        return count"}
{"prompt": "def numberOfWeakCharacters(self, properties: List[List[int]]) -> int:\n        \n        properties.sort(key=lambda x: (-x[0],x[1]))\n        \n        ans = 0\n        curr_max = 0\n        \n        for _, d in properties:\n            if d < curr_max:\n                ans += 1\n            else:\n                curr_max = d\n        return ans"}
{"prompt": "def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\n        odd = [0]\n        even = [1]\n        for i in range(1, len(nextVisit)): \n            odd.append((even[-1] + 1) % 1_000_000_007)\n            even.append((2*odd[-1] - odd[nextVisit[i]] + 1) % 1_000_000_007)\n        return odd[-1]"}
{"prompt": "def reversePrefix(self, word: str, ch: str) -> str:\n        try:\n            ix = word.index(ch)\n            return word[:ix+1][::-1] + word[ix+1:]\n        except ValueError:\n            return word"}
{"prompt": "def interchangeableRectangles(self, rectangles: List[List[int]]) -> int:\n        preSum = []\n        for rec in rectangles:\n            preSum.append(rec[1]/rec[0])\n        \n        dic1 = {}\n        for i in range(len(preSum)-1, -1, -1):\n            if preSum[i] not in dic1.keys():\n                dic1[preSum[i]] = [0,1]\n            else:\n                dic1[preSum[i]][0] = dic1[preSum[i]][0] + dic1[preSum[i]][1]\n                dic1[preSum[i]][1] += 1\n        \n        return sum ([v[0] for v in dic1.values()])"}
{"prompt": "def maxProduct(self, s: str) -> int:\n        subs = []\n        n = len(s)\n        def dfs(curr, ind, inds):\n            if ind == n:\n                if curr == curr[::-1]:\n                    subs.append((curr, inds))\n                return\n            dfs(curr+s[ind], ind+1, inds|{ind})\n            dfs(curr, ind+1, inds)\n        \n        dfs('', 0, set())\n        \n        res = 0\n        n = len(subs)\n        for i in range(n):\n            s1, i1 = subs[i]\n            for j in range(i+1, n):\n                s2, i2 = subs[j]\n                if len(i1 &amp; i2) == 0:\n                    res = max(res, len(s1)*len(s2))\n        return res"}
{"prompt": "def smallestMissingValueSubtree(self, parents: List[int], nums: List[int]) -> List[int]:\n        ans = [1] * len(parents)\n        if 1 in nums: \n            tree = {}\n            for i, x in enumerate(parents): \n                tree.setdefault(x, []).append(i)\n                \n            k = nums.index(1)\n            val = 1\n            seen = set()\n            \n            while k != -1: \n                stack = [k]\n                while stack: \n                    x = stack.pop()\n                    seen.add(nums[x])\n                    for xx in tree.get(x, []): \n                        if nums[xx] not in seen: \n                            stack.append(xx)\n                            seen.add(nums[xx])\n                while val in seen: val += 1\n                ans[k] = val\n                k = parents[k]\n        return ans"}
{"prompt": "def countKDifference(self, nums: List[int], k: int) -> int:\n        seen = defaultdict(int)\n        counter = 0\n        for num in nums:\n            tmp, tmp2 = num - k, num + k\n            if tmp in seen:\n                counter += seen[tmp]\n            if tmp2 in seen:\n                counter += seen[tmp2]\n            \n            seen[num] += 1\n        \n        return counter"}
{"prompt": "def findOriginalArray(self, changed: List[int]) -> List[int]:\n        \n        \"\"\"\n        The idea is to:\n            1st sort the numbers\n            2nd Create a counter to save the frequency of each number\n            3nd iterate the array and for each number check if the double exists.\n            4rd after taking len(changed) // 2 numbers return the answer\n            \n        Time complexity: O(nlog(n)) \n        Space complexity: O(n)\n        \n        \"\"\"\n        \n        \n        if len(changed) % 2 != 0: # If there are not even amount the numbers there is no solution.\n            return []\n        \n        changed.sort()\n        \n        c = Counter(changed) # The counter is needed because we have 0s\n        \n        answer = []\n        for num in changed:\n            if num in c and c[num] >= 1: # Check if the number is available (we may have taken it before)\n                c[num] -= 1 # we mark the number as used by decreasing the counter (only needed for the zeros)\n                if (num * 2) in c and c[(num * 2)] >= 1: # Take the one that doubles it if exists\n                    answer.append(num)\n                    c[num*2] -= 1 # The number has been taken.\n            \n            if len(answer) == len(changed) // 2:\n                return answer\n        \n        return []"}
{"prompt": "def maxTaxiEarnings(self, n: int, rides: List[List[int]]) -> int:\n        \n        d = {}\n        for start,end,tip in rides:\n            if end not in d:\n                d[end] =[[start,tip]]\n            else:\n                d[end].append([start,tip])\n        \n       \n        dp = [0]*(n+1)\n        dp[0] = 0\n        \n        for i in range(1,n+1):\n            dp[i] = dp[i-1]\n            if i in d:\n                temp_profit = 0\n                for start,tip in d[i]:\n                    if (i-start)+tip+dp[start] > temp_profit:\n                        temp_profit = i-start+tip+dp[start]\n                dp[i] = max(dp[i],temp_profit)\n                \n                \n        return dp[-1]"}
{"prompt": "def minOperations(self, nums: List[int]) -> int:\n        n = len(nums)\n        nums = sorted(set(nums))\n        \n        ans = ii = 0\n        for i, x in enumerate(nums): \n            if x - nums[ii] >= n: ii += 1\n            ans = max(ans, i - ii + 1)\n        return n - ans"}
{"prompt": "def finalValueAfterOperations(self, operations: List[str]) -> int:\n        x = 0\n        for o in operations:\n            if '+' in o:\n                x += 1\n            else:\n                x -= 1\n        return x"}
{"prompt": "def sumOfBeauties(self, nums: List[int]) -> int:\n        beauty=[0]*len(nums)\n        for i in range(1,len(nums)-1):\n            leftarr=nums[:i]\n            rightarr=nums[i+1:]\n            if(max(leftarr)<nums[i] and min(rightarr)>nums[i]):\n                beauty[i]=2\n            elif(nums[i-1]<nums[i] and nums[i+1]>nums[i]):\n                beauty[i]=1\n            else:\n                beauty[i]=0\n        return sum(beauty)"}
{"prompt": "def longestSubsequenceRepeatedK(self, s: str, k: int) -> str:\n        freq = [0] * 26\n        for ch in s: freq[ord(ch)-97] += 1\n        \n        cand = [chr(i+97) for i, x in enumerate(freq) if x >= k] # valid candidates \n        \n        def fn(ss): \n            \"\"\"Return True if ss is a k-repeated sub-sequence of s.\"\"\"\n            i = cnt = 0\n            for ch in s: \n                if ss[i] == ch: \n                    i += 1\n                    if i == len(ss): \n                        if (cnt := cnt + 1) == k: return True  \n                        i = 0\n            return False \n        \n        ans = \"\"\n        queue = deque([\"\"])\n        while queue: \n            x = queue.popleft()\n            for ch in cand:  \n                xx = x + ch\n                if fn(xx): \n                    ans = xx\n                    queue.append(xx)\n        return ans"}
{"prompt": "def maximumDifference(self, nums: List[int]) -> int:\n        ans = -1 \n        prefix = inf\n        for i, x in enumerate(nums): \n            if i and x > prefix: ans = max(ans, x - prefix)\n            prefix = min(prefix, x)\n        return ans"}
{"prompt": "def gridGame(self, grid):\n        \n        top, bottom = grid\n        top_sum = sum(top)\n        bottom_sum = 0\n        res = float('inf')\n        \n        for i in range(len(top)):\n            top_sum -= top[i]\n            res = min(res, max(top_sum, bottom_sum))\n            bottom_sum += bottom[i]\n            \n        return res"}
{"prompt": "def placeWordInCrossword(self, board: List[List[str]], word: str) -> bool:\n        for x in board, zip(*board): \n            for row in x: \n                for s in \"\".join(row).split(\"#\"): \n                    for w in word, word[::-1]: \n                        if len(s) == len(w) and all(ss in (\" \", ww) for ss, ww in zip(s, w)): return True \n        return False"}
{"prompt": "def scoreOfStudents(self, s: str, answers: List[int]) -> int:\n        \n        @cache\n        def fn(lo, hi): \n            \"\"\"Return possible answers of s[lo:hi].\"\"\"\n            if lo+1 == hi: return {int(s[lo])}\n            ans = set()\n            for mid in range(lo+1, hi, 2): \n                for x in fn(lo, mid): \n                    for y in fn(mid+1, hi): \n                        if s[mid] == \"+\" and x + y <= 1000: ans.add(x + y)\n                        elif s[mid] == \"*\" and x * y <= 1000: ans.add(x * y)\n            return ans \n                \n        target = eval(s)\n        cand = fn(0, len(s))\n        ans = 0 \n        for x in answers: \n            if x == target: ans += 5\n            elif x in cand: ans += 2\n        return ans"}
{"prompt": "def construct2DArray(self, original: List[int], m: int, n: int) -> List[List[int]]:\n        ans = []\n        if len(original) == m*n: \n            for i in range(0, len(original), n): \n                ans.append(original[i:i+n])\n        return ans"}
{"prompt": "def numOfPairs(self, nums: List[str], target: str) -> int:\n        freq = Counter(nums)\n        ans = 0 \n        for k, v in freq.items(): \n            if target.startswith(k): \n                suffix = target[len(k):]\n                ans += v * freq[suffix]\n                if k == suffix: ans -= freq[suffix]\n        return ans"}
{"prompt": "def maxConsecutiveAnswers(self, string: str, k: int) -> int:\n\t\tresult = 0\n\t\tj = 0\n\t\tcount1 = k\n\t\tfor i in range(len(string)):\n\t\t\tif count1 == 0 and string[i] == \"F\":\n\t\t\t\twhile string[j] != \"F\":\n\t\t\t\t\tj+=1\n\t\t\t\tcount1+=1 \n\t\t\t\tj+=1\n\n\t\t\tif string[i] == \"F\":\n\t\t\t\tif count1 > 0:\n\t\t\t\t\tcount1-=1\n\n\t\t\tif i - j + 1 > result:\n\t\t\t\tresult = i - j + 1\n\n\t\tj = 0\n\t\tcount2 = k\n\t\tfor i in range(len(string)):\n\t\t\tif count2 == 0 and string[i] == \"T\":\n\t\t\t\twhile string[j] != \"T\":\n\t\t\t\t\tj+=1\n\t\t\t\tcount2+=1 \n\t\t\t\tj+=1\n\n\t\t\tif string[i] == \"T\":\n\t\t\t\tif count2 > 0:\n\t\t\t\t\tcount2-=1\n\n\t\t\tif i - j + 1 > result:\n\t\t\t\tresult = i - j + 1\n\n\t\treturn result"}
{"prompt": "def waysToPartition(self, nums: List[int], k: int) -> int:\n        prefix = [0]\n        loc = defaultdict(list)\n        for i, x in enumerate(nums): \n            prefix.append(prefix[-1] + x)\n            if i < len(nums)-1: loc[prefix[-1]].append(i)\n        \n        ans = 0 \n        if prefix[-1] % 2 == 0: ans = len(loc[prefix[-1]//2]) # unchanged \n        \n        total = prefix[-1]\n        for i, x in enumerate(nums): \n            cnt = 0 \n            diff = k - x\n            target = total + diff \n            if target % 2 == 0: \n                target //= 2\n                cnt += bisect_left(loc[target], i)\n                cnt += len(loc[target-diff]) - bisect_left(loc[target-diff], i)\n            ans = max(ans, cnt)\n        return ans"}
{"prompt": "def minimumMoves(self, s: str) -> int:\n        ans = i = 0\n        while i < len(s): \n            if s[i] == \"X\": \n                ans += 1\n                i += 3\n            else: i += 1\n        return ans"}
{"prompt": "def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\n        missing_val, rem = divmod(mean * (len(rolls) + n) - sum(rolls), n)\n        if rem == 0:\n            if 1 <= missing_val <= 6:\n                return [missing_val] * n\n        elif 1 <= missing_val < 6:\n            return [missing_val + 1] * rem + [missing_val] * (n - rem)\n        return []"}
{"prompt": "def stoneGameIX(self, stones: List[int]) -> bool:\n        freq = defaultdict(int)\n        for x in stones: freq[x % 3] += 1\n        \n        if freq[0]%2 == 0: return freq[1] and freq[2]\n        return abs(freq[1] - freq[2]) >= 3"}
{"prompt": "def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\n        counts,total = 0, 0\n        n = len(s)\n        for ch in s:\n            if ch==letter:\n                total +=1\n        stack = []\n        occ = 0\n        for idx,ch in enumerate(s):\n            if ch==letter:\n                counts +=1\n            while stack and stack[-1]>ch and  len(stack)+ (n-1-idx)>=k and (occ+total-counts-(stack[-1]==letter)+(ch==letter)>=repetition ): \n                occ -= stack.pop()==letter\n            if ch!=letter  and len(stack)< k-max(0,(repetition-occ)):\n                stack.append(ch)\n            elif ch==letter and len(stack)+(total-counts)<k:\n                stack.append(ch)\n                occ +=1\n        return ''.join(stack)"}
{"prompt": "def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:\n        s1, s2, s3 = set(nums1), set(nums2), set(nums3)\n        return (s1&amp;s2) | (s2&amp;s3) | (s1&amp;s3)"}
{"prompt": "def minOperations(self, grid: List[List[int]], x: int) -> int:\n        vals = [x for row in grid for x in row]\n        if len(set(val%x for val in vals)) > 1: return -1 # impossible\n        median = sorted(vals)[len(vals)//2] # O(N) possible via \"quick select\"\n        return sum(abs(val - median)//x for val in vals)"}
{"prompt": "def minimumDifference(self, nums: List[int]) -> int:\n        N = len(nums) // 2 # Note this is N/2, ie no. of elements required in each.\n        \n        def get_sums(nums): # generate all combinations sum of k elements\n            ans = {}\n            N = len(nums)\n            for k in range(1, N+1): # takes k element for nums\n                sums = []\n                for comb in combinations(nums, k):\n                    s = sum(comb)\n                    sums.append(s)\n                ans[k] = sums\n            return ans\n        \n        left_part, right_part = nums[:N], nums[N:]\n        left_sums, right_sums = get_sums(left_part), get_sums(right_part)\n        ans = abs(sum(left_part) - sum(right_part)) # the case when taking all N from left_part for left_ans, and vice versa\n        total = sum(nums) \n        half = total // 2 # the best sum required for each, we have to find sum nearest to this\n        for k in range(1, N):\n            left = left_sums[k] # if taking k no. from left_sums\n            right = right_sums[N-k] # then we have to take remaining N-k from right_sums.\n            right.sort() # sorting, so that we can binary search the required value\n            for x in left:\n                r = half - x # required, how much we need to add in x to bring it closer to half.\n                p = bisect.bisect_left(right, r) # we are finding index of value closest to r, present in right, using binary search\n                for q in [p, p-1]:\n                    if 0 <= q < len(right):\n                        left_ans_sum = x + right[q]\n                        right_ans_sum = total - left_ans_sum\n                        diff = abs(left_ans_sum - right_ans_sum)\n                        ans = min(ans, diff) \n        return ans"}
{"prompt": "def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:\n        seats.sort()\n        students.sort()\n        return sum(abs(seat - student) for seat, student in zip(seats, students))"}
{"prompt": "def winnerOfGame(self, s: str) -> bool:\n        \n        a = b = 0\n        \n        for i in range(1,len(s)-1):\n            if s[i-1] == s[i] == s[i+1]:\n                if s[i] == 'A':\n                    a += 1\n                else:\n                    b += 1\n                    \n        return a>b"}
{"prompt": "def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\n        graph = {}\n        for u, v in edges: \n            graph.setdefault(u, []).append(v)\n            graph.setdefault(v, []).append(u)\n        \n        dist = [-1]*len(graph)\n        dist[0] = 0 \n        val = 0\n        queue = [0]\n        while queue: \n            val += 2\n            newq = []\n            for u in queue: \n                for v in graph[u]: \n                    if dist[v] == -1: \n                        dist[v] = val\n                        newq.append(v)\n            queue = newq\n        \n        ans = 0\n        for d, p in zip(dist, patience): \n            if p: \n                k = d//p - int(d%p == 0)\n                ans = max(ans, d + k*p)\n        return ans + 1"}
{"prompt": "def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:\n        \n        def fn(val):\n            \"\"\"Return count of products <= val.\"\"\"\n            ans = 0\n            for x in nums1: \n                if x < 0: ans += len(nums2) - bisect_left(nums2, ceil(val/x))\n                elif x == 0: \n                    if 0 <= val: ans += len(nums2)\n                else: ans += bisect_right(nums2, floor(val/x))\n            return ans \n            \n        lo, hi = -10**10, 10**10 + 1\n        while lo < hi: \n            mid = lo + hi >> 1\n            if fn(mid) < k: lo = mid + 1\n            else: hi = mid\n        return lo"}
{"prompt": "def areNumbersAscending(self, s: str) -> bool:\n        nums = [int(w) for w in s.split() if w.isdigit()]\n        return all(nums[i-1] < nums[i] for i in range(1, len(nums)))"}
{"prompt": "def countMaxOrSubsets(self, nums: List[int]) -> int:\n        target = reduce(or_, nums)\n        \n        @cache\n        def fn(i, mask): \n            \"\"\"Return number of subsets to get target.\"\"\"\n            if mask == target: return 2**(len(nums)-i)\n            if i == len(nums): return 0 \n            return fn(i+1, mask | nums[i]) + fn(i+1, mask)\n        \n        return fn(0, 0)"}
{"prompt": "def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\n        graph = [[] for _ in range(n)]\n        for u, v in edges: \n            graph[u-1].append(v-1)\n            graph[v-1].append(u-1)\n        pq = [(0, 0)]\n        seen = [[] for _ in range(n)]\n        least = None\n        while pq: \n            t, u = heappop(pq)\n            if u == n-1: \n                if least is None: least = t\n                elif least < t: return t \n            if (t//change) &amp; 1: t = (t//change+1)*change # waiting for green\n            t += time\n            for v in graph[u]: \n                if not seen[v] or len(seen[v]) == 1 and seen[v][0] != t: \n                    seen[v].append(t)\n                    heappush(pq, (t, v))"}
{"prompt": "def countValidWords(self, sentence: str) -> int:\n        \n        def fn(word): \n            \"\"\"Return true if word is valid.\"\"\"\n            seen = False \n            for i, ch in enumerate(word): \n                if ch.isdigit() or ch in \"!.,\" and i != len(word)-1: return False\n                elif ch == '-': \n                    if seen or i == 0 or i == len(word)-1 or not word[i+1].isalpha(): return False \n                    seen = True \n            return True \n        \n        return sum(fn(word) for word in sentence.split())"}
{"prompt": "def nextBeautifulNumber(self, n: int) -> int:\n        while True: \n            n += 1\n            nn = n \n            freq = defaultdict(int)\n            while nn: \n                nn, d = divmod(nn, 10)\n                freq[d] += 1\n            if all(k == v for k, v in freq.items()): return n"}
{"prompt": "def countHighestScoreNodes(self, parents: List[int]) -> int:\n        graph = collections.defaultdict(list)\n        for node, parent in enumerate(parents):  # build graph\n            graph[parent].append(node)\n        n = len(parents)                         # total number of nodes\n        d = collections.Counter()\n        def count_nodes(node):                   # number of children node + self\n            p, s = 1, 0                          # p: product, s: sum\n            for child in graph[node]:            # for each child (only 2 at maximum)\n                res = count_nodes(child)         # get its nodes count\n                p *= res                         # take the product\n                s += res                         # take the sum\n            p *= max(1, n - 1 - s)               # times up-branch (number of nodes other than left, right children ans itself)\n            d[p] += 1                            # count the product\n            return s + 1                         # return number of children node + 1 (self)\n        count_nodes(0)                           # starting from root (0)\n        return d[max(d.keys())]                  # return max count"}
{"prompt": "def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\n        graph = { course:[] for course in range(n)}\n        inDegree = [0]*n\n        # 1- build graph\n        #  convert 1-base into 0-baseindexes and add to graph\n        # Note: choose Prev->next since it helps to preserve the topology order\n        for prevCourse,nextCourse in relations:\n            prevCourse,nextCourse = prevCourse-1, nextCourse-1\n            graph[prevCourse].append(nextCourse)\n            inDegree[nextCourse] += 1\n\n        # 2 Assign time cost\n        q = collections.deque()\n        cost = [0] * n\n        for course in range(n):\n            if inDegree[course] == 0:\n                q.append(course)\n                cost[course] = time[course] # number of months\n        # 3- BFS\n        while q:\n            prevCourse = q.popleft()\n            for nextCourse in graph[prevCourse]:\n                # Update cost[nextCourse] using the maximum cost of the predecessor course\n                cost[nextCourse] = max(cost[nextCourse], cost[prevCourse] + time[nextCourse])\n                inDegree[nextCourse] -= 1\n                if inDegree[nextCourse] == 0:\n                    q.append(nextCourse)\n        return max(cost)\n\t\t```"}
{"prompt": "def kthDistinct(self, arr: List[str], k: int) -> str:\n        freq = Counter(arr)\n        for x in arr: \n            if freq[x] == 1: k -= 1\n            if k == 0: return x\n        return \"\""}
{"prompt": "def maxTwoEvents(self, events: List[List[int]]) -> int:\n    \n    events.sort()\n    heap = []\n    res2,res1 = 0,0\n    for s,e,p in events:\n        while heap and heap[0][0]<s:\n            res1 = max(res1,heapq.heappop(heap)[1])\n        \n        res2 = max(res2,res1+p)\n        heapq.heappush(heap,(e,p))\n    \n    return res2"}
{"prompt": "def platesBetweenCandles(self, s: str, qs: List[List[int]]) -> List[int]:\n        n=len(s)\n        prefcandle=[-1]*n #this stores the position of closest candle from current towards left\n        suffcandle=[0]*n #this stores the position of closest candle from current towards right\n        \n        pref=[0]*n #stores the number of plates  till ith position from 0 - for i = 0 -> n \n        \n        ind=-1\n        c=0\n        #The following method calculates number of plates(*) till ith position from 0 - for i = 0 -> n \n        for i in range(n):\n            if ind!=-1 and s[i]=='*':\n                c+=1\n            elif s[i]=='|':\n                ind=i\n            pref[i]=c\n              \n        #this method calculates the left nearest candle to a point\n        #intial is -1 as to left of leftmost element no candle can be present\n        ind =-1\n        for i in range(n):\n            if s[i] == '|':\n                ind=i\n            prefcandle[i]=ind\n            \n        #this method calculates the right nearest candle to a point\n        #intial is infinity as to right of rightmost element no candle can be present\n        ind = float('inf')       \n        for i in range(n-1, -1, -1):\n            if s[i]=='|':\n                ind=i\n            suffcandle[i]=ind\n\n        #m = no of queries\n        m=len(qs)\n        ans=[0]*m\n\n        for i in range(m):\n            c=0\n            l=qs[i][0]\n            r=qs[i][1]\n            \n            #check if left nearest candle of right boundary is after left boundary\n            #check if right nearest candle of left boundary is before right boundary\n            # to summarise - here we find if there is a pair of candle present within the given range or not\n            if prefcandle[r]<l or suffcandle[l]>r:\n                continue\n            \n            #desired answer is no of pplates(*) only inside 2 candles (|) inside the given boundary area\n            ans[i]=pref[prefcandle[r]]-pref[suffcandle[l]]\n        return ans"}
{"prompt": "BOARD_SIZE = 8\n    \n    def diag(self, r, c):\n        # Return all diagonal indices except (r, c)\n        # Diagonal indices has the same r - c\n        inv = r - c\n        result = []\n        for ri in range(self.BOARD_SIZE):\n            ci = ri - inv\n            if 0 <= ci < self.BOARD_SIZE and ri != r:\n                result.append((ri, ci))\n\n        return result\n    \n    def reverseDiag(self, r, c):\n        # Return all reverse diagonal indices except (r, c)\n        # Reverse diagonal indices has the same r + c\n        inv = r + c\n        result = []\n        for ri in range(self.BOARD_SIZE):\n            ci = inv - ri\n            if 0 <= ci < self.BOARD_SIZE and ri != r:\n                result.append((ri, ci))\n\n        return result\n    \n    def generatePossiblePositions(self, piece, start):\n        # Generate list of possible positions for every figure\n        rs, cs = start[0] - 1, start[1] - 1\n\n        # Start position\n        result = [(rs, cs)]\n\n        # Straight\n        if piece == \"rook\" or piece == \"queen\":\n            result.extend([(r, cs) for r in range(self.BOARD_SIZE) if r != rs])\n            result.extend([(rs, c) for c in range(self.BOARD_SIZE) if c != cs])\n\n        # Diagonal\n        if piece == \"bishop\" or piece == \"queen\":\n            result.extend(self.diag(rs, cs))\n            result.extend(self.reverseDiag(rs, cs))\n\n        return result\n    \n    def collide(self, start1, end1, start2, end2):\n        # Check if two figures will collide\n        # Collision occures if: \n        #  - two figures have the same end points\n        #  - one figure stands on the way of second one\n        #\n        # For this purpose let's model each step of two pieces \n        # and compare their positions at every time step.\n        \n        def steps(start, end):\n            # Total steps that should be done\n            return abs(end - start)\n\n        def step(start, end):\n            # Step direction -1, 0, 1\n            if steps(start, end) == 0:\n                return 0\n            return (end - start) / steps(start, end)\n\n        (rstart1, cstart1), (rend1, cend1) = start1, end1\n        (rstart2, cstart2), (rend2, cend2) = start2, end2\n\n        # Find step direction for each piece\n        rstep1, cstep1 = step(rstart1, rend1), step(cstart1, cend1)\n        rstep2, cstep2 = step(rstart2, rend2), step(cstart2, cend2)\n\n        # Find maximum number of steps for each piece\n        max_step1 = max(steps(rstart1, rend1), steps(cstart1, cend1))\n        max_step2 = max(steps(rstart2, rend2), steps(cstart2, cend2))\n\n        # Move pieces step by step and compare their positions\n        for step_i in range(max(max_step1, max_step2) + 1):\n            step_i1 = min(step_i, max_step1)\n            r1 = rstart1 + step_i1 * rstep1\n            c1 = cstart1 + step_i1 * cstep1\n\n            step_i2 = min(step_i, max_step2)\n            r2 = rstart2 + step_i2 * rstep2\n            c2 = cstart2 + step_i2 * cstep2\n\n            # If positions are the same then collision occures\n            if r1 == r2 and c1 == c2:\n                return True\n\n        return False\n    \n    def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:\n        if len(pieces) == 0:\n            return 0\n\n        n = len(pieces)\n        \n        # Make zero-indexed\n        start_positions = [[r - 1, c - 1] for r, c in positions]\n        \n        # All possible positions\n        possible_positions = [\n            self.generatePossiblePositions(piece, start) \n            for piece, start in zip(pieces, positions)\n        ]\n        \n        # Let's use DFS with backtracking\n        # For that we will keep set of already occupied coordinates\n        # and current positions of pieces\n        occupied = set()\n        current_positions = [None] * n  # None means that we didn't placed the piece\n        \n        def collision(start, end):\n            # Helper to check if moving from start to end position will collide with someone\n            for start2, end2 in zip(start_positions, current_positions):\n                if end2 is not None and self.collide(start, end, start2, end2):\n                    return True\n            return False\n\n        def dfs(piece_i=0):\n            # All pieces are placed\n            if piece_i == n:\n                return 1\n\n            result = 0\n            for position in possible_positions[piece_i]:\n                # If position already occupied of collides with other pieces then skip it\n                if position in occupied or collision(start_positions[piece_i], position):\n                    continue\n                \n                # Occupy the position\n                occupied.add(position)\n                current_positions[piece_i] = position\n                \n                # Run DFS for next piece\n                result += dfs(piece_i + 1)\n                \n                # Release the position\n                occupied.remove(position)\n                current_positions[piece_i] = None\n                \n            return result\n\n        return dfs()"}
{"prompt": "def smallestEqual(self, nums: List[int]) -> int:\n        return next((i for i, x in enumerate(nums) if i%10 == x), -1)"}
{"prompt": "def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\n        min_res = math.inf\n        min_point = max_point = last_point = None\n        prev_val = head.val\n        head = head.next\n        i = 1\n        while head.next:\n            if ((head.next.val < head.val and prev_val < head.val) or\n               (head.next.val > head.val and prev_val > head.val)):\n                \n                if min_point is None:\n                    min_point = i\n                else:\n                    max_point = i\n                \n                if last_point:\n                    min_res = min(min_res, i - last_point)\n                \n                last_point = i\n            \n            prev_val = head.val\n            i += 1\n            head = head.next\n        \n        if min_res == math.inf:\n            min_res = -1\n        max_res = max_point - min_point if max_point else -1\n        \n        return [min_res, max_res]"}
{"prompt": "def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\n        ans = 0\n        seen = {start}\n        queue = deque([start])\n        while queue: \n            for _ in range(len(queue)): \n                val = queue.popleft()\n                if val == goal: return ans \n                if 0 <= val <= 1000: \n                    for x in nums: \n                        for op in (add, sub, xor): \n                            if op(val, x) not in seen: \n                                seen.add(op(val, x))\n                                queue.append(op(val, x))\n            ans += 1\n        return -1"}
{"prompt": "def possiblyEquals(self, s1: str, s2: str) -> bool:\n        \n        def gg(s): \n            \"\"\"Return possible length\"\"\"\n            ans = [int(s)]\n            if len(s) == 2: \n                if s[1] != '0': ans.append(int(s[0]) + int(s[1]))\n                return ans\n            elif len(s) == 3: \n                if s[1] != '0': ans.append(int(s[:1]) + int(s[1:]))\n                if s[2] != '0': ans.append(int(s[:2]) + int(s[2:]))\n                if s[1] != '0' and s[2] != '0': ans.append(int(s[0]) + int(s[1]) + int(s[2]))\n            return ans \n        \n        @cache\n        def fn(i, j, diff): \n            \"\"\"Return True if s1[i:] matches s2[j:] with given differences.\"\"\"\n            if i == len(s1) and j == len(s2): return diff == 0\n            if i < len(s1) and s1[i].isdigit(): \n                ii = i\n                while ii < len(s1) and s1[ii].isdigit(): ii += 1\n                for x in gg(s1[i:ii]): \n                    if fn(ii, j, diff-x): return True \n            elif j < len(s2) and s2[j].isdigit(): \n                jj = j \n                while jj < len(s2) and s2[jj].isdigit(): jj += 1\n                for x in gg(s2[j:jj]): \n                    if fn(i, jj, diff+x): return True \n            elif diff == 0: \n                if i == len(s1) or j == len(s2) or s1[i] != s2[j]: return False \n                return fn(i+1, j+1, 0)\n            elif diff > 0: \n                if i == len(s1): return False \n                return fn(i+1, j, diff-1)\n            else: \n                if j == len(s2): return False \n                return fn(i, j+1, diff+1)\n            \n        return fn(0, 0, 0)"}
{"prompt": "def countVowelSubstrings(self, word: str) -> int:\n        ans = 0 \n        freq = defaultdict(int)\n        for i, x in enumerate(word): \n            if x in \"aeiou\": \n                if not i or word[i-1] not in \"aeiou\": \n                    jj = j = i # set anchor\n                    freq.clear()\n                freq[x] += 1\n                while len(freq) == 5 and all(freq.values()): \n                    freq[word[j]] -= 1\n                    j += 1\n                ans += j - jj\n        return ans"}
{"prompt": "def countVowels(self, word: str) -> int:\n        count = 0\n        sz = len(word)\n        \n        for pos in range(sz):\n            if word[pos] in 'aeiou':\n                count += (sz - pos) * (pos + 1)\n        \n        return count"}
{"prompt": "def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\n        lo, hi = 1, max(quantities)\n        while lo < hi: \n            mid = lo + hi >> 1\n            if sum(ceil(qty/mid) for qty in quantities) <= n: hi = mid \n            else: lo = mid + 1\n        return lo"}
{"prompt": "def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\n        ans = 0\n        graph = collections.defaultdict(dict)\n        for u, v, t in edges:\n            graph[u][v] = t\n            graph[v][u] = t\n        \n        def dfs(curr, visited, score, cost):\n            if curr == 0:\n                nonlocal ans\n                ans = max(ans, score)\n            \n            for nxt, time in graph[curr].items():\n                if time <= cost:\n                    dfs(nxt, visited|set([nxt]), score+values[nxt]*(nxt not in visited), cost-time)\n        \n        dfs(0, set([0]), values[0], maxTime)\n        return ans"}
{"prompt": "def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\n        freq = [0]*26\n        for x in word1: freq[ord(x)-97] += 1\n        for x in word2: freq[ord(x)-97] -= 1\n        return all(abs(x) <= 3 for x in freq)"}
{"prompt": "def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:\n\n\t\titems.sort()\n\t\tdic = dict()\n\t\tres = []\n\t\tgmax = 0\n\t\tfor p,b in items:\n\t\t\tgmax = max(b,gmax)\n\t\t\tdic[p] = gmax\n\n\t\tkeys = sorted(dic.keys())\n\t\tfor q in queries:\n\t\t\tind = bisect.bisect_left(keys,q)\n\t\t\tif ind<len(keys) and keys[ind]==q:\n\t\t\t\tres.append(dic[q])\n\t\t\telif ind==0:\n\t\t\t\tres.append(0)\n\t\t\telse:\n\t\t\t\tres.append(dic[keys[ind-1]])\n\n\t\treturn res"}
{"prompt": "def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:\n        # workers sorted in reverse order, tasks sorted in normal order\n        def can_assign(n):\n            task_i = 0\n            task_temp = deque()\n            n_pills = pills\n            for i in range(n-1,-1,-1):\n                while task_i < n and tasks[task_i] <= workers[i]+strength:\n                    task_temp.append(tasks[task_i])\n                    task_i += 1\n                \n                if len(task_temp) == 0:\n                    return False\n                if workers[i] >= task_temp[0]:\n                    task_temp.popleft()\n                elif n_pills > 0:\n                    task_temp.pop()\n                    n_pills -= 1\n                else:\n                    return False\n            return True\n        \n        tasks.sort()\n        workers.sort(reverse = True)\n        \n        l = 0\n        r = min(len(tasks), len(workers))\n        res = -1\n        while l <= r:\n            m = (l+r)//2\n            if can_assign(m):\n                res = m\n                l = m+1\n            else:\n                r = m-1\n        return res"}
{"prompt": "def timeRequiredToBuy(self, tickets: list[int], k: int) -> int:\n        secs = 0 \n        i = 0\n        while tickets[k] != 0:\n            if tickets[i] != 0: # if it is zero that means we dont have to count it anymore\n                tickets[i] -= 1 # decrease the value by 1 everytime\n                secs += 1 # increase secs by 1\n\n            i = (i + 1) % len(tickets) # since after getting to the end of the array we have to return to the first value so we use the mod operator\n            \n        return secs"}
{"prompt": "def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        n, node = 0, head\n        while node: n, node = n+1, node.next\n        \n        k, node = 0, head \n        while n: \n            k += 1\n            size = min(k, n)\n            stack = []\n            if not size &amp; 1: \n                temp = node \n                for _ in range(size): \n                    stack.append(temp.val)\n                    temp = temp.next \n            for _ in range(size): \n                if stack: node.val = stack.pop()\n                node = node.next \n            n -= size\n        return head"}
{"prompt": "def decodeCiphertext(self, encodedText: str, rows: int) -> str:\n        cols, res = len(encodedText) // rows, \"\"\n        for i in range(cols):\n            for j in range(i, len(encodedText), cols + 1):\n                res += encodedText[j]\n        return res.rstrip()"}
{"prompt": "def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:        \n        result = [False for _ in requests]\n        \n        connected_components = [{i} for i in range(n)]\n        \n        connected_comp_dict = {}\n        for i in range(n):\n            connected_comp_dict[i] = i\n        \n        banned_by_comps = [set() for i in range(n)]\n        for res in restrictions:\n            banned_by_comps[res[0]].add(res[1])\n            banned_by_comps[res[1]].add(res[0])\n        for i,r in enumerate(requests):\n            n1, n2 = r[0], r[1]\n            c1, c2 = connected_comp_dict[n1], connected_comp_dict[n2]\n            if c1 == c2:\n                result[i] = True\n            else:\n                if not (connected_components[c1].intersection(banned_by_comps[c2]) or connected_components[c2].intersection(banned_by_comps[c1])):\n                    connected_components[c1].update(connected_components[c2])\n                    banned_by_comps[c1].update(banned_by_comps[c2])\n                    for node in connected_components[c2]:\n                        connected_comp_dict[node] = c1\n                    result[i] = True\n                \n        return result"}
{"prompt": "def maxDistance(self, colors: List[int]) -> int:\n        ans = 0 \n        for i, x in enumerate(colors): \n            if x != colors[0]: ans = max(ans, i)\n            if x != colors[-1]: ans = max(ans, len(colors)-1-i)\n        return ans"}
{"prompt": "def wateringPlants(self, plants: List[int], capacity: int) -> int:\n        ans = 0\n        can = capacity\n        for i, x in enumerate(plants): \n            if can < x: \n                ans += 2*i\n                can = capacity\n            ans += 1\n            can -= x\n        return ans"}
{"prompt": "def kMirror(self, k: int, n: int) -> int:\n        \n        def fn(x):\n            \"\"\"Return next k-symmetric number.\"\"\"\n            n = len(x)//2\n            for i in range(n, len(x)): \n                if int(x[i])+1 < k: \n                    x[i] = x[~i] = str(int(x[i])+1)\n                    for ii in range(n, i): x[ii] = x[~ii] = '0'\n                    return x\n            return [\"1\"] + [\"0\"]*(len(x)-1) + [\"1\"]\n                \n        x = [\"0\"]\n        ans = 0\n        for _ in range(n): \n            while True: \n                x = fn(x)\n                val = int(\"\".join(x), k)\n                if str(val)[::-1] == str(val): break\n            ans += val\n        return ans"}
{"prompt": "def countWords(self, words1: List[str], words2: List[str]) -> int:\n        freq1, freq2 = Counter(words1), Counter(words2)\n        return len({w for w, v in freq1.items() if v == 1} &amp; {w for w, v in freq2.items() if v == 1})"}
{"prompt": "def minimumBuckets(self, street: str) -> int:\n        street = list(street)\n        ans = 0 \n        for i, ch in enumerate(street): \n            if ch == 'H' and (i == 0 or street[i-1] != '#'): \n                if i+1 < len(street) and street[i+1] == '.': street[i+1] = '#'\n                elif i and street[i-1] == '.': street[i-1] = '#'\n                else: return -1\n                ans += 1\n        return ans"}
{"prompt": "def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\n    src_x,src_y = startPos[0],startPos[1]\n    end_x,end_y = homePos[0], homePos[1]\n    \n    if src_x < end_x:\n        rc = sum(rowCosts[src_x+1:end_x+1])\n    elif src_x > end_x:\n        rc = sum(rowCosts[end_x:src_x])\n    else:\n        rc=0\n    \n    if src_y < end_y:\n        cc = sum(colCosts[src_y+1:end_y+1])\n    elif src_y > end_y:\n        cc = sum(colCosts[end_y:src_y])\n    else:\n        cc=0\n    \n    return cc+rc"}
{"prompt": "def countPyramids(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        vals = [[inf]*n for _ in range(m)]\n        for i in range(m):\n            for j in range(n): \n                if grid[i][j] == 0: vals[i][j] = 0\n                elif j == 0: vals[i][j] = 1\n                else: vals[i][j] = min(vals[i][j], 1 + vals[i][j-1])\n                if grid[i][~j] == 0: vals[i][~j] = 0\n                elif j == 0: vals[i][~j] = 1\n                else: vals[i][~j] = min(vals[i][~j], 1 + vals[i][~j+1])\n        \n        def fn(vals): \n            \"\"\"Return count of pyramid in given grid.\"\"\"\n            ans = 0 \n            for j in range(n):\n                width = 0\n                for i in range(m): \n                    if vals[i][j]: width = min(width+1, vals[i][j])\n                    else: width = 0\n                    ans += max(0, width-1)\n            return ans \n        \n        return fn(vals) + fn(vals[::-1])"}
{"prompt": "def targetIndices(self, nums, target):\n        ans = []\n        for i,num in enumerate(sorted(nums)):\n            if num == target: ans.append(i)\n        return ans"}
{"prompt": "def getAverages(self, nums: List[int], k: int) -> List[int]:\n    res = [-1]*len(nums)\n\n    left, curWindowSum, diameter = 0, 0, 2*k+1\n    for right in range(len(nums)):\n      curWindowSum += nums[right]\n      if (right-left+1 >= diameter):\n        res[left+k] = curWindowSum//diameter\n        curWindowSum -= nums[left]\n        left += 1\n    return res"}
{"prompt": "def minimumDeletions(self, nums: List[int]) -> int:\n        imin = nums.index(min(nums))\n        imax = nums.index(max(nums))\n        return min(max(imin, imax)+1, len(nums)-min(imin, imax), len(nums)+1+min(imin, imax)-max(imin, imax))"}
{"prompt": "def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\n        can = {0, firstPerson}\n        for _, grp in groupby(sorted(meetings, key=lambda x: x[2]), key=lambda x: x[2]): \n            queue = set()\n            graph = defaultdict(list)\n            for x, y, _ in grp: \n                graph[x].append(y)\n                graph[y].append(x)\n                if x in can: queue.add(x)\n                if y in can: queue.add(y)\n                    \n            queue = deque(queue)\n            while queue: \n                x = queue.popleft()\n                for y in graph[x]: \n                    if y not in can: \n                        can.add(y)\n                        queue.append(y)\n        return can"}
{"prompt": "def findEvenNumbers(self, digits: List[int]) -> List[int]:\n        ans = set()\n        for x, y, z in permutations(digits, 3): \n            if x != 0 and z &amp; 1 == 0: \n                ans.add(100*x + 10*y + z) \n        return sorted(ans)"}
{"prompt": "def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        slow,fast,prev=head,head,None\n        while fast and fast.next:\n            prev=slow\n            slow=slow.next\n            fast=fast.next.next\n        if prev==None:\n            return None\n        prev.next=slow.next\n        return head"}
{"prompt": "def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:\n        \n        def lca(node): \n            \"\"\"Return lowest common ancestor of start and dest nodes.\"\"\"\n            if not node or node.val in (startValue , destValue): return node \n            left, right = lca(node.left), lca(node.right)\n            return node if left and right else left or right\n        \n        root = lca(root) # only this sub-tree matters\n        \n        ps = pd = \"\"\n        stack = [(root, \"\")]\n        while stack: \n            node, path = stack.pop()\n            if node.val == startValue: ps = path \n            if node.val == destValue: pd = path\n            if node.left: stack.append((node.left, path + \"L\"))\n            if node.right: stack.append((node.right, path + \"R\"))\n        return \"U\"*len(ps) + pd"}
{"prompt": "def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]"}
{"prompt": "def maxSubsequence(self, nums: List[int], k: int) -> List[int]:\n        tuple_heap = [] # Stores (value, index) as min heap\n        for i, val in enumerate(nums):\n            if len(tuple_heap) == k:\n                heappushpop(tuple_heap, (val, i)) # To prevent size of heap growing larger than k\n            else:\n                heappush(tuple_heap, (val, i))\n\t\t# heap now contains only the k largest elements with their indices as well.\n        tuple_heap.sort(key=lambda x: x[1]) # To get the original order of values. That is why we sort it by index(x[1]) &amp; not value(x[0])\n        ans = []\n        for i in tuple_heap:\n            ans.append(i[0])\n        return ans"}
{"prompt": "def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\n        suffix = [0]*len(security)\n        for i in range(len(security)-2, 0, -1): \n            if security[i] <= security[i+1]: suffix[i] = suffix[i+1] + 1\n        \n        ans = []\n        prefix = 0\n        for i in range(len(security)-time): \n            if i and security[i-1] >= security[i]: prefix += 1\n            else: prefix = 0\n            if prefix >= time and suffix[i] >= time: ans.append(i)\n        return ans"}
{"prompt": "def maximumDetonation(self, bombs: List[List[int]]) -> int:\n        if len(bombs)==1:\n            return 1\n        \n        adlist={i:[] for i in range(len(bombs))}\n        \n        for i in range(len(bombs)):\n            x1,y1,r1=bombs[i]\n            for j in range(i+1,len(bombs)):\n                x2,y2,r2=bombs[j]\n                dist=((x2-x1)**2+(y2-y1)**2)**(1/2)\n                if dist<=r1:\n                    adlist[i].append(j)  \n                if dist<=r2:\n                    adlist[j].append(i)\n        \n        def dfs(adlist,seen,start):\n            seen.add(start)\n            for i in adlist[start]:\n                if i not in seen:\n                    dfs(adlist,seen,i)\n        maxx=1   \n        for v in adlist:\n            seen=set()\n            seen.add(v)\n            dfs(adlist,seen,v)\n            maxx=max(maxx,len(seen))\n        return maxx"}
{"prompt": "def countPoints(self, r: str) -> int:\n        ans = 0\n        for i in range(10):\n            i = str(i)\n            if 'R'+i in r and 'G'+i in r and 'B'+i in r:\n                ans += 1\n        return ans"}
{"prompt": "def subArrayRanges(self, nums: List[int]) -> int:\n        \n        def fn(op): \n            \"\"\"Return min sum (if given gt) or max sum (if given lt).\"\"\"\n            ans = 0 \n            stack = []\n            for i in range(len(nums) + 1): \n                while stack and (i == len(nums) or op(nums[stack[-1]], nums[i])): \n                    mid = stack.pop()\n                    ii = stack[-1] if stack else -1 \n                    ans += nums[mid] * (i - mid) * (mid - ii)\n                stack.append(i)\n            return ans \n        \n        return fn(lt) - fn(gt)"}
{"prompt": "def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\n        ans = 0 \n        lo, hi = 0, len(plants)-1\n        canA, canB = capacityA, capacityB\n        while lo < hi: \n            if canA < plants[lo]: ans += 1; canA = capacityA\n            canA -= plants[lo]\n            if canB < plants[hi]: ans += 1; canB = capacityB\n            canB -= plants[hi]\n            lo, hi = lo+1, hi-1\n        if lo == hi and max(canA, canB) < plants[lo]: ans += 1\n        return ans"}
{"prompt": "def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\n    \n        fruitMap = defaultdict(int)\n        \n        for position, amount in fruits:\n            fruitMap[position] = amount\n        \n        \n        if k == 0:\n            return fruitMap[startPos]\n        \n        totalLeft = 0 # max sum if we go k steps to the left\n        totalRight = 0 # max sum if we go k steps to the right\n        inBetween = 0 # max sum if we go x steps to the left &amp; k steps to the right (ensuring that we don't move more than k steps in total)\n        \n        dp = dict()\n        \n        for i in range(startPos,startPos-k-1, -1):\n            totalLeft += fruitMap[i]\n            dp[i] = totalLeft\n            \n        for i in range(startPos,startPos+k+1):\n            totalRight += fruitMap[i]\n            dp[i] = totalRight\n            \n        \n        leftSteps = 1\n        rightSteps = k-2\n        \n        while rightSteps > 0:\n            currAmount = 0\n            \n            # go right &amp; collect\n            currAmount += dp[startPos-leftSteps]\n            # go left &amp; collect\n            currAmount += dp[startPos+rightSteps]\n            \n            \n            inBetween = max(inBetween, currAmount-fruitMap[startPos])\n            \n            leftSteps += 1\n            rightSteps -= 2\n        \n        \n        leftSteps = k-2\n        rightSteps = 1\n        \n        while leftSteps > 0:\n            currAmount = 0\n            \n            # go right &amp; collect\n            currAmount += dp[startPos-leftSteps]\n            # go left &amp; collect\n            currAmount += dp[startPos+rightSteps]\n            \n            inBetween = max(inBetween, currAmount-fruitMap[startPos])\n            \n            leftSteps -= 2\n            rightSteps += 1\n        \n            \n        return max(totalLeft, totalRight, inBetween)"}
{"prompt": "def firstPalindrome(self, words):\n        for word in words:\n            if word == word[::-1]: return word\n        return \"\""}
{"prompt": "def addSpaces(self, s: str, spaces: List[int]) -> str:\n        \n        arr = []\n        prev = 0\n        for space in spaces:\n            arr.append(s[prev:space])\n            prev = space\n        arr.append(s[space:])\n       \n        return \" \".join(arr)"}
{"prompt": "def getDescentPeriods(self, prices: List[int]) -> int:\n        ans = 0 \n        for i, x in enumerate(prices): \n            if i == 0 or prices[i-1] != x + 1: cnt = 0\n            cnt += 1\n            ans += cnt \n        return ans"}
{"prompt": "def kIncreasing(self, arr: List[int], k: int) -> int:\n        \n        def fn(sub): \n            \"\"\"Return ops to make sub non-decreasing.\"\"\"\n            vals = []\n            for x in sub: \n                k = bisect_right(vals, x)\n                if k == len(vals): vals.append(x)\n                else: vals[k] = x\n            return len(sub) - len(vals)\n        \n        return sum(fn(arr[i:len(arr):k]) for i in range(k))"}
{"prompt": "def mostWordsFound(self, ss: List[str]) -> int:\n        return max(s.count(\" \") for s in ss) + 1"}
{"prompt": "def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n        graph, can_make, supplies = {recipe : [] for recipe in recipes},  {}, set(supplies)\n        def dfs(recipe : str) -> bool:\n            if recipe not in can_make:\n                can_make[recipe] = False\n                can_make[recipe] = all([dfs(ingr) for ingr in graph[recipe]])\n            return can_make[recipe]\n        for i, recipe in enumerate(recipes):\n            for ingr in ingredients[i]:\n                if ingr not in supplies:\n                    graph[recipe].append(ingr if ingr in graph else recipe)\n        return [recipe for recipe in recipes if dfs(recipe)]"}
{"prompt": "def canBeValid(self, s: str, locked: str) -> bool:\n        def validate(s: str, locked: str, op: str) -> bool:\n            bal, wild = 0, 0\n            for i in range(len(s)):\n                if locked[i] == \"1\":\n                    bal += 1 if s[i] == op else -1\n                else:\n                    wild += 1\n                if wild + bal < 0:\n                    return False\n            return bal <= wild\n        return len(s) % 2 == 0 and validate(s, locked, '(') and validate(s[::-1], locked[::-1], ')')"}
{"prompt": "def abbreviateProduct(self, left: int, right: int) -> str:\n        ans = prefix = suffix = 1\n        trailing = 0 \n        flag = False \n        for x in range(left, right+1): \n            if not flag: \n                ans *= x\n                while ans % 10 == 0: ans //= 10 \n                if ans >= 1e10: flag = True \n            prefix *= x\n            suffix *= x\n            while prefix >= 1e12: prefix //= 10 \n            while suffix % 10 == 0: \n                trailing += 1\n                suffix //= 10 \n            if suffix >= 1e10: suffix %= 10_000_000_000\n        while prefix >= 100000: prefix //= 10 \n        suffix %= 100000\n        if flag: return f\"{prefix}...{suffix:>05}e{trailing}\"\n        return f\"{ans}e{trailing}\""}
{"prompt": "def isSameAfterReversals(self, num: int) -> bool:\n        return not num or num % 10"}
{"prompt": "def executeInstructions(self, n: int, startPos: list[int], s: str) -> list[int]:\n\n        def num_of_valid_instructions(s, pos, start, end):\n            row, colon = pos\n            k = 0\n            for i in range(start, end):\n                cur = s[i]\n                row += (cur == 'D') - (cur == 'U')\n                colon += (cur == 'R') - (cur == 'L')\n                if not (0 <= row < n and 0 <= colon < n):\n                    return k\n                k += 1\n            return k\n\n        ans = []\n        for i in range(len(s)):\n            ans.append(num_of_valid_instructions(s, startPos, i, len(s)))\n        return ans"}
{"prompt": "def getDistances(self, arr: List[int]) -> List[int]:\n        loc = defaultdict(list)\n        for i, x in enumerate(arr): loc[x].append(i)\n        \n        for k, idx in loc.items(): \n            prefix = list(accumulate(idx, initial=0))\n            vals = []\n            for i, x in enumerate(idx): \n                vals.append(prefix[-1] - prefix[i] - prefix[i+1] - (len(idx)-2*i-1)*x)\n            loc[k] = deque(vals)\n        \n        return [loc[x].popleft() for x in arr]"}
{"prompt": "def recoverArray(self, nums: List[int]) -> List[int]:\n        nums.sort()\n        cnt = Counter(nums)\n        for i in range(1, len(nums)): \n            diff = nums[i] - nums[0]\n            if diff and diff&amp;1 == 0: \n                ans = []\n                freq = cnt.copy()\n                for k, v in freq.items(): \n                    if v: \n                        if freq[k+diff] < v: break \n                        ans.extend([k+diff//2]*v)\n                        freq[k+diff] -= v\n                else: return ans"}
{"prompt": "def checkString(self, s: str) -> bool:\n        return ''.join(sorted(s)) == s"}
{"prompt": "def numberOfBeams(self, bank: List[str]) -> int:\n        a, s = [x.count(\"1\") for x in bank if x.count(\"1\")], 0\n\n\t\t# ex: bank is [[00101], [01001], [00000], [11011]]\n\t\t# a would return [2, 2, 4]\n\n        for c in range(len(a)-1):\n            s += (a[c]*a[c+1])\n\n\t\t\t# basic math to find the total amount of lasers\n\t\t\t# for the first iteration: s += 2*2\n\t\t\t# for the second iteration: s += 2*4\n\t\t\t# returns s = 12\n\n        return s"}
{"prompt": "def asteroidsDestroyed(self, mass: int, asteroids: List[int]) -> bool:\n        asteroids = sorted(asteroids)\n        for i in asteroids:\n            if i <= mass:\n                mass += i\n            else:\n                return False\n        return True"}
{"prompt": "def maximumInvitations(self, favorite: List[int]) -> int:\n        n = len(favorite)\n        graph = [[] for _ in range(n)]\n        for i, x in enumerate(favorite): graph[x].append(i)\n        \n        def bfs(x, seen): \n            \"\"\"Return longest arm of x.\"\"\"\n            ans = 0 \n            queue = deque([x])\n            while queue: \n                for _ in range(len(queue)): \n                    u = queue.popleft()\n                    for v in graph[u]: \n                        if v not in seen: \n                            seen.add(v)\n                            queue.append(v)\n                ans += 1\n            return ans \n        \n        ans = 0 \n        seen = [False]*n\n        for i, x in enumerate(favorite): \n            if favorite[x] == i and not seen[i]: \n                seen[i] = seen[x] = True \n                ans += bfs(i, {i, x}) + bfs(x, {i, x})\n                \n        dp = [0]*n\n        for i, x in enumerate(favorite): \n            if dp[i] == 0: \n                ii, val = i, 0\n                memo = {}\n                while ii not in memo: \n                    if dp[ii]: \n                        cycle = dp[ii]\n                        break\n                    memo[ii] = val\n                    val += 1\n                    ii = favorite[ii]\n                else: cycle = val - memo[ii]\n                for k in memo: dp[k] = cycle\n        return max(ans, max(dp))"}
{"prompt": "def capitalizeTitle(self, title: str) -> str:\n        title = title.split()\n        word = \"\"\n        for i in range(len(title)):\n            if len(title[i]) < 3:\n                word = word + title[i].lower() + \" \"\n            else:\n                word = word + title[i].capitalize() + \" \"\n        return word[:-1]"}
{"prompt": "def pairSum(self, head: Optional[ListNode]) -> int:\n        nums = []\n        curr = head\n        while curr:\n            nums.append(curr.val)\n            curr = curr.next\n        \n        N = len(nums)\n        res = 0\n        for i in range(N // 2):\n            res = max(res, nums[i] + nums[N - i - 1])\n        return res"}
{"prompt": "def longestPalindrome(self, words: List[str]) -> int:\n        dc=defaultdict(lambda:0)\n        for a in words:\n            dc[a]+=1\n        count=0\n        palindromswords=0\n        inmiddle=0\n        wds=set(words)\n        for a in wds:\n            if(a==a[::-1]):\n                if(dc[a]%2==1):\n                    inmiddle=1\n                palindromswords+=(dc[a]//2)*2\n            elif(dc[a[::-1]]>0):\n                count+=(2*(min(dc[a],dc[a[::-1]])))\n                dc[a]=0\n        return (palindromswords+count+inmiddle)*2\n        ``"}
{"prompt": "def prefix_sum(self, grid: List[List[int]]) -> List[List[int]]:\n            ps = [[grid[row][col] for col in range(len(grid[0]))]for row in range(len(grid))]\n            \n            for row in range(len(grid)):\n                for col in range(1, len(grid[0])):\n                    ps[row][col] = ps[row][col-1] + grid[row][col]\n            \n            for row in range(1, len(grid)):\n                for col in range(len(grid[0])):\n                    ps[row][col] = ps[row-1][col] + ps[row][col]\n            \n            return ps\n\t\t\t\n    def sumRegion(self, ps, row1: int, col1: int, row2: int, col2: int) -> int:\n            ans = 0\n            if row1 == 0 and col1 == 0:\n                ans = ps[row2][col2]\n            elif row1 == 0:\n                ans = ps[row2][col2] - ps[row2][col1-1]\n            elif col1 == 0:\n                ans = ps[row2][col2] - ps[row1-1][col2]\n            else:\n                ans = ps[row2][col2] - ps[row1-1][col2] - ps[row2][col1-1] + ps[row1-1][col1-1]\n            return ans\n\n    def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:\n        diff = [[0 for col in range(len(grid[0])+1)]for row in range(len(grid)+1)]\n        \n        ps = self.prefix_sum(grid)\n        cover = 0\n        \n        for row in range(len(grid)-(stampHeight-1)):\n            for col in range(len(grid[0])-(stampWidth-1)):\n                sub_sum = self.sumRegion(ps, row, col, row+stampHeight-1, col+stampWidth-1)\n                if sub_sum == 0:\n                    diff[row][col] += 1\n                    diff[row][col+stampWidth] -= 1\n                    diff[row+stampHeight][col] -= 1\n                    diff[row+stampHeight][col+stampWidth] = 1\n        pref_diff = self.prefix_sum(diff)\n        m, n = len(grid), len(grid[0])\n        \n        for row in range(len(grid)):\n            for col in range(len(grid[0])):\n                if grid[row][col] == 0 and pref_diff[row][col] == 0: return False \n        \n        return True"}
{"prompt": "def checkValid(self, matrix: List[List[int]]) -> bool:\n        lst = [0]*len(matrix)\n        for i in matrix:\n            if len(set(i)) != len(matrix):\n                return False\n            for j in range(len(i)):\n                lst[j] += i[j]\n        return len(set(lst)) == 1"}
{"prompt": "def minSwaps(self, nums: List[int]) -> int:\n        width = sum(num == 1 for num in nums) #width of the window\n        nums += nums\n        res = width\n        curr_zeros = sum(num == 0 for num in nums[:width]) #the first window is nums[:width]\n        \n        for i in range(width, len(nums)):\n            curr_zeros -= (nums[i - width] == 0) #remove the leftmost 0 if exists\n            curr_zeros += (nums[i] == 0) #add the rightmost 0 if exists\n            res = min(res, curr_zeros) #update if needed\n        \n        return res"}
{"prompt": "def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\n        seen = set()\n        for word in startWords: \n            m = 0\n            for ch in word: m ^= 1 << ord(ch)-97\n            seen.add(m)\n            \n        ans = 0 \n        for word in targetWords: \n            m = 0 \n            for ch in word: m ^= 1 << ord(ch)-97\n            for ch in word: \n                if m ^ (1 << ord(ch)-97) in seen: \n                    ans += 1\n                    break \n        return ans"}
{"prompt": "def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\n        res = 0\n        for grow, plant in sorted(zip(growTime, plantTime)):\n            res = max(res, grow) + plant\n        return res"}
{"prompt": "def divideString(self, s: str, k: int, fill: str) -> List[str]:\n        length = len(s)\n        res=[]\n        for i in range(0,length,k):\n            if i+k>length:\n                break\n            res.append(s[i:i+k])\n        mod =length%k \n        \n        if mod!= 0:\n            fill_str = fill *(k-mod)\n            add_str = s[i:]+fill_str\n            res.append(add_str)\n            \n        return res"}
{"prompt": "def minMoves(self, target: int, maxDoubles: int) -> int:\n       moves = 0\n       while maxDoubles > 0 and target > 1:\n           if target % 2 == 1:\n               target -= 1\n           else:\n               target //= 2\n               maxDoubles -= 1\n           moves += 1\n       moves += target - 1\n       return moves"}
{"prompt": "def mostPoints(self, q: List[List[int]]) -> int:\n        @cache\n        def dfs(i: int) -> int:\n            return 0 if i >= len(q) else max(dfs(i + 1), q[i][0] + dfs(i + 1 + q[i][1]))\n        return dfs(0)"}
{"prompt": "def maxRunTime(self, n: int, batteries: List[int]) -> int:\n        batteries.sort()\n        extra = sum(batteries[:-n])\n        batteries = batteries[-n:]\n        \n        ans = prefix = 0 \n        for i, x in enumerate(batteries): \n            prefix += x \n            if i+1 < len(batteries) and batteries[i+1]*(i+1) - prefix > extra: return (prefix + extra) // (i+1)\n        return (prefix + extra) // n"}
{"prompt": "def minimumCost(self, cost: List[int]) -> int:\n        cost.sort(reverse=True)\n        res, i, N = 0, 0, len(cost)\n        while i < N:\n            res += sum(cost[i : i + 2])\n            i += 3\n        return res"}
{"prompt": "def numberOfArrays(self, diff: List[int], lower: int, upper: int) -> int:\n        diff = list(accumulate(diff, initial = 0))\n        return max(0, upper - lower - (max(diff) - min(diff)) + 1)"}
{"prompt": "def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\n        m, n = len(grid), len(grid[0])\n        ans = []\n        queue = deque([(0, *start)])\n        grid[start[0]][start[1]] *= -1 \n        while queue: \n            x, i, j = queue.popleft()\n            if pricing[0] <= -grid[i][j] <= pricing[1]: ans.append((x, -grid[i][j], i, j))\n            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \n                if 0 <= ii < m and 0 <= jj < n and grid[ii][jj] > 0: \n                    queue.append((x+1, ii, jj))\n                    grid[ii][jj] *= -1\n        return [[i, j] for _, _, i, j in sorted(ans)[:k]]"}
{"prompt": "def numberOfWays(self, corridor: str) -> int:\n        #edge case\n        num_S = corridor.count('S')\n        if num_S == 0 or num_S % 2 == 1:\n            return 0\n        \n        mod = 10 ** 9 + 7\n        curr_s = 0\n        divide_spots = []\n        \n        for char in corridor:\n\t\t\tcurr_s += (char == 'S')\n            if curr_s > 0 and curr_s % 2 == 0:\n                divide_spots[-1] += 1\n            else:\n                if not divide_spots or divide_spots[-1] > 0:\n                    divide_spots.append(0)\n        \n        res = 1\n        for num in divide_spots[:-1]:\n            res = res * num % mod\n        return res"}
{"prompt": "def countElements(self, nums: List[int]) -> int:\n        res = 0\n        mn = min(nums)\n        mx = max(nums)\n        for i in nums:\n            if i > mn and i < mx:\n                res += 1\n        return res"}
{"prompt": "def rearrangeArray(self, nums: List[int]) -> List[int]:\n        return [i for t in zip([p for p in nums if p > 0], [n for n in nums if n < 0]) for i in t]"}
{"prompt": "def findLonely(self, nums: List[int]) -> List[int]:\n        m = Counter(nums)\n        return [n for n in nums if m[n] == 1 and m[n - 1] + m[n + 1] == 0]"}
{"prompt": "def maximumGood(self, statements: List[List[int]]) -> int:\n        ans, n = 0, len(statements)\n        for person in itertools.product([0, 1], repeat=n): # use itertools to create a list only contains 0 or 1\n            valid = True                                   # initially, we think the `person` list is valid\n            for i in range(n):\n                if not person[i]: continue                 # only `good` person's statement can lead to a contradiction, we don't care what `bad` person says\n                for j in range(n):\n                    if statements[i][j] == 2: continue     # ignore is no statement was made\n                    if statements[i][j] != person[j]:      # if there is a contradiction, then valid = False\n                        valid = False\n                        break                              # optimization: break the loop when not valid\n                if not valid:                              # optimization: break the loop when not valid\n                    break        \n            if valid: \n                ans = max(ans, sum(person))                # count sum only when valid == True\n        return ans"}
{"prompt": "def findFinalValue(self, nums: List[int], original: int) -> int:\n\n    while original in nums:\n\t\n        original *= 2\n\t\t\n    return original"}
{"prompt": "def maxScoreIndices(self, nums: List[int]) -> List[int]:\n        ans = [0]\n        cand = most = nums.count(1)\n        for i, x in enumerate(nums): \n            if x == 0: cand += 1\n            elif x == 1: cand -= 1\n            if cand > most: ans, most = [i+1], cand\n            elif cand == most: ans.append(i+1)\n        return ans"}
{"prompt": "def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\n        pp = pow(power, k-1, modulo)\n        hs = ii = 0 \n        for i, ch in enumerate(reversed(s)): \n            if i >= k: hs -= (ord(s[~(i-k)]) - 96)*pp\n            hs = (hs * power + (ord(ch) - 96)) % modulo\n            if i >= k-1 and hs == hashValue: ii = i \n        return s[~ii:~ii+k or None]"}
{"prompt": "def minimumSum(self, num: int) -> int:\n        num = sorted(str(num),reverse=True)\n        n = len(num)    \n        res = 0\n        even_iteration = False\n        position = 0\n        for i in range(n):\n            res += int(num[i])*(10**position)\n            if even_iteration:\n                position += 1\n                even_iteration = False\n            else:\n                even_iteration = True\n        return res"}
{"prompt": "def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\n\n\t\tans=[]\n\n\t\tnums.remove(pivot)\n\n\t\ti=0\n\t\tans.append(pivot)\n\n\t\tfor j in nums:\n\t\t\tif j<pivot:\n\t\t\t\tans.insert(i,j)\n\t\t\t\ti=i+1\n\t\t\telif j==pivot:\n\t\t\t\tans.insert(i+1,j)\n\t\t\telse:\n\t\t\t\tans.append(j)\n\n\t\treturn ans"}
{"prompt": "def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\n        def count_cost(minutes, seconds): # Calculates cost for certain configuration of minutes and seconds\n            time = f'{minutes // 10}{minutes % 10}{seconds // 10}{seconds % 10}' # mm:ss\n            time = time.lstrip('0') # since 0's are prepended we remove the 0's to the left to minimize cost\n            t = [int(i) for i in time]\n            current = startAt\n            cost = 0\n            for i in t:\n                if i != current:\n                    current = i\n                    cost += moveCost\n                cost += pushCost\n            return cost\n        ans = float('inf')\n        for m in range(100): # Check which [mm:ss] configuration works out\n            for s in range(100):\n                if m * 60 + s == targetSeconds: \n                    ans = min(ans, count_cost(m, s))\n        return ans"}
{"prompt": "def minimumDifference(self, nums: List[int]) -> int:\n        n = len(nums) // 3\n\n        # calculate max_sum using min_heap for second part\n        min_heap = nums[(2 * n) :]\n        heapq.heapify(min_heap)\n\n        max_sum = [0] * (n + 2)\n        max_sum[n + 1] = sum(min_heap)\n        for i in range((2 * n) - 1, n - 1, -1):\n            # push current\n            heapq.heappush(min_heap, nums[i])\n            # popout minimum from heap\n            val = heapq.heappop(min_heap)\n            # max_sum for this partition\n            max_sum[i - n + 1] = max_sum[i - n + 2] - val + nums[i]\n\n\n        # calculate min_sum using max_heap for first part\n        max_heap = [-x for x in nums[:n]]\n        heapq.heapify(max_heap)\n\n        min_sum = [0] * (n + 2)\n        min_sum[0] = -sum(max_heap)\n        for i in range(n, (2 * n)):\n            # push current\n            heapq.heappush(max_heap, -nums[i])\n            # popout maximum from heap\n            val = -heapq.heappop(max_heap)\n            # min_sum for this partition\n            min_sum[i - n + 1] = min_sum[i - n] - val + nums[i]\n\n\n        # find min difference bw second part (max_sum) and first part (min_sum)\n        ans = math.inf\n        for i in range(0, n + 1):\n            print(i, min_sum[i], max_sum[i])\n            ans = min((min_sum[i] - max_sum[i + 1]), ans)\n\n        return ans"}
{"prompt": "def sortEvenOdd(self, nums: List[int]) -> List[int]:\n\t\tn = len(nums)\n\t\tfor i in range(0,n,2):\n\t\t\tfor j in range(i+2,n,2):\n\t\t\t\tif nums[i] > nums[j]:\n\t\t\t\t\tnums[i],nums[j] = nums[j], nums[i]\n\n\t\tfor i in range(1,n,2):\n\t\t\tfor j in range(i+2,n,2):\n\t\t\t\tif nums[i] < nums[j]:\n\t\t\t\t\tnums[i],nums[j] = nums[j], nums[i]\n\t\treturn nums"}
{"prompt": "def smallestNumber(self, num: int) -> int:\n        \n        if num == 0 : return 0 \n        snum = sorted(str(num))\n        if snum[0] == '-' :\n            return -int(\"\".join(snum[:0:-1]))\n        elif snum[0] == '0' :\n            x = snum.count('0')\n            return \"\".join([snum[x]]+['0'*x]+snum[x+1:])\n        else :\n            return \"\".join(snum)"}
{"prompt": "def minimumTime(self, s: str) -> int:\n        ans = inf \n        prefix = 0 \n        for i, ch in enumerate(s): \n            if ch == '1': prefix = min(2 + prefix, i+1)\n            ans = min(ans, prefix + len(s)-1-i)\n        return ans"}
{"prompt": "def countOperations(self, num1: int, num2: int) -> int:\n        ans = 0 \n        while num1 and num2: \n            ans += num1//num2\n            num1, num2 = num2, num1%num2\n        return ans"}
{"prompt": "def minimumOperations(self, nums: List[int]) -> int:\n        pad = lambda x: x + [(None, 0)]*(2-len(x))\n        even = pad(Counter(nums[::2]).most_common(2))\n        odd = pad(Counter(nums[1::2]).most_common(2))\n        return len(nums) - (max(even[0][1] + odd[1][1], even[1][1] + odd[0][1]) if even[0][0] == odd[0][0] else even[0][1] + odd[0][1])"}
{"prompt": "def minimumRemoval(self, beans: List[int]) -> int:\n        beans.sort()\n        return sum(beans) - max((len(beans)-i)*x for i, x in enumerate(beans))"}
{"prompt": "def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\n        \n        @cache\n        def fn(k, m): \n            \"\"\"Return max AND sum.\"\"\"\n            if k == len(nums): return 0 \n            ans = 0 \n            for i in range(numSlots): \n                if m &amp; 1<<2*i == 0 or m &amp; 1<<2*i+1 == 0: \n                    if m &amp; 1<<2*i == 0: mm = m ^ 1<<2*i\n                    else: mm = m ^ 1<<2*i+1\n                    ans = max(ans, (nums[k] &amp; i+1) + fn(k+1, mm))\n            return ans \n        \n        return fn(0, 0)"}
{"prompt": "def countPairs(self, nums: List[int], k: int) -> int:\n        n=len(nums)\n        c=0\n        for i in range(0,n):\n            for j in range(i+1,n):\n                if nums[i]==nums[j] and ((i*j)%k==0):\n                    c+=1\n        return c"}
{"prompt": "def sumOfThree(self, num: int) -> List[int]:\n        return [] if num % 3 else [num//3-1, num//3, num//3+1]"}
{"prompt": "def maximumEvenSplit(self, finalSum: int) -> List[int]:\n        l=set()\n        if finalSum%2!=0:\n            return l\n        else:\n            s=0\n            i=2                       # even pointer 2, 4, 6, 8, 10, 12...........\n            while(s<finalSum):\n                s+=i                #sum \n                l.add(i)      # append the i in list\n                i+=2\n            if s==finalSum:  #if sum s is equal to finalSum then no modidfication required\n                return l\n            else:\n                l.discard(s-finalSum)  #Deleting the element which makes s greater than finalSum\n\t\t\t\treturn l"}
{"prompt": "def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        hashmap2 = {}\n        for i in range(n):\n            hashmap2[nums2[i]] = i\n        indices = []\n        for num in nums1:\n            indices.append(hashmap2[num])\n        from sortedcontainers import SortedList\n        left, right = SortedList(), SortedList()\n        leftCount, rightCount = [], []\n        for i in range(n):\n            leftCount.append(left.bisect_left(indices[i]))\n            left.add(indices[i])\n        for i in range(n - 1, -1, -1):\n            rightCount.append(len(right) - right.bisect_right(indices[i]))\n            right.add(indices[i])\n        count = 0\n        for i in range(n):\n            count += leftCount[i] * rightCount[n - 1 - i]\n        return count"}
{"prompt": "def countEven(self, num: int) -> int:\n        return num // 2 if sum([int(k) for k in str(num)]) % 2 == 0 else (num - 1) // 2"}
{"prompt": "def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        d=ListNode(0)\n        t=0\n        r=ListNode(0,d)\n        while head:\n            if head.val!=0:\n                t+=head.val\n            else:\n                print(t)\n                if t!=0:\n                    d.next=ListNode(t)\n                    d=d.next\n                    t=0\n            head=head.next\n        return r.next.next"}
{"prompt": "def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\n        pq = [(-ord(k), v) for k, v in Counter(s).items()] \n        heapify(pq)\n        ans = []\n        while pq: \n            k, v = heappop(pq)\n            if ans and ans[-1] == k: \n                if not pq: break \n                kk, vv = heappop(pq)\n                ans.append(kk)\n                if vv-1: heappush(pq, (kk, vv-1))\n                heappush(pq, (k, v))\n            else: \n                m = min(v, repeatLimit)\n                ans.extend([k]*m)\n                if v-m: heappush(pq, (k, v-m))\n        return \"\".join(chr(-x) for x in ans)"}
{"prompt": "def coutPairs(self, nums: List[int], k: int) -> int:\n        factors = []\n        for x in range(1, int(sqrt(k))+1):\n            if k % x == 0: factors.append(x)\n        ans = 0 \n        freq = Counter()\n        for x in nums: \n            x = gcd(x, k)\n            ans += freq[k//x]\n            for f in factors: \n                if x % f == 0 and f <= x//f: \n                    freq[f] += 1\n                    if f < x//f: freq[x//f] += 1\n        return ans"}
{"prompt": "def prefixCount(self, words: List[str], pref: str) -> int:\n        return sum(word.find(pref) == 0 for word in words)"}
{"prompt": "def minSteps(self, s: str, t: str) -> int:\n        fs, ft = Counter(s), Counter(t)\n        return sum((fs-ft).values()) + sum((ft-fs).values())"}
{"prompt": "def minimumTime(self, time: List[int], totalTrips: int) -> int:\n        r = min(time) * totalTrips + 1 # This is the worst case answer possible for any case. Could use big values like 10^15 as well but they might slow the time down for smaller cases.\n        l = 0\n        ans = 0\n\n        def check_status(expected_time: int) -> int:\n            nonlocal ans\n            count = 0\n            for i in time:\n                count += expected_time // i # Total trips with time expected_time should be integer part of expected_time // i\n            if count < totalTrips:\n                return 1 # Since number of trips are less then required, left moves to mid\n            elif count >= totalTrips:\n                ans = expected_time # stores the latest result. This is guaranteed to be the minimum possible answer.\n                return -1 # Since number of trips are greater/equal to required, right moves to mid\n\n        while l < r-1: # Till Binary Search can continue. \n            mid = (l + r) // 2 # mid is the current expected time.\n            status = check_status(mid) # The return values 1/-1 in check_status function determines which pointer to move.\n            if status == 1:\n                l = mid\n            else:\n                r = mid\n                \n        return ans"}
{"prompt": "def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\n        tires.sort()\n        newTires = []\n        minTime = [changeTime*(i-1) + tires[0][0]*i for i in range(numLaps+1)]\n        minTime[0] = 0\n        maxi = 0\n        for f,r in tires:\n            if not newTires or f>newTires[-1][0] and r<newTires[-1][1]:\n                newTires.append([f,r])\n                t = f\n                i = 1\n                while i<numLaps and t*(r-1)<changeTime:\n                    t = t*r + f\n                    i += 1\n                    if minTime[i]>t:\n                        minTime[i]=t\n                        maxi = max(i,maxi)\n        for lap in range(numLaps+1):\n            for run in range(min(lap,maxi+1)):\n                minTime[lap] = min(minTime[lap],minTime[lap-run]+changeTime+minTime[run])\n        return minTime[numLaps]"}
{"prompt": "def mostFrequent(self, nums, key):\n        counts = {}\n        \n        for i in range(1,len(nums)):\n            if nums[i-1]==key:\n                if nums[i] not in counts: counts[nums[i]] = 1\n                else: counts[nums[i]] += 1\n        \n        return max(counts, key=counts.get)"}
{"prompt": "def sortJumbled(self, mapping: List[int], nums: List[int]) -> List[int]:\n        @cache\n        def convert(i: int):\n            res, pow10 = 0, 1\n            while i:\n                res += pow10 * mapping[i % 10]\n                i //= 10\n                pow10 *= 10\n            return res\n        return sorted(nums, key=lambda i: mapping[i] if i < 10 else convert(i))"}
{"prompt": "def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n        #Use Kahn's algorithm of toposort using a queue and bfs!\n        graph = [[] for _ in range(n)]\n        indegrees = [0] * n\n        \n        #Time: O(n^2)\n        #Space: O(n^2 + n + n) -> O(n^2)\n        \n        #1st step: build adjacency list grpah and update the initial indegrees of every node!\n        for edge in edges:\n            src, dest = edge[0], edge[1]\n            graph[src].append(dest)\n            indegrees[dest] += 1\n        \n        \n        queue = deque()\n        ans = [set() for _ in range(n)]\n        #2nd step: go through the indegrees array and add to queue for any node that has no ancestor!\n        for i in range(len(indegrees)):\n            if(indegrees[i] == 0):\n                queue.append(i)\n        \n        #Kahn's algorithm initiation!\n        #while loop will run for each and every node in graph!\n        #in worst case, adjacency list for one particular node may contain all other vertices!\n        while queue:\n            cur = queue.pop()\n            \n            #for each neighbor\n            for neighbor in graph[cur]:\n                #current node is ancestor to each and every neighboring node!\n                ans[neighbor].add(cur)\n                #every ancestor of current node is also an ancestor to the neighboring node!\n                ans[neighbor].update(ans[cur])\n                indegrees[neighbor] -= 1\n                if(indegrees[neighbor] == 0):\n                    queue.append(neighbor)\n        \n        #at the end, we should have set of ancestors for each and every node!\n        #in worst case, set s for ith node could have all other vertices be ancestor to node i !\n        ans = [(sorted(list(s))) for s in ans]\n        return ans"}
{"prompt": "def minMovesToMakePalindrome(self, s: str) -> int:\n        ans = 0 \n        while len(s) > 2: \n            lo = s.find(s[-1])\n            hi = s.rfind(s[0])\n            if lo < len(s)-hi-1: \n                ans += lo \n                s = s[:lo] + s[lo+1:-1]\n            else: \n                ans += len(s)-hi-1\n                s = s[1:hi] + s[hi+1:]\n        return ans"}
{"prompt": "def cellsInRange(self, s: str) -> List[str]:\n        return [chr(c)+str(r) for c in range(ord(s[0]), ord(s[3])+1) for r in range(int(s[1]), int(s[4])+1)]"}
{"prompt": "def minimalKSum(self, nums: List[int], k: int) -> int:\n        ans = k*(k+1)//2\n        prev = -inf \n        for x in sorted(nums): \n            if prev < x: \n                if x <= k: \n                    k += 1\n                    ans += k - x\n                else: break\n                prev = x\n        return ans"}
{"prompt": "def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:\n        mp = {}\n        seen = set()\n        for p, c, left in descriptions: \n            if p not in mp: mp[p] = TreeNode(p)\n            if c not in mp: mp[c] = TreeNode(c)\n            if left: mp[p].left = mp[c]\n            else: mp[p].right = mp[c]\n            seen.add(c)\n        for p, _, _ in descriptions: \n            if p not in seen: return mp[p]"}
{"prompt": "def replaceNonCoprimes(self, nums: List[int]) -> List[int]:       \n\n        stack = nums[:1]\n        \n        for j in range(1, len(nums)):\n            cur = nums[j]\n            while stack and math.gcd(stack[-1], cur) > 1:\n                prev = stack.pop()\n                cur = math.lcm(prev, cur)\n            stack.append(cur)            \n               \n        return stack"}
{"prompt": "def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:\n        ind_j = []\n        for ind, elem in enumerate(nums):\n            if elem == key:\n                ind_j.append(ind)\n        res = []\n        for i in range(len(nums)):\n            for j in ind_j:\n                if abs(i - j) <= k:\n                    res.append(i)\n                    break\n        return sorted(res)"}
{"prompt": "def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\n\t    # Time: O(max(artifacts, dig)) which is O(N^2) as every position in the grid can be in dig\n\t\t# Space: O(dig) which is O(N^2)\n        result, dig_pos = 0, set(tuple(pos) for pos in dig)\n        for pos in artifacts:\n            if all((x, y) in dig_pos for x in range(pos[0], pos[2] + 1) for y in range(pos[1], pos[3] + 1)):     \n                result += 1\n        return result"}
{"prompt": "def maximumTop(self, nums: List[int], k: int) -> int:\n        if len(nums) == 1:\n            if k%2 != 0:\n                return -1\n            return nums[0]\n        \n        if k == 0:\n            return nums[0]\n        if k == len(nums):\n            return max(nums[:-1])\n        if k > len(nums):\n            return max(nums)\n        if k == 1:\n            return nums[1]\n        m = max(nums[:k-1])\n        m = max(m, nums[k])\n        return m"}
{"prompt": "def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\n        forward, backward = dict(), dict()\n        for start, end, weight in edges:\n            if start in forward:\n                if end in forward[start]:\n                    forward[start][end] = min(weight, forward[start][end])\n                else:\n                    forward[start][end] = weight\n            else:\n                forward[start] = {end: weight}\n            if end in backward:\n                if start in backward[end]:\n                    backward[end][start] = min(weight, backward[end][start])\n                else:\n                    backward[end][start] = weight\n            else:\n                backward[end] = {start: weight}\n\n        def travel(origin: int, relations: dict, costs: list) -> None:\n            level = {origin}\n            costs[origin] = 0\n            while level:\n                new_level = set()\n                for node in level:\n                    if node in relations:\n                        for next_node, w in relations[node].items():\n                            if w + costs[node] < costs[next_node]:\n                                new_level.add(next_node)\n                                costs[next_node] = w + costs[node]\n                level = new_level\n\n        from_src1 = [inf] * n\n        from_src2 = [inf] * n\n        from_dest = [inf] * n\n\n        travel(src1, forward, from_src1)\n        travel(src2, forward, from_src2)\n        travel(dest, backward, from_dest)\n\n        combined_cost = min(sum(tpl)\n                            for tpl in zip(from_src1, from_src2, from_dest))\n\n        return combined_cost if combined_cost < inf else -1"}
{"prompt": "def divideArray(self, nums: List[int]) -> bool:\n        lena = len(nums)\n        count = sum(num//2 for num in Counter(nums).values())\n        return (lena/2 == count)"}
{"prompt": "def maximumSubsequenceCount(self, string: str, pattern: str) -> int:\n\n        text = pattern[0]+string\n        text1 = string + pattern[1]\n        cnt,cnt1 = 0,0\n        ans,ans1 = 0,0\n        \n        for i in range(len(text)):\n            if text[i] == pattern[0]:\n                cnt+=1\n            elif text[i] == pattern[1]:\n                ans+= cnt\n        if pattern[0] == pattern[1]:\n            ans = ((cnt)*(cnt-1))//2\n        # appending at the last \n        for i in range(len(text1)):\n            if text1[i] == pattern[0]:\n                cnt1+=1\n            elif text1[i] == pattern[1]:\n                ans1+= cnt1\n        if pattern[0] == pattern[1]:\n            ans1 = ((cnt1)*(cnt1-1))//2\n        return max(ans1,ans)"}
{"prompt": "def halveArray(self, nums: List[int]) -> int:\n        s = sum(nums)\n        goal = s / 2\n        res = 0\n        \n        for i, num in enumerate(nums):\n            nums[i] = -num\n        heapq.heapify(nums)\n        \n        while s > goal:\n            halfLargest = -heapq.heappop(nums) / 2\n            s -= halfLargest\n            heapq.heappush(nums, -halfLargest)\n            res += 1\n        \n        return res"}
{"prompt": "def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\n        \n        @cache\n        def fn(i, n):\n            \"\"\"Return min while tiles at k with n carpets left.\"\"\"\n            if n < 0: return inf \n            if i >= len(floor): return 0 \n            if floor[i] == '1': return min(fn(i+carpetLen, n-1), 1 + fn(i+1, n))\n            return fn(i+1, n)\n        \n        return fn(0, numCarpets)"}
{"prompt": "def countHillValley(self, nums: List[int]) -> int:\n        \n        #cnt: An integer to store total hills and valleys\n        #left: Highest point of hill or lowest point of valley left of the current index\n        cnt, left = 0, nums[0]\n        \n        for i in range(1, len(nums)-1):\n            if (left<nums[i] and nums[i]>nums[i+1]) or (left>nums[i] and nums[i]<nums[i+1]):\n                cnt+=1\n                left=nums[i]\n        return cnt"}
{"prompt": "def countCollisions(self, directions: str) -> int:\n        return sum(d!='S' for d in directions.lstrip('L').rstrip('R'))"}
{"prompt": "def maximumBobPoints(self, numArrows: int, aliceArrows: List[int]) -> List[int]:\n        \n        # Initialization with round 1 (round 0 is skipped)\n        dp = {(0, 0): (0, numArrows), (0, aliceArrows[1] + 1): (1, numArrows - (aliceArrows[1] + 1))}\n        \n        # Loop from round 2\n        for i in range(2, 12):\n            prev = dp\n            dp = {}\n            \n            # Consider two possible strategies for each state from last round: to bid and not to bid\n            for key in prev:\n                \n                # Base case: not to bid in this round. Score and arrows left do not change.\n                # Simply append 0 at the end to the key.\n                newkey1 = list(key)\n                newkey1.append(0)\n                score, arrowleft = prev[key]\n                \n                newval1 = (score, arrowleft)\n                dp[tuple(newkey1)] = newval1\n                \n                # If we still have enough arrows, we can bid in this round\n                if arrowleft >= aliceArrows[i] + 1:\n                    newkey2 = list(key)\n                    newkey2.append(aliceArrows[i] + 1)\n                    newval2 = (score + i, arrowleft - (aliceArrows[i] + 1))\n                    dp[tuple(newkey2)] = newval2\n        \n        # Select the bidding history with max score\n        maxscore, res = 0, None\n        for key in dp:\n            score, _ = dp[key]\n            if score > maxscore:\n                maxscore = score\n                res = list(key)\n        \n        # Taking care of the corner case, where too many arrows are given\n        if sum(res) < numArrows:\n            res[0] = numArrows - sum(res)\n        \n        return res"}
{"prompt": "def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\n        \n        set_1 = list_to_set(nums1)\n        set_2 = list_to_set(nums2)\n        \n        return remove_same_elements(set_1, set_2)\n                \n# Convert the lists into sets via helper method.      \ndef list_to_set(arr: List[int]):\n    \n    s = set()\n    \n    for i in arr:\n        s.add(i)\n        \n    return s   \n\n# Now when the two lists are sets, use the difference attribute to filter common elements of the two sets.\ndef remove_same_elements(x, y):\n    \n    x, y = list(x - y), list(y - x)\n        \n    return [x, y]\n\n\n# Runtime: 185 ms, faster than 95.96% of Python3 online submissions for Find the Difference of Two Arrays.\n# Memory Usage: 14.3 MB, less than 51.66% of Python3 online submissions for Find the Difference of Two Arrays.\n\n# If you like my work, then I'll appreciate a like. Thanks!"}
{"prompt": "def minDeletion(self, nums: List[int]) -> int:\n        # Greedy !\n        # we first only consider requirement 2: nums[i] != nums[i + 1] for all i % 2 == 0\n        # at the begining, we consider the num on the even index\n        # when we delete a num, we need consider the num on the odd index\n        # then repeat this process\n        # at the end we check the requirement 1: nums.length is even or not\n        \n        n = len(nums)\n        count = 0\n        # flag is true then check the even index\n        # flag is false then check the odd index\n        flag = True\n        \n        for i in range(n):\n            # check the even index\n            if flag:\n                if i % 2 == 0 and i != n -1 and nums[i] == nums[i + 1]:\n                    count += 1\n                    flag = False\n            # check the odd index\n            elif not flag:\n                if i % 2 == 1 and i != n -1 and nums[i] == nums[i + 1]:\n                    count += 1\n                    flag = True\n        \n        curLength = n - count\n        \n        return count if curLength % 2 == 0 else count + 1"}
{"prompt": "def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\n        # think the palindromes in half\n        # e.g. len  = 4 we only consider the first 2 digits\n        # half: 10, 11, 12, 13, 14, ..., 19, 20, \n        # full: 1001, 1111, 1221, 1331, ...\n        # e.g. len = 5 we consider the first 3 digits\n        # half: 100, 101, 102, ...\n        # full: 10001, 10101, 10201, ...\n        \n        result = []\n        \n        for i in queries:\n            result.append(self.generatePalindrome(intLength, i))\n        \n        return result\n    \n    def generatePalindrome(self, length, num):\n        # index start from 0\n\t\t# e.g. num =1 means we want to find the most smallest palindrome, then its index is 0\n\t\t# e.g. num =2 means we want to find the second most smallest palindrome, then its index is 1\n        index = num -1\n        \n\t\t# if the length is even\n\t\t# we only think about the fisrt half of digits\n        if length % 2 == 0:\n            cur = int('1' + '0' * (length // 2 -1))\n            maxLength = len(str(cur))\n            cur += index\n            \n            if len(str(cur)) > maxLength:\n                return -1\n            \n            else:\n                cur = str(cur)\n                cur = cur + cur[::-1]\n                cur = int(cur)\n                return cur\n\t\t\t\t\n        # if the length is odd\n\t\t# we consider first (length // 2 + 1) digits\n        else:\n            cur = int('1' + '0' * (length // 2))\n            maxLength = len(str(cur))\n            cur += index\n            \n            if len(str(cur)) > maxLength:\n                return -1\n            \n            else:\n                cur = str(cur)\n                temp = str(cur)[:-1]\n                cur = cur + temp[::-1]\n                cur = int(cur)\n                return cur"}
{"prompt": "def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\n        n, m = len(piles), 0\n        prefixSum = []\n        for i in range(n):\n            temp = [0]\n            for j in range(len(piles[i])):\n                temp.append(temp[-1] + piles[i][j])\n                m += 1\n            prefixSum.append(temp)\n        if m == k:\n            return sum(temp[-1] for temp in prefixSum)\n            \n        dp = [[0] * (k + 1) for _ in range(n)]\n        for j in range(1, k + 1):\n            if j < len(prefixSum[0]):\n                dp[0][j] = prefixSum[0][j]\n        \n        for i in range(1, n):\n            for j in range(1, k + 1):\n                for l in range(len(prefixSum[i])):\n                    if l > j:\n                        break\n                    dp[i][j] = max(dp[i][j], prefixSum[i][l] + dp[i - 1][j - l])\n        return dp[n - 1][k]"}
{"prompt": "def minBitFlips(self, s: int, g: int) -> int:\n        count = 0\n        while s or g:\n            if s%2 != g%2: count+=1\n            s, g = s//2, g//2\n        return count"}
{"prompt": "def triangularSum(self, nums: List[int]) -> int:\n        return sum(n * comb(len(nums) - 1, i) for i, n in enumerate(nums)) % 10"}
{"prompt": "def numberOfWays(self, s: str) -> int:\n        zeros = s.count('0')\n        ones = len(s) - zeros\n        zeroPrefix = onePrefix = res = 0\n        for c in s:\n            if c == '0':\n                res += onePrefix * (ones - onePrefix)\n                zeroPrefix += 1\n            else:\n                res += zeroPrefix * (zeros - zeroPrefix)\n                onePrefix += 1\n        \n        return res"}
{"prompt": "def sumScores(self, s: str) -> int:\n        mod = 119_218_851_371\n        hs = 0 \n        vals = [0]\n        for i, ch in enumerate(s): \n            hs = (hs * 26 + ord(ch) - 97) % mod\n            vals.append(hs)\n        \n        p26 = [1]\n        for _ in range(len(s)): p26.append(p26[-1] * 26 % mod)\n        \n        ans = 0 \n        for i in range(len(s)): \n            if s[0] == s[i]: \n                lo, hi = i, len(s)\n                while lo < hi: \n                    mid = lo + hi + 1 >> 1\n                    hs = (vals[mid] - vals[i]*p26[mid-i]) % mod\n                    if hs == vals[mid-i]: lo = mid\n                    else: hi = mid - 1\n                ans += lo - i \n        return ans"}
{"prompt": "def convertTime(self, current: str, correct: str) -> int:\n        current_time = 60 * int(current[0:2]) + int(current[3:5]) # Current time in minutes\n        target_time = 60 * int(correct[0:2]) + int(correct[3:5]) # Target time in minutes\n        diff = target_time - current_time # Difference b/w current and target times in minutes\n        count = 0 # Required number of operations\n\t\t# Use GREEDY APPROACH to calculate number of operations\n        for i in [60, 15, 5, 1]:\n            count += diff // i # add number of operations needed with i to count\n            diff %= i # Diff becomes modulo of diff with i\n        return count"}
{"prompt": "def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\n        winners, losers, table = [], [], {}\n        for winner, loser in matches:\n            # map[key] = map.get(key, 0) + change . This format ensures that KEY NOT FOUND error is always prevented.\n            # map.get(key, 0) returns map[key] if key exists and 0 if it does not.\n            table[winner] = table.get(winner, 0)  # Winner\n            table[loser] = table.get(loser, 0) + 1\n        for k, v in table.items(): # Player k with losses v\n            if v == 0:\n                winners.append(k) # If player k has no loss ie v == 0\n            if v == 1:\n                losers.append(k) # If player k has one loss ie v == 1\n        return [sorted(winners), sorted(losers)] # Problem asked to return sorted arrays."}
{"prompt": "def maximumCandies(self, candies, k):\n        n = len(candies)\n        left = 1  # the least number of candy in each stack we can give to each student is one\n        right = max(candies)  # the max number of candy in each stack that we can give to each student is the maximum number in the candies array\n        ans = 0 # ans here is used to store the maximum amount in each stack that we can give to each children. \n               # If we don't have enough to distribute, we will return 0 at the end so we initialize it to be 0 now.\n\n        while left <= right:  # binary search\n            numberOfPiles = 0\n            mid = (left) + (right - left) // 2  # the number of candies we require to form a stack\n\n            for i in range(n):   # loop through the array to find the numbers of stack we can form\n                numberOfPiles += candies[i] // mid   # we add to the numberOfPiles whenever we find that this current stack (candies[i]) can be split into mid (the number of candies we require to form a stack)\n\n            if numberOfPiles >= k: # if our number of piles is greater or equal than the students we have, so we have enough to distribute\n                ans = max(ans, mid)   # we first store the max no. of candies in each stack that we can give to each student \n                left = mid + 1      # we will try to increase the number of candies in each stack that we can give to each student\n            else: \n                right = mid - 1   # we will try to reduce the number of candies in each stack that we can give to each student\n        return ans"}
{"prompt": "def largestInteger(self, num: int):\n        n = len(str(num))\n        arr = [int(i) for i in str(num)]\n        odd, even = [], []\n        for i in arr:\n            if i % 2 == 0:\n                even.append(i)\n            else:\n                odd.append(i)\n        odd.sort()\n        even.sort()\n        res = 0\n        for i in range(n):\n            if arr[i] % 2 == 0:\n                res = res*10 + even.pop()\n            else:\n                res = res*10 + odd.pop()\n        return res"}
{"prompt": "def minimizeResult(self, expression: str) -> str:\n        plus_index, n, ans = expression.find('+'), len(expression), [float(inf),expression] \n        def evaluate(exps: str):\n            return eval(exps.replace('(','*(').replace(')', ')*').lstrip('*').rstrip('*'))\n        for l in range(plus_index):\n            for r in range(plus_index+1, n):\n                exps = f'{expression[:l]}({expression[l:plus_index]}+{expression[plus_index+1:r+1]}){expression[r+1:n]}'\n                res = evaluate(exps)\n                if ans[0] > res:\n                    ans[0], ans[1] = res, exps\n        return ans[1]"}
{"prompt": "def maximumProduct(self, nums: List[int], k: int) -> int:\n        heap = nums.copy()\n        heapify(heap)\n        for i in range(k):\n            t = heappop(heap)\n            heappush(heap, t + 1)\n        ans = 1\n        mod = 1000000007\n        for i in heap:\n            ans = (ans*i) % mod\n        return ans"}
{"prompt": "def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\n        flowers = sorted(min(target, x) for x in flowers)\n        prefix = [0]\n        ii = -1 \n        for i in range(len(flowers)): \n            if flowers[i] < target: ii = i \n            if i: prefix.append(prefix[-1] + (flowers[i]-flowers[i-1])*i)\n        ans = 0 \n        for k in range(len(flowers)+1): \n            if k: newFlowers -= target - flowers[-k]\n            if newFlowers >= 0: \n                while 0 <= ii and (ii+k >= len(flowers) or prefix[ii] > newFlowers): ii -= 1\n                if 0 <= ii: kk = min(target-1, flowers[ii] + (newFlowers - prefix[ii])//(ii+1))\n                else: kk = 0 \n                ans = max(ans, k*full + kk*partial)\n        return ans"}
{"prompt": "def sum(self, num1: int, num2: int) -> int:\n        return num1 + num2"}
{"prompt": "def checkTree(self, root: Optional[TreeNode]) -> bool:\n        return root.left.val+root.right.val == root.val"}
{"prompt": "def findClosestNumber(self, nums: List[int]) -> int:\n        m = 10 ** 6\n        for i in nums:\n            x = abs(i-0)\n            if x < m:\n                m = x\n                val = i\n            elif x == m and val < i:\n                val = i\n        return val"}
{"prompt": "def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\n        if total < cost1 and total < cost2:\n            return 1\n        ways = 0\n        if cost1 > cost2:\n            for i in range(0, (total // cost1)+1):\n                rem = total - (i * cost1)\n                ways += (rem // cost2) + 1\n            return ways\n        for i in range(0, (total // cost2)+1):\n            rem = total - (i * cost2)\n            ways += (rem // cost1) + 1\n        return ways"}
{"prompt": "def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n      \n      connection = {}\n      \n      for source, target in edges:\n        if source not in connection: connection[source] = [target]\n        else: connection[source].append(target)\n          \n        if target not in connection: connection[target] = [source]\n        else: connection[target].append(source)\n          \n      res = -1\n      \n      max_dict = {}\n      for key, value in connection.items():\n        max1, max2, max3 = -sys.maxsize, -sys.maxsize, -sys.maxsize\n        n1, n2, n3 = None, None, None\n        for element in value:\n          if scores[element] > max1:\n            max1, max2, max3 = scores[element], max1, max2\n            n1, n2, n3 = element, n1, n2\n          elif scores[element] > max2:\n            max2, max3 = scores[element], max2\n            n2, n3 = element, n2\n          elif scores[element] > max3:\n            max3 = scores[element]\n            n3 = element\n        max_dict[key] = []\n        if n1 != None: max_dict[key].append(n1)\n        if n2 != None: max_dict[key].append(n2)\n        if n3 != None: max_dict[key].append(n3)\n             \n      for source, target in edges:\n        base = scores[source] + scores[target]\n        \n        n_s = max_dict[source]\n        n_t = max_dict[target]\n        if len(n_s) == 1 or len(n_t) == 1:\n          pass\n        else:\n          new_n_s = [x for x in n_s if x != target]\n          new_n_t = [x for x in n_t if x != source]\n          if new_n_s[0] != new_n_t[0]:\n            res = max(res, base + scores[new_n_s[0]] + scores[new_n_t[0]])\n          else:\n            if len(new_n_s) > 1:\n              res = max(res, base + scores[new_n_s[1]] + scores[new_n_t[0]])\n            if len(new_n_t) > 1:\n              res = max(res, base + scores[new_n_s[0]] + scores[new_n_t[1]])      \n    \n      return res"}
{"prompt": "def digitSum(self, s: str, k: int) -> str:\n        while len(s) > k:\n            set_3 = [s[i:i+k] for i in range(0, len(s), k)]\n            s = ''\n            for e in set_3:\n                val = 0\n                for n in e:\n                    val += int(n)\n                s += str(val)\n        return s"}
{"prompt": "def minimumRounds(self, tasks: List[int]) -> int:\n        table, res = Counter(tasks), 0 # Counter to hold frequency of ith task and res stores the result.\n        for count in table.values():\n            if count <= 1: return -1 # If count <= 1 then it cannot follow the condition hence return -1.\n            res += ceil(count / 3) # Total number of groups increments after 3 values. \n        return res"}
{"prompt": "def maxTrailingZeros(self, grid: List[List[int]]) -> int:\n        ans = 0\n        m, n = len(grid), len(grid[0])\n        prefixH = [[[0] * 2 for _ in range(n + 1)] for __ in range(m)]\n        prefixV = [[[0] * 2 for _ in range(n)] for __ in range(m + 1)]\n        for i in range(m):\n            for j in range(n):\n                temp= grid[i][j]\n                while temp % 2 == 0:\n                    prefixH[i][j + 1][0] += 1\n                    prefixV[i + 1][j][0] += 1\n                    temp //= 2\n                while temp % 5 == 0:\n                    prefixH[i][j + 1][1] += 1\n                    prefixV[i + 1][j][1] += 1\n                    temp //= 5\n                for k in range(2):\n                    prefixH[i][j + 1][k] += prefixH[i][j][k]\n                    prefixV[i + 1][j][k] += prefixV[i][j][k]\n        for i in range(m):\n            for j in range(n):\n                left = prefixH[i][j]\n                up = prefixV[i][j]\n                right, down, center = [0] * 2, [0] * 2, [0] * 2\n                for k in range(2):\n                    right[k] = prefixH[i][n][k] - prefixH[i][j + 1][k]\n                    down[k] = prefixV[m][j][k] - prefixV[i + 1][j][k]\n                    center[k] = prefixH[i][j + 1][k] - prefixH[i][j][k]\n                LU, LD, RU, RD = [0] * 2, [0] * 2, [0] * 2, [0] * 2\n                for k in range(2):\n                    LU[k] += left[k] + up[k] + center[k]\n                    LD[k] += left[k] + down[k] + center[k]\n                    RU[k] += right[k] + up[k] + center[k]\n                    RD[k] += right[k] + down[k] + center[k]\n                ans = max(ans,\n                          min(LU[0], LU[1]),\n                          min(LD[0], LD[1]),\n                          min(RU[0], RU[1]),\n                          min(RD[0], RD[1]))\n        return ans"}
{"prompt": "def longestPath(self, par: List[int], s: str) -> int:\n        dit = {}\n        # store tree in dictionary\n        for i in range(len(par)):\n            if par[i] in dit:\n                dit[par[i]].append(i)\n            else:\n                dit[par[i]] = [i]\n                \n        ans = 1        \n        def dfs(n):\n            nonlocal ans\n            if n not in dit:\n                return 1\n            \n            largest=0 # largest path lenght among all children\n            second_largest=0 # second largest path lenght among all children\n            for u in dit[n]:\n                curr = dfs(u)\n                if s[u]!=s[n]: # pick child path if child and parent both have different value\n                    if curr>largest:\n                        second_largest = largest\n                        largest = curr\n                    elif curr>second_largest:\n                        second_largest = curr\n                        \n            ans = max(ans,largest+second_largest+1) # largest path including parent with at most two children \n            \n            return largest+1  # return largest path end at parent\n        \n        dfs(0)\n        return ans\n        ```"}
{"prompt": "def intersection(self, nums: List[List[int]]) -> List[int]:\n        res = set(nums[0])\n        for i in range(1, len(nums)):\n            res &amp;= set(nums[i])\n        res = list(res)\n        res.sort()\n        return res"}
{"prompt": "def countLatticePoints(self, circles: List[List[int]]) -> int:\n        points = set()\n        for x, y, r in circles:\n            for dx in range(-r, r + 1, 1):\n                temp = math.floor(math.sqrt(r ** 2 - dx ** 2))\n                for dy in range(-temp, temp + 1):\n                    points.add((x + dx, y + dy))\n        return len(points)"}
{"prompt": "def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:\n        mp = defaultdict(list)\n        for l, h in rectangles: mp[h].append(l)\n        for v in mp.values(): v.sort()\n        ans = []\n        for x, y in points: \n            cnt = 0 \n            for yy in range(y, 101): \n                if yy in mp: cnt += len(mp[yy]) - bisect_left(mp[yy], x)\n            ans.append(cnt)\n        return ans"}
{"prompt": "def fullBloomFlowers(self, flowers: List[List[int]], persons: List[int]) -> List[int]:\n        start, end, res = [], [], []\n        for i in flowers:\n            start.append(i[0])\n            end.append(i[1])\n        start.sort() #bisect only works with sorted data\n        end.sort()\n\n        for p in persons:\n            num = bisect_right(start, p) - bisect_left(end, p)\n            res.append(num)\n        return res\n#bisect_right(start, p) gives you the number of flowers that are in full bloom at person p.\n#bisect_left(end, p) gives you number of flowers that are not in full bloom at person p.\n#we have to tighten our bound to get exact number of flowers that are in bloom or not, thats why we are using right and left of bisect module."}
{"prompt": "def countPrefixes(self, words: List[str], s: str) -> int:\n        count=0\n        for i in words:\n            if (s[:len(i)]==i):\n                count+=1\n        return count"}
{"prompt": "def minimumAverageDifference(self, a: List[int]) -> int:\n        l=0\n        r=sum(a)\n        z=100001\n        y=0\n        n=len(a)\n        \n        for i in range(n-1):\n            l+=a[i]\n            r-=a[i]\n        \n            d=abs((l//(i+1))-(r//(n-i-1)))\n            if d<z:\n                z=d\n                y=i\n        \n        if sum(a)//n<z:\n            y=n-1\n        \n        return y"}
{"prompt": "def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\n        vis = [[0]*n for _ in range(m)]\n        # i - rows, j - colums\n        # sum(row.count('hit') for row in grid)\n        for i,j in walls:\n            vis[i][j] = 2\n        for i,j in guards:\n            vis[i][j] = 2\n        for i,j in guards:\n            for l in range(j-1,-1,-1):\n                if self.checkWall(i,l,vis):\n                    break    \n                vis[i][l] = 1\n            for r in range(j+1,n):\n                if self.checkWall(i,r,vis):\n                    break\n                vis[i][r] = 1\n            for u in range(i-1,-1,-1):\n                if self.checkWall(u,j,vis):\n                    break\n                vis[u][j] = 1\n            for d in range(i+1,m):\n                if self.checkWall(d,j, vis):\n                    break\n                vis[d][j] = 1\n        return sum(row.count(0) for row in vis)\n        \n    def checkWall(self, i, j, vis):\n        if vis[i][j] ==2:\n            return True"}
{"prompt": "def maximumMinutes(self, grid: List[List[int]]) -> int:\n      \n      #region growing to assign each grass with the time that it will catch fire\n      \n      m, n = len(grid), len(grid[0])\n      \n      start = []\n      \n      for i in range(m):\n        for j in range(n):\n          if grid[i][j] == 1:\n            start.append([i,j])\n            grid[i][j] = 'F'\n          elif grid[i][j] == 2:\n            grid[i][j] = 'W'\n            \n      visited = set()\n      for element in start: visited.add(tuple(element))\n        \n      time = 1\n      \n      while start:\n        new_start = []\n        for x, y in start:\n          if x >= 1:\n            if grid[x-1][y] == 0 and (x-1, y) not in visited:\n              new_start.append([x-1, y])\n              visited.add((x-1, y))\n              grid[x-1][y] = time\n          if x < m-1:\n            if grid[x+1][y] == 0 and (x+1, y) not in visited:\n              new_start.append([x+1, y])\n              visited.add((x+1, y))\n              grid[x+1][y] = time\n          if y >= 1:\n            if grid[x][y-1] == 0 and (x, y-1) not in visited:\n              new_start.append([x, y-1])\n              visited.add((x, y-1))\n              grid[x][y-1] = time\n          if y < n-1:\n            if grid[x][y+1] == 0 and (x, y+1) not in visited:\n              new_start.append([x, y+1])\n              visited.add((x, y+1))\n              grid[x][y+1] = time\n        time += 1\n        start = new_start\n        \n        \n      #memo variable will save time from search path that is already proved to be impossible\n      memo = {}\n      def search(x, y, time, visited):\n        if (x,y) in memo and time >= memo[(x,y)]: return False\n        if time > grid[-1][-1]: return False\n        if x == m-1 and y == n-1:\n          if grid[x][y] == 0:\n            return True\n          else: \n            if grid[x][y] >= time:\n              return True\n        else:\n          if grid[x][y] == time: return False\n          visited.add((x,y))\n          if x >= 1:\n            if grid[x-1][y] != 'W' and grid[x-1][y] != 'F' and grid[x-1][y] > time  and (x-1, y) not in visited:\n              res = search(x-1, y, time+1, visited)\n              if res: return True\n          if x < m-1:\n            if grid[x+1][y] != 'W' and grid[x+1][y] != 'F' and grid[x+1][y] > time  and (x+1, y) not in visited:\n              res = search(x+1, y, time+1, visited)\n              if res: return True\n          if y >= 1:\n            if grid[x][y-1] != 'W' and grid[x][y-1] != 'F' and grid[x][y-1] > time  and (x, y-1) not in visited:\n              res = search(x, y-1, time+1, visited)\n              if res: return True\n          if y < n-1:\n            if grid[x][y+1] != 'W' and grid[x][y+1] != 'F' and grid[x][y+1] > time  and (x, y+1) not in visited:\n              res = search(x, y+1, time+1, visited)\n              if res: return True\n          visited.remove((x,y))\n          if (x,y) not in memo: memo[(x,y)] = time\n          else: memo[(x,y)] = min(time, memo[(x,y)])\n          return False\n        \n      if grid[0][0] == 0:\n        if search(0, 0, -sys.maxsize, set()): return 10**9\n        else: return -1\n      else:\n        start, end = 0, grid[0][0]-1\n        \n        #binary search\n \n        while start < end:\n          mid = ceil((start + end)/2)\n          if search(0, 0, mid, set()):\n            start = mid\n          else:\n            end = mid - 1\n        if start != 0: return start\n        else:\n          if search(0, 0, 0, set()): return 0\n          else: return -1"}
{"prompt": "def removeDigit(self, number: str, digit: str) -> str:\n        \n        # Initializing the last index as zero\n        last_index = 0\n        \n        #iterating each number to find the occurences, \\\n        # and to find if the number is greater than the next element \\ \n\n        for num in range(1, len(number)):\n            \n            # Handling [case 1] and [case 2]\n            if number[num-1] == digit:\n                if int(number[num]) > int(number[num-1]):\n                    return number[:num-1] + number[num:]\n                else:\n                    last_index = num - 1\n        \n        # If digit is the last number (last occurence) in the string [case 3]\n        if number[-1] == digit:\n            last_index = len(number) - 1\n\n        return number[:last_index] + number[last_index + 1:]"}
{"prompt": "def minimumCardPickup(self, cards: List[int]) -> int:\n        minPick = float('inf')\n        seen = {}\n        for i, n in enumerate(cards):\n            if n in seen:\n                if i - seen[n] + 1 < minPick:\n                    minPick = i - seen[n] + 1\n            seen[n] = i\n        if minPick == float('inf'):\n            return -1\n        return minPick"}
{"prompt": "def countDistinct(self, nums: List[int], k: int, p: int) -> int:\n        n = len(nums)                        \n        sub_arrays = set()\n        \n\t\t# generate all combinations of subarray\n        for start in range(n):\n            cnt = 0\n            temp = ''\n            for i in range(start, n):\n                if nums[i]%p == 0:\n                    cnt+=1                 \n                temp+=str(nums[i]) + ',' # build the sequence subarray in CSV format          \n                if cnt>k: # check for termination \n                    break\n                sub_arrays.add(temp)                                    \n                \n        return len(sub_arrays)"}
{"prompt": "def appealSum(self, s: str) -> int:\n        res, cur, prev = 0, 0, defaultdict(lambda: -1)\n        for i, ch in enumerate(s):\n            cur += i - prev[ch]\n            prev[ch] = i\n            res += cur\n        return res"}
{"prompt": "def largestGoodInteger(self, n: str) -> str:\n        return max(n[i-2:i+1] if n[i] == n[i - 1] == n[i - 2] else \"\" for i in range(2, len(n)))"}
{"prompt": "def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\n        \n        def fn(node): \n            nonlocal ans\n            if not node: return 0, 0 \n            ls, ln = fn(node.left)\n            rs, rn = fn(node.right)\n            s = node.val + ls + rs\n            n = 1 + ln + rn\n            if s//n == node.val: ans += 1\n            return s, n\n        \n        ans = 0 \n        fn(root)\n        return ans"}
{"prompt": "def countTexts(self, pressedKeys: str) -> int:\n        MOD = 1_000_000_007 \n        \n        @cache \n        def fn(n, k): \n            \"\"\"Return number of possible text of n repeated k times.\"\"\"\n            if n < 0: return 0\n            if n == 0: return 1\n            ans = 0\n            for x in range(1, k+1): ans = (ans + fn(n-x, k)) % MOD\n            return ans \n        \n        ans = 1\n        for key, grp in groupby(pressedKeys): \n            if key in \"79\": k = 4\n            else: k = 3\n            ans = (ans * fn(len(list(grp)), k)) % MOD \n        return ans"}
{"prompt": "def hasValidPath(self, grid: List[List[str]]) -> bool:  \n        m = len(grid)\n        n = len(grid[0])\n        @lru_cache(maxsize=None)\n        def hasValidPathInner(x, y, cnt):\n            # cnt variable would act as a counter to track \n            # the balance of parantheses sequence\n            if x == m or y == n or cnt < 0:\n                return False\n            \n            # logic to check the balance of sequence\n            cnt += 1 if grid[x][y] == '(' else -1\n            \n            # if balanced and end of grid, return True\n            if x == m - 1 and y == n - 1 and not cnt:\n                return True\n            \n            return hasValidPathInner(x + 1, y, cnt) or hasValidPathInner(x, y + 1, cnt)\n\n        return hasValidPathInner(0, 0, 0)"}
{"prompt": "\"\"\"\n    Time:   O(log10(n)*k)\n    Memory: O(log10(n))\n    \"\"\"\n\n    def divisorSubstrings(self, num: int, k: int) -> int:\n        str_num = str(num)\n        return sum(\n            num % int(str_num[i - k:i]) == 0\n            for i in range(k, len(str_num) + 1)\n            if int(str_num[i - k:i]) != 0\n        )"}
{"prompt": "def waysToSplitArray(self, n: List[int]) -> int:\n        n = list(accumulate(n))\n        return sum(n[i] >= n[-1] - n[i] for i in range(len(n) - 1))"}
{"prompt": "def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:\n        tiles.sort()\n        ans = ii = val = 0 \n        for i in range(len(tiles)): \n            hi = tiles[i][0] + carpetLen - 1\n            while ii < len(tiles) and tiles[ii][1] <= hi:\n                val += tiles[ii][1] - tiles[ii][0] + 1\n                ii += 1\n            partial = 0 \n            if ii < len(tiles): partial = max(0, hi - tiles[ii][0] + 1)\n            ans = max(ans, val + partial)\n            val -= tiles[i][1] - tiles[i][0] + 1\n        return ans"}
{"prompt": "def largestVariance(self, s: str) -> int:\n        ans = 0 \n        seen = set(s)\n        for x in ascii_lowercase: \n            for y in ascii_lowercase: \n                if x != y and x in seen and y in seen: \n                    vals = []\n                    for ch in s: \n                        if ch == x: vals.append(1)\n                        elif ch == y: vals.append(-1)\n                    cand = prefix = least = 0 \n                    ii = -1 \n                    for i, v in enumerate(vals): \n                        prefix += v\n                        if prefix < least: \n                            least = prefix \n                            ii = i \n                        ans = max(ans, min(prefix-least, i-ii-1))\n        return ans"}
{"prompt": "def removeAnagrams(self, w: List[str]) -> List[str]:\n        return [next(g) for _, g in groupby(w, sorted)]"}
{"prompt": "def maxConsecutive(self, bottom: int, top: int, special: list[int]) -> int:\n        special.sort()\n        res = special[0] - bottom\n        \n        for i in range(1, len(special)):\n            res = max(res, special[i] - special[i - 1] - 1)\n            \n        return max(res, top - special[-1])"}
{"prompt": "def largestCombination(self, candidates: List[int]) -> int:\n        return max(sum(n &amp; (1 << i) > 0 for n in candidates) for i in range(0, 24))"}
{"prompt": "def percentageLetter(self, s: str, letter: str) -> int:\n        a = s.count(letter)\n        return (a*100)//len(s)"}
{"prompt": "def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\n        remaining = [0] * len(capacity)\n        res = 0\n        \n        for i in range(len(capacity)):\n            remaining[i] = capacity[i] - rocks[i]\n        remaining.sort()\n        \n        for i in range(len(remaining)):\n            if remaining[i] > additionalRocks:\n                break\n                \n            additionalRocks -= remaining[i]\n            res += 1\n        \n        return res"}
{"prompt": "def minimumLines(self, stockPrices: List[List[int]]) -> int:\n        # key point: never use devision to judge whether 3 points are on a same line or not, use the multiplication instead !!\n        \n        n = len(stockPrices)\n        stockPrices.sort(key = lambda x: (x[0], x[1]))\n        \n        if n == 1:\n            return 0\n        \n        pre_delta_y = stockPrices[0][1] - stockPrices[1][1]\n        pre_delta_x = stockPrices[0][0] - stockPrices[1][0]\n        num = 1\n        \n        for i in range(1, n-1):\n            cur_delta_y = stockPrices[i][1] - stockPrices[i+1][1]\n            cur_delta_x = stockPrices[i][0] - stockPrices[i+1][0]\n            \n            if pre_delta_y * cur_delta_x != pre_delta_x * cur_delta_y:\n                num += 1\n                pre_delta_x = cur_delta_x\n                pre_delta_y = cur_delta_y\n        \n        return num"}
{"prompt": "def totalStrength(self, strength: List[int]) -> int:\n        strength = [0] + strength + [0]\n        def calc_prefix_sum(array):\n            if not array: return []\n            result = [array[0]]\n            for el in array[1:]:\n                result.append(array[-1]+el)\n            return result\n        prefix_sums = calc_prefix_sum(strength)\n        pp_sums = calc_prefix_sum(prefix_sums)\n        stack = [0]\n        total = 0\n        for right in range(len(strength)):\n            while pp_sums[stack[-1]] > pp_sums[right]:\n                left = stack[-2]\n                i = stack.pop()\n                pos = (i - left) * (pp_sums[right] - pp_sums[i])\n                neg = (right - i) * (pp_sums[i] - pp_sums[left])\n                total += pp_sums[i] * (pos - neg)\n                stack.push(right)\n        return total % (10**9+7)\n    def totalStrength(self, strength):\n        res, S, A = 0, [0], [0] + strength + [0]                           # O(N)\n        P = list(itertools.accumulate(itertools.accumulate(A), initial=0)) # O(N)\n        for r in range(len(A)):                                            # O(N)\n            while A[S[-1]] > A[r]:                                         # O(1) amortized\n                l, i = S[-2], S.pop()\n                res += A[i] * ((i - l) * (P[r] - P[i]) - (r - i) * (P[i] - P[l]))\n            S.append(r)\n        return res % (10 ** 9 + 7)"}
{"prompt": "def digitCount(self, num: str) -> bool:\n        counter=Counter(num)\n        for i in range(len(num)):\n            if counter[f'{i}'] != int(num[i]):\n                return False\n        return True"}
{"prompt": "def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\n        d={}\n        l=[]\n        for i in range(len(messages)):\n            if senders[i] not in d:\n                d[senders[i]]=len(messages[i].split())\n            else:\n                d[senders[i]]+=len(messages[i].split())\n        x=max(d.values())\n        for k,v in d.items():\n            if v==x :\n                l.append(k)\n        if len(l)==1:\n            return l[0]\n        else:\n            l=sorted(l)[::-1]      #Lexigograhical sorting of list\n            return l[0]"}
{"prompt": "def maximumImportance(self, n: int, roads: List[List[int]]) -> int:\n        Arr = [0] * n  # i-th city has Arr[i] roads\n        for A,B in roads:\n            Arr[A] += 1 # Each road increase the road count\n            Arr[B] += 1\n        Arr.sort()  # Cities with most road should receive the most score\n        summ = 0\n        for i in range(len(Arr)):\n            summ += Arr[i] * (i+1)  # Multiply city roads with corresponding score\n        \n        return summ"}
{"prompt": "def rearrangeCharacters(self, s: str, target: str) -> int:\n        counter_s = Counter(s)        \n        return min(counter_s[c] // count for c,count in Counter(target).items())"}
{"prompt": "def discountPrices(self, sentence: str, discount: int) -> str:\n        s = sentence.split() # convert to List to easily update\n        m = discount / 100 \n        for i,word in enumerate(s):\n            if word[0] == \"$\" and word[1:].isdigit(): # Check whether it is in correct format\n                num = int(word[1:]) * (1-m) # discounted price\n                w = \"$\" + \"{:.2f}\".format(num) #correctly format\n                s[i] = w #Change inside the list\n        \n        return \" \".join(s) #Combine the updated list\n\t\t```"}
{"prompt": "def totalSteps(self, nums: List[int]) -> int:\n        n = len(nums)\n        l = [i-1 for i in range(n)]\n        r = [i+1 for i in range(n)]\n        q = []\n        dist = dict()\n        ans = 0\n        for i in range(1, n):\n            if nums[i] < nums[i-1]:\n                q.append(i)\n                dist[i] = 1\n                ans = 1\n        while len(q) != 0:\n            u = q.pop(0)\n            ans = max(ans, dist[u])\n            if r[u] < n:\n                l[r[u]] = l[u]\n            if l[u] > -1:\n                r[l[u]] = r[u]\n            if r[u] not in dist and r[u] < n and nums[r[u]] < nums[l[u]]:\n                dist[r[u]] = dist[u] + 1\n                q.append(r[u])\n        return ans"}
{"prompt": "def minimumObstacles(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        dist = [[inf]*n for _ in range(m)]\n        dist[0][0] = 0\n        pq = [(0, 0, 0)]\n        while pq: \n            x, i, j = heappop(pq)\n            if i == m-1 and j == n-1: return x\n            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \n                if 0 <= ii < m and 0 <= jj < n and x + grid[ii][jj] < dist[ii][jj]: \n                    dist[ii][jj] = x + grid[ii][jj]\n                    heappush(pq, (dist[ii][jj], ii, jj))"}
{"prompt": "def minMaxGame(self, nums: List[int]) -> int:                \n        l=nums\n        while len(l)>1:\n            is_min=True     \n            tmp=[]\n            for i in range(0, len(l), 2):\n                if is_min:\n                    tmp.append(min(l[i:i+2]))\n                else:\n                    tmp.append(max(l[i:i+2]))\n                is_min=not is_min            \n            l=tmp            \n        return l[0]"}
{"prompt": "def partitionArray(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        ans = 1\n\t\t# To keep track of starting element of each subsequence\n        start = nums[0]\n        \n        for i in range(1, len(nums)):\n            diff = nums[i] - start\n            if diff > k:\n\t\t\t\t# If difference of starting and current element of subsequence is greater\n\t\t\t\t# than K, then only start new subsequence\n                ans += 1\n                start = nums[i]\n        \n        return ans"}
{"prompt": "def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\n            replacements = {}\n            for x, y in reversed(operations):\n                replacements[x] = replacements.get(y, y)\n            for idx, val in enumerate(nums):\n                if val in replacements:\n                    nums[idx] = replacements[val]\n            return nums"}
{"prompt": "def strongPasswordCheckerII(self, pwd: str) -> bool:\n        return (\n            len(pwd) > 7\n            and max(len(list(p[1])) for p in groupby(pwd)) == 1\n            and reduce(\n                lambda a, b: a | (1 if b.isdigit() else 2 if b.islower() else 4 if b.isupper() else 8), pwd, 0\n            ) == 15\n        )"}
{"prompt": "def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\n        potions.sort()\n        ans, n = [], len(potions)\n        for spell in spells:\n            val = success // spell\n            if success % spell == 0:\n                idx = bisect.bisect_left(potions, val)\n            else:    \n                idx = bisect.bisect_right(potions, val)\n            ans.append(n - idx)\n        return ans"}
{"prompt": "def matchReplacement(self, s: str, sub: str, mappings: List[List[str]]) -> bool:\n        s_maps = defaultdict(lambda : set())\n        for x,y in mappings:\n            s_maps[x].add(y)\n                \n        # build a sequence of set for substring match\n        # eg: sub=leet, mappings = {e: 3, t:7}\n        # subs = [{l}, {e, 3}, {e, 3}, {t, 7}]\n        # precalculation helps to eliminate TLE\n        subs = [s_maps[c] | {c} for c in sub] \n        \n        for i in range(len(s)-len(sub) + 1):\n            c=s[i]            \n            j=i\n            # Try to match substring\n            while j-i<len(sub) and s[j] in subs[j-i]:                                        \n                j+=1\n            if j-i==len(sub): # a valid match if iterated through the whole length of substring\n                return True\n    \n        return False"}
{"prompt": "def countSubarrays(self, nums: List[int], k: int) -> int:\n        sum, res, j = 0, 0, 0\n        for i, n in enumerate(nums):\n            sum += n\n            while sum * (i - j + 1) >= k:\n                sum -= nums[j]\n                j += 1\n            res += i - j + 1\n        return res"}
{"prompt": "def calculateTax(self, brackets: List[List[int]], income: int) -> float:\n        ans = prev = 0 \n        for hi, pct in brackets: \n            hi = min(hi, income)\n            ans += (hi - prev)*pct/100\n            prev = hi \n        return ans"}
{"prompt": "def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\n        max_row, max_col = len(grid), len(grid[0])\n        dp = [[-1] * max_col for _ in range(max_row)] \n\n        def recursion(row, col):\n            if row == max_row - 1: # If last row then return nodes value\n                return grid[row][col]\n            if dp[row][col] == -1: # If DP for this node is not computed then we will do so now.\n                current = grid[row][col] # Current Node Value\n                res = float('inf') # To store best path from Current Node\n                for c in range(max_col): # Traverse all path from Current Node\n                    val = moveCost[current][c] + recursion(row + 1, c) # Move cost + Target Node Value\n                    res = min(res, val)\n                dp[row][col] = res + current # DP[current node] = Best Path + Target Node Val + Current Node Val\n            return dp[row][col]\n\n        for c in range(max_col):\n            recursion(0, c) # Start recursion from all nodes in 1st row\n        return min(dp[0]) # Return min value from 1st row"}
{"prompt": "def distributeCookies(self, cookies: List[int], k: int) -> int:\n        l = [0]*k \n        self.s = float('inf')\n        def ser(l,i):\n            if i>=len(cookies):\n                self.s = min(self.s,max(l))\n                return \n            if max(l)>=self.s:\n                return \n            for j in range(k):\n                l[j]+=cookies[i]\n                ser(l,i+1)\n                l[j]-=cookies[i]\n        \n        ser(l,0)\n        return self.s"}
{"prompt": "def distinctNames(self, ideas: List[str]) -> int:\n        \n        names=defaultdict(set)\n        res=0  \n        \n        #to store first letter as key and followed suffix as val\n        for i in ideas:\n            names[i[0]].add(i[1:])\n            \n        #list of distinct first-letters available in ideas (may or may not contain all alphabets,depends upon elements in ideas)\n        arr=list(names.keys())\n        ans,n=0,len(arr)\n        \n        for i in range(n):\n            for j in range(i+1,n):\n                #a,b => 2 distinct first letters\n                a,b=arr[i],arr[j]\n                # adding the number of distinct posssible suffixes and multiplying by 2 as the new word formed might be \"newword1 newword2\" or \"newword2 newword1\"\n                res+=len(names[a]-names[b])*len(names[b]-names[a])*2\n                \n        return res"}
{"prompt": "def greatestLetter(self, s: str) -> str:\n        cnt = Counter(s)\n        return next((u for u in reversed(ascii_uppercase) if cnt[u] and cnt[u.lower()]), \"\")"}
{"prompt": "def minimumNumbers(self, num: int, k: int) -> int:\n        \n        if num == 0:\n            return 0\n        \n        if num < k:\n            return -1\n        \n        if num == k:\n            return 1\n        \n        ans = -1\n        i = 1\n\n        while i <= 10:\n            if (num - i * k) % 10 == 0 and i * k <= num:\n                return i\n            i += 1\n\n        return ans"}
{"prompt": "def longestSubsequence(self, s: str, k: int) -> int:\n        n = len(s)\n        ones = []\n\t\t# Notice how I reversed the string,\n\t\t# because the binary representation is written from greatest value of 2**n\n        for i, val in enumerate(s[::-1]):\n            if val == '1':\n                ones.append(i)\n\t\t# Initialize ans, there are already number of zeroes (num_of_zeroes = len(nums) - len(ones)\n        ans = n - len(ones)\n        i = 0\n\t\t# imagine k == 5 and binary string 001011\n\t\t# ones = [0, 1, 3]\n\t\t# first loop: 5 - 2**0 -> 4, ans += 1\n\t\t# second loop: 4 - 2**1 -> 2, ans +=1\n\t\t# Third loop does not occur because 2 - 2**3 -> -6 which is less than zero\n\t\t# So the ans is 3 + 2 = 5\n        while i < len(ones) and k - 2 ** ones[i] >= 0:\n            ans += 1\n            k -= 2 ** ones[i]\n            i += 1\n\t\n        return ans"}
{"prompt": "def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\n        dp = [[0]*(n+1) for _ in range(m+1)]\n        for h, w, p in prices:\n            dp[h][w] = p\n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                v = max(dp[k][j] + dp[i - k][j] for k in range(1, i // 2 + 1)) if i > 1 else 0\n                h = max(dp[i][k] + dp[i][j - k] for k in range(1, j // 2 + 1)) if j > 1 else 0\n                dp[i][j] = max(dp[i][j], v, h)\n        return dp[m][n]"}
{"prompt": "\"\"\"\n\tTime:   O(n)\n\tMemory: O(1)\n\t\"\"\"\n\n\tdef countAsterisks(self, s: str) -> int:\n\t\tis_closed = True\n\t\tcount = 0\n\n\t\tfor c in s:\n\t\t\tcount += is_closed * c == '*'\n\t\t\tis_closed ^= c == '|'\n\n\t\treturn count\n\n\n\"\"\"\n\tTime:   O(n)\n\tMemory: O(n)\n\t\"\"\"\n\n\tdef countAsterisks(self, s: str) -> int:\n\t\treturn sum(chunk.count('*') for chunk in s.split('|')[0::2])"}
{"prompt": "def countPairs(self, n: int, edges: List[List[int]]) -> int:\n        def dfs(graph,node,visited):\n            visited.add(node)\n            self.c += 1\n            for child in graph[node]:\n                if child not in visited:\n                    dfs(graph, child, visited)\n        \n        #build graph\n        graph = {}\n        for i in range(n):\n            graph[i] = []\n            \n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        visited = set()\n        count = 0\n        totalNodes = 0\n        \n        #run dfs in unvisited nodes\n        for i in range(n):\n            if i not in visited:\n                self.c = 0\n                dfs(graph, i, visited)\n                \n                count += totalNodes*self.c    # result \n                totalNodes += self.c          # total nodes visited \n        return count"}
{"prompt": "def maximumXOR(self, nums: List[int]) -> int:\n       return reduce(lambda x,y: x|y, nums)\n\ndef maximumXOR(self, nums: List[int]) -> int:\n       return reduce(or_, nums)\n\ndef maximumXOR(self, nums: List[int]) -> int:\n       \n       ans = 0\n       for n in nums:\n           ans |= n      \n       return ans"}
{"prompt": "def distinctSequences(self, n: int) -> int:\n        \n        @lru_cache\n        def fn(n, p0, p1): \n            \"\"\"Return total number of distinct sequences.\"\"\"\n            if n == 0: return 1\n            ans = 0\n            for x in range(1, 7): \n                if x not in (p0, p1) and gcd(x, p0) == 1: ans += fn(n-1, x, p0)\n            return ans % 1_000_000_007\n        \n        return fn(n, -1, -1)"}
{"prompt": "def checkXMatrix(self, grid: List[List[int]]) -> bool:\n        a=0\n        j=len(grid)-1\n        for i in range(0,len(grid)):\n            if grid[i][i]==0 or grid[i][j]==0:\n                return False\n            else:\n                if i!=j:\n                    a=grid[i][i]+grid[i][j]\n                elif i==j:\n                    a=grid[i][i]\n            if a!=sum(grid[i]):\n                return False\n            j-=1\n        return True"}
{"prompt": "def countHousePlacements(self, n: int) -> int:\n        pre,ppre = 2,1\n        if n==1:\n            return 4\n        for i in range(1,n):\n            temp = pre+ppre \n            ppre = pre \n            pre = temp \n        return ((pre)**2)%((10**9) + 7)"}
{"prompt": "def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\n        # create a difference array between nums1 and nums2\n        # idea: find two subarray(elements are contiguous) in the diff\n        # one is the subarray that have the minimum negative sum\n        # another one is the subarray that have the maximum positive sum\n        # so there are four candidates for maximum score:\n        # 1. original_sum1 \n        # 2. original_sum \n        # 3. original_sum1 - min_negative_sum\n        # 4. original_sum2 + max_positive_sum\n        \n        original_sum1 = sum(nums1)\n        original_sum2 = sum(nums2)\n        diff = [num1 - num2 for num1, num2 in zip(nums1, nums2)]\n        min_negative_sum = float('inf')\n        max_positive_sum = - float('inf')\n        cur_negative_sum = 0\n        cur_positive_sum = 0\n        \n        for val in diff:\n            cur_negative_sum += val\n\n            if cur_negative_sum > 0:\n                cur_negative_sum = 0\n            \n            cur_positive_sum += val\n            \n            if cur_positive_sum < 0:\n                cur_positive_sum = 0\n                    \n            min_negative_sum = min(min_negative_sum, cur_negative_sum)\n            max_positive_sum = max(max_positive_sum, cur_positive_sum)\n\n        return max(original_sum1 - min_negative_sum, original_sum2 + max_positive_sum, original_sum2, original_sum1)"}
{"prompt": "def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:        \n        n = len(nums)\n        graph = [[] for _ in range(n)]\n        for u, v in edges: \n            graph[u].append(v)\n            graph[v].append(u)\n            \n        def fn(u): \n            score[u] = nums[u]\n            child[u] = {u}\n            for v in graph[u]: \n                if seen[v] == 0: \n                    seen[v] = 1\n                    fn(v)\n                    score[u] ^= score[v]\n                    child[u] |= child[v]\n        \n        seen = [1] + [0]*(n-1)\n        score = [0]*n\n        child = [set() for _ in range(n)]\n        fn(0)\n        \n        ans = inf \n        for u in range(1, n): \n            for v in range(u+1, n): \n                if u in child[v]: \n                    uu = score[u]\n                    vv = score[v] ^ score[u]\n                    xx = score[0] ^ score[v]\n                elif v in child[u]: \n                    uu = score[u] ^ score[v]\n                    vv = score[v]\n                    xx = score[0] ^ score[u]\n                else: \n                    uu = score[u]\n                    vv = score[v]\n                    xx = score[0] ^ score[u] ^ score[v]\n                ans = min(ans, max(uu, vv, xx) - min(uu, vv, xx))\n        return ans"}
{"prompt": "def decodeMessage(self, key: str, message: str) -> str:\n        mapping = {' ': ' '}\n        i = 0\n        res = ''\n        letters = 'abcdefghijklmnopqrstuvwxyz'\n        \n        for char in key:\n            if char not in mapping:\n                mapping[char] = letters[i]\n                i += 1\n        \n        for char in message:\n            res += mapping[char]\n                \n        return res"}
{"prompt": "def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\n        \n        matrix = [[-1]*n for i in range(m)]\n        \n        current = head\n        direction = 1\n        i, j = 0, -1\n        \n        while current:\n            for _ in range(n):\n                if current:\n                    j += direction\n                    matrix[i][j] = current.val\n                    current = current.next\n                    \n            m -= 1\n            \n            for _ in range(m):\n                if current:\n                    i += direction\n                    matrix[i][j] = current.val\n                    current = current.next\n            n -= 1\n            \n            direction *= -1\n        \n        return matrix"}
{"prompt": "def peopleAwareOfSecret(self, n: int, d: int, f: int) -> int:\n        dp, md = [1] + [0] * (f - 1), 10**9 + 7\n        for i in range(1, n):\n            dp[i % f] = (md + dp[(i + f - d) % f] - dp[i % f] + (0 if i == 1 else dp[(i - 1) % f])) % md\n        return sum(dp) % md"}
{"prompt": "def countPaths(self, grid: List[List[int]]) -> int:\n        rows, cols = len(grid), len(grid[0])\n        dp = {}\n        mod = (10 ** 9) + 7\n\n        def dfs(r, c, prev):\n            if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] <= prev:\n                return 0\n\n            if (r, c) in dp:\n                return dp[(r, c)]\n\n            pathLength = 1\n            pathLength += (dfs(r + 1, c, grid[r][c]) + dfs(r - 1, c, grid[r][c]) +\n                dfs(r, c + 1, grid[r][c]) + dfs(r, c - 1, grid[r][c]))\n            dp[(r, c)] = pathLength\n            return pathLength\n            \n        count = 0\n        for r in range(rows):\n            for c in range(cols):\n                count += dfs(r, c, 0)\n\n        return count % mod"}
{"prompt": "def evaluateTree(self, root: Optional[TreeNode]) -> bool:\n            if root.val==0 or root.val==1:\n                return root.val\n            if root.val==2:\n                return self.evaluateTree(root.left) or self.evaluateTree(root.right)\n            if root.val==3:\n                return self.evaluateTree(root.left) and self.evaluateTree(root.right)"}
{"prompt": "def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\n        buses.sort()\n        passengers.sort()\n        \n        passenger = 0\n        for bus in buses:\n            maxed_out = False\n            cap = capacity\n            \n            while passenger < len(passengers) and passengers[passenger] <= bus and cap != 0:\n                passenger += 1\n                cap -= 1\n                \n            if cap == 0:\n                maxed_out = True\n                \n        if maxed_out:\n            max_seat = passengers[passenger - 1]\n        else:\n            max_seat = buses[-1]\n    \n        booked = set(passengers)\n        for seat in range(max_seat, 0, -1):\n            if seat not in booked:\n                return seat"}
{"prompt": "def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\n        n = len(nums1)\n        k = k1+k2 # can combine k's because items can be turned negative\n        diffs = sorted((abs(x - y) for x, y in zip(nums1, nums2)))\n        \n        # First binary search to find our new max for our diffs array\n        l, r = 0, max(diffs)\n        while l < r:\n            mid = (l+r)//2\n            \n            # steps needed to reduce all nums greater than newMax\n            steps = sum(max(0, num-mid) for num in diffs)\n            \n            if steps <= k:\n                r = mid\n            else:\n                l = mid+1\n                \n        newMax = l\n        k -= sum(max(0, num-newMax) for num in diffs) # remove used k\n\n        # Second binary search to find first index to replace with max val\n        l, r = 0, n-1\n        while l < r:\n            mid = (l+r)//2\n            if diffs[mid] < newMax:\n                l = mid+1\n            else:\n                r = mid\n\n        # Replace items at index >= l with newMax\n        diffs = diffs[:l]+[newMax]*(n-l)\n        \n        # Use remaining steps to reduce overall score\n        for i in range(len(diffs)-1,-1,-1):\n            if k == 0 or diffs[i] == 0: break\n            diffs[i] -= 1\n            k -= 1\n            \n        return sum(diff*diff for diff in diffs)"}
{"prompt": "def validSubarraySize(self, nums: List[int], threshold: int) -> int:\n                            # Stack elements are the array's indices idx, and montonic with respect to nums[idx].\n                            # When the index of the nearest smaller value to nums[idx] comes to the top of the \n                            # stack, we check whether the threshold criterion is satisfied. If so, we are done.\n                            #  If not, we continue. Return -1 if we reach the end of nums without a winner.\n\t\t\t\t\t\t\t\n        nums.append(0)\n        stack = deque()\n\n        for idx in range(len(nums)):\n\n            while stack and nums[idx] <= nums[stack[-1]]:           \n                n = nums[stack.pop()]                               # n is the next smaller value for nums[idx]\n                k = idx if not stack else idx - stack[-1] -1        \n                if n > threshold //k: return k                      # threshold criterion. if n passes, all\n                                                                    # elements of the interval pass\n            stack.append(idx)\n\n        return -1"}
{"prompt": "def fillCups(self, amount: List[int]) -> int:\n        pq = [-q for q in amount if q != 0]\n        heapq.heapify(pq)\n        ret = 0\n        \n        while len(pq) > 1:\n            first = heapq.heappop(pq)\n            second = heapq.heappop(pq)\n            first += 1\n            second += 1\n            ret += 1\n            if first:\n                heapq.heappush(pq, first)\n            if second:\n                heapq.heappush(pq, second)\n\n        if pq:\n            return ret - pq[0]\n        else:\n            return ret"}
{"prompt": "# Criteria for a valid transormation:\n\n                    #   1) The # of Ls, # of Rs , and # of _s must be equal between the two strings\n                    #\n                    #   2) The ordering of Ls and Rs in the two strings must be the same.\n                    #\n                    #   3) Ls can only move left and Rs can only move right, so each L in start \n                    #      cannot be to the left of its corresponding L in target, and each R cannot\n                    #      be to the right of its corresponding R in target.\n\n    def canChange(self, start: str, target: str) -> bool:\n                                                          \n        if (len(start) != len(target) or \n            start.count('_') != target.count('_')): return False   #  <-- Criterion 1\n\n        s = [(ch,i) for i, ch in enumerate(start ) if ch != '_']\n        t = [(ch,i) for i, ch in enumerate(target) if ch != '_']\n\n        for i in range(len(s)):\n            (sc, si), (tc,ti) = s[i], t[i]\n            if sc != tc: return False                              # <-- Criteria 1 &amp; 2\n            if sc == 'L' and si < ti: return False                 # <-- Criterion 3\n            if sc == 'R' and si > ti: return False                 # <--/\n\n        return True                                                # <-- It's a winner!"}
{"prompt": "def idealArrays(self, n: int, maxValue: int) -> int:\n        ans = maxValue\n        freq = {x : 1 for x in range(1, maxValue+1)}\n        for k in range(1, n): \n            temp = Counter()\n            for x in freq: \n                for m in range(2, maxValue//x+1): \n                    ans += comb(n-1, k)*freq[x]\n                    temp[m*x] += freq[x]\n            freq = temp\n            ans %= 1_000_000_007\n        return ans"}
{"prompt": "\"\"\"\n\tTime:   O(n)\n\tMemory: O(n)\n\t\"\"\"\n\n\tdef numberOfPairs(self, nums: List[int]) -> List[int]:\n\t\tpairs = sum(cnt // 2 for cnt in Counter(nums).values())\n\t\treturn [pairs, len(nums) - 2 * pairs]"}
{"prompt": "# The plan here is to:\n                    # \n                    #   • sort the elements of nums into a dict of maxheaps,\n                    #     according to sum-of-digits.\n                    #\n                    #   • For each key, determine whether there are at least two \n                    #     elements in that key's values, and if so, compute the\n                    #     product of the greatest two elements.\n                    #\n                    #   • return the the greatest such product as the answer.\n\n                    # For example:\n\t\t\t\t\t\n                    #     nums = [6,15,13,12,24,21] –> {3:[12,21], 4:[13], 6:[6,15,24]}\n\t\t\t\t\t\n                    #     Only two keys qualify, 3 and 6, for which the greatest two elements\n                    #     are 12,21 and 15,24, respectively. 12+21 = 33 and 15+24 = 39,\n                    #     so the answer is 39.\n\n    def maximumSum(self, nums: List[int]) -> int:\n        d, mx = defaultdict(list), -1\n        digits = lambda x: sum(map(int, list(str(x))))      # <-- sum-of-digits function\n       \n        for n in nums:                                      # <-- construct max-heaps\n            heappush(d[digits(n)],-n)                       #     (note \"-n\") \n\n        for i in d:                                         # <-- pop the two greatest values off\n            if len(d[i]) > 1:                               #     each maxheap (when possible) and\n                mx= max(mx, -heappop(d[i])-heappop(d[i]))   #     compare with current max value.\n                                                           \n        return mx"}
{"prompt": "def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\n        def countingSort(indices, pos):\n            count = [0] * 10\n            for idx in indices:\n                count[ord(nums[idx][pos]) - ord('0')] += 1\n            start_pos = list(accumulate([0] + count, add))\n            result = [None] * len(indices)\n            for idx in indices:\n                digit = ord(nums[idx][pos]) - ord('0')\n                result[start_pos[digit]] = idx\n                start_pos[digit] += 1\n            return result\n            \n        n = len(nums)\n        m = len(nums[0])\n        suffix_ordered = [list(range(n))]\n        for i in range(m - 1, -1, -1):\n            suffix_ordered.append(countingSort(suffix_ordered[-1], i))\n        return [suffix_ordered[t][k-1] for k, t in queries]"}
{"prompt": "# From number theory, we know that an integer num divides each\n                    # integer in a list if and only if num divides the list's gcd.\n                    # \n                    # Our plan here is to:\n                    #   • find the gcd of numDivide\n                    #   • heapify(nums) and count the popped elements that do not\n                    #     divide the gcd.\n                    #   • return that count when and if a popped element eventually\n                    #     divides the gcd. If that never happens, return -1 \n        \n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\n\t\n        g, ans = gcd(*numsDivide), 0            # <-- find gcd (using * operator)\n\n        heapify(nums)                           # <-- create heap\n\n        while nums:                             # <-- pop and count\n\n            if not g%heappop(nums): return ans  # <-- found a divisor? return count\n            else: ans+= 1                       # <-- if not, increment the count\n\n        return -1                               # <-- no divisors found\n\t\t\n#--------------------------------------------------\n# version w/o heap. Seems to run slower\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\n\t\n        g = gcd(*numsDivide)\n        nums.sort()\n\n        for i,num in enumerate(nums):\n            if not g%num: return i\n\n        return -1"}
{"prompt": "def bestHand(self, ranks: List[int], suits: List[str]) -> str:\n\n        dictRanks = {}\n        dictSuits = {}\n        \n        for key in ranks:\n            dictRanks[key] = dictRanks.get(key, 0) + 1\n\n        for key in suits:\n            dictSuits[key] = dictSuits.get(key, 0) + 1\n            \n        maxRanks = max(dictRanks.values())\n        maxSuits = max(dictSuits.values())\n        \n        if maxSuits == 5:\n            return \"Flush\"\n        if maxRanks >= 3:\n            return \"Three of a Kind\"\n        if maxRanks >= 2:\n            return \"Pair\" \n        return \"High Card\""}
{"prompt": "def zeroFilledSubarray(self, nums: List[int]) -> int:\n        \n        n = len(nums)\n\n        ans = 0\n        i, j = 0, 0\n        while i <= n - 1:\n            j = 0\n            if nums[i] == 0:\n                while i + j <= n - 1 and nums[i + j] == 0:\n                    j += 1\n                ans += (j + 1) * j // 2\n\n            i = i + j + 1\n        \n        return ans"}
{"prompt": "def shortestSequence(self, rolls: List[int], k: int) -> int:\n        ans = 0 \n        seen = set()\n        for x in rolls: \n            seen.add(x)\n            if len(seen) == k: \n                ans += 1\n                seen.clear()\n        return ans+1"}
{"prompt": "def repeatedCharacter(self, s: str) -> str:\n        \n        setS = set()\n\n        for x in s:\n            if x in setS:\n                return x\n            else:\n                setS.add(x)"}
{"prompt": "# Consider this grid for an example:\n                                #           grid = [[1,2,1,9]\n                                #                   [2,8,9,2]\n                                #                   [1,2,1,9]\n                                #                   [9,2,6,3]]\n    \n                                # Here's the plan:\n\n                                #   • Determine tpse, the transpose of grid (using zip(*grid)):\n                                #           tspe = [[1,2,1,9] \n                                #                   [2,8,2,2]\n                                #                   [1,9,1,6]\n                                #                   [9,2,9,3]] \n                                #     The problem now is to determine the pairs of \n                                #     identical rows, one row in tpse and the other in grid.\n\n                                #   • We hash grid and tspe:\n                                #\n                                #           Counter(tuple(grid)):\n                                #               {(1,2,1,9): 2, (2,8,9,2): 1, (9,2,6,3): 1}\n                                #  \n                                #           Counter(zip(*grid)):\n                                #            {(1,2,1,9): 1, (2,8,2,2): 1, (1,9,1,6): 1, (9,2,9,3): 1}\n                                #\n                                #   • We determine the number of pairs:\n                                #       (1,2,1,9): 2 and (1,2,1,9): 1    => 2x1 = 2\n                                \n    def equalPairs(self, grid: List[List[int]]) -> int:\n\n        tpse = Counter(zip(*grid))                  # <-- determine the transpose\n                                                    #     and hash the rows\n\n        grid = Counter(map(tuple,grid))             # <-- hash the rows of grid. (Note the tuple-map, so\n                                                    #     we can compare apples w/ apples in next step.)\n\n        return  sum(tpse[t]*grid[t] for t in tpse)  # <-- compute the number of identical pairs\n\t\t\n\t\t                                            # https://leetcode.com/submissions/detail/755717162/"}
{"prompt": "def countExcellentPairs(self, nums: List[int], k: int) -> int:\n        hamming = sorted([self.hammingWeight(num) for num in set(nums)])\n        ans = 0\n        for h in hamming:\n            ans += len(hamming) - bisect.bisect_left(hamming, k - h)\n        return ans\n        \n    def hammingWeight(self, n):\n        ans = 0\n        while n:\n            n &amp;= (n - 1)\n            ans += 1\n        return ans"}
{"prompt": "def minimumOperations(self, nums: List[int]) -> int:\n        return len(set(nums) - {0})"}
{"prompt": "def maximumGroups(self, grades: List[int]) -> int:\n        \n        x = len(grades)\n        n = 0.5 * ((8 * x + 1) ** 0.5 - 1)\n        ans = int(n)\n        \n        return ans"}
{"prompt": "def get_neighbors(self, start: int) -> Dict[int, int]:\n\t\tdistances = defaultdict(lambda: math.inf)\n\n\t\tqueue = deque([start])\n\t\tlevel = 0\n\n\t\twhile queue:\n\t\t\tfor _ in range(len(queue)):\n\t\t\t\tcurr = queue.popleft()\n\n\t\t\t\tif distances[curr] <= level:    \n\t\t\t\t\tcontinue\n\n\t\t\t\tdistances[curr] = level\n\n\t\t\t\tfor neighbor in graph[curr]:\n\t\t\t\t\tqueue.append(neighbor)\n\n\t\t\tlevel += 1        \n\n\t\treturn distances\n\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        n = len(edges)\n        graph = [[] for _ in range(n)]\n        \n        for _from, to in enumerate(edges):\n            if to != -1:\n                graph[_from].append(to)\n        \n        a = self.get_neighbors(node1)\n        b = self.get_neighbors(node2)\n                \n        options = []    \n        \n        for idx in range(n):\n            if a[idx] != math.inf and b[idx] != math.inf:\n                options.append((max(a[idx], b[idx]), idx))\n                \n        if not options:\n            return -1        \n        \n        return min(options)[1]"}
{"prompt": "def longestCycle(self, edges: List[int]) -> int:\n        in_d = set()\n        out_d = set()\n        for i, j in enumerate(edges):\n            if j != -1:\n                in_d.add(j)\n                out_d.add(i)\n        potential = in_d &amp; out_d\n        visited = set()\n        self.ans = -1\n        def dfs(node, curr, v):\n            visited.add(node)\n            v[node] = curr\n            nei = edges[node]\n            if nei in v:\n                self.ans = max(self.ans, curr - v[nei] + 1)\n                visited.add(nei)\n                return\n            if nei not in visited and nei in potential:\n                dfs(nei, curr + 1, v)\n        for node in potential:\n            dfs(node, 1, {})\n        return self.ans"}
{"prompt": "def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\n\n\t\tmerge_item = items1 + items2\n\n\t\td = defaultdict(int)\n\n\t\tfor i in merge_item:\n\t\t\tvalue,weight = i\n\t\t\td[value] = d[value] + weight\n\n\t\tresult = []\n\n\t\tfor j in sorted(d):\n\t\t\tresult.append([j,d[j]])\n\n\t\treturn result"}
{"prompt": "def countBadPairs(self, nums: List[int]) -> int:\n        nums_len = len(nums)\n        count_dict = dict()\n        for i in range(nums_len):\n            nums[i] -= i\n            if nums[i] not in count_dict:\n                count_dict[nums[i]] = 0\n            count_dict[nums[i]] += 1\n        \n        count = 0\n        for key in count_dict:\n            count += math.comb(count_dict[key], 2)\n        return math.comb(nums_len, 2) - count"}
{"prompt": "def taskSchedulerII(self, tasks: List[int], space: int) -> int:\n        \n        ans = 0\n        hashset = {}\n        n = len(tasks)\n        \n        for x in set(tasks):\n            hashset[x] = 0\n            \n        i = 0\n        while i <= n - 1:\n            flag = ans - hashset[tasks[i]]\n            if flag >= 0:\n                ans += 1\n                hashset[tasks[i]] = ans + space\n                i += 1\n            else:\n                ans += -flag\n        \n        return ans"}
{"prompt": "def minimumReplacement(self, nums: List[int]) -> int:\n        \n        n = len(nums)\n        k = nums[n - 1]\n        ans = 0\n        \n        for i in reversed(range(n - 1)):\n            if nums[i] > k:\n                l =  nums[i] / k\n                if l == int(l):\n                    ans += int(l) - 1\n                    k = nums[i] / int(l)\n                else:\n                    ans += int(l)\n                    k = int(nums[i] / (int(l) + 1))\n            else:\n                k = nums[i]\n\n        return ans"}
{"prompt": "def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\n        \n        ans = 0\n        n = len(nums)\n        for i in range(n):\n            if nums[i] + diff in nums and nums[i] + 2 * diff in nums:\n                ans += 1\n        \n        return ans"}
{"prompt": "def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\n        \n        restrictedSet = set(restricted)\n        uf = UnionFindSet(n)\n        for edge in edges:\n            if edge[0] in restrictedSet or edge[1] in restrictedSet:\n                continue\n            else:\n                uf.union(edge[0], edge[1])\n\n        ans = 1\n        rootNode = uf.find(0)\n        for i in range(1, n):\n            if uf.find(i) == rootNode:\n                ans += 1\n        return ans\n\nclass UnionFindSet:\n    def __init__(self, size):\n        self.root = [i for i in range(size)]\n        # Use a rank array to record the height of each vertex, i.e., the \"rank\" of each vertex.\n        # The initial \"rank\" of each vertex is 1, because each of them is\n        # a standalone vertex with no connection to other vertices.\n        self.rank = [1] * size\n\n    # The find function here is the same as that in the disjoint set with path compression.\n    def find(self, x):\n        if x == self.root[x]:\n            return x\n        self.root[x] = self.find(self.root[x])\n        return self.root[x]\n\n    # The union function with union by rank\n    def union(self, x, y):\n        rootX = self.find(x)\n        rootY = self.find(y)\n        if rootX != rootY:\n            if self.rank[rootX] > self.rank[rootY]:\n                self.root[rootY] = rootX\n            elif self.rank[rootX] < self.rank[rootY]:\n                self.root[rootX] = rootY\n            else:\n                self.root[rootY] = rootX"}
{"prompt": "def validPartition(self, nums: List[int]) -> bool:\n        idxs = defaultdict(list)\n        n = len(nums)\n        \n        #Find all doubles\n        for idx in range(1, n):\n            if nums[idx] == nums[idx - 1]:\n                idxs[idx - 1].append(idx + 1)\n                \n        #Find all triples\n        for idx in range(2, n):\n            if nums[idx] == nums[idx - 1] == nums[idx - 2]:\n                idxs[idx - 2].append(idx + 1)\n                \n        #Find all triple increments\n        for idx in range(2, n):\n            if nums[idx] == nums[idx - 1] + 1 == nums[idx - 2] + 2:\n                idxs[idx - 2].append(idx + 1)\n        \n        #DFS \n        seen = set()\n        stack = [0]\n\n        while stack:\n            node = stack.pop()\n\n            if node not in seen:\n                if node == n:\n                    return True\n                seen.add(node)\n\n            for adj in idxs[node]:\n                if adj not in seen:\n                    stack.append(adj)\n        \n        return False"}
{"prompt": "def longestIdealString(self, s: str, k: int) -> int:\n        dp = [0] * 26\n        for ch in s:\n            i = ord(ch) - ord(\"a\")\n            dp[i] = 1 + max(dp[max(0, i - k) : min(26, i + k + 1)])\n        return max(dp)"}
{"prompt": "def largestLocal(self, grid: List[List[int]]) -> List[List[int]]:\n        n = len(grid)\n        ans = [[0]*(n-2) for _ in range(n-2)]\n        for i in range(n-2): \n            for j in range(n-2): \n                ans[i][j] = max(grid[ii][jj] for ii in range(i, i+3) for jj in range(j, j+3))\n        return ans"}
{"prompt": "def edgeScore(self, edges: List[int]) -> int:\n\n        n = len(edges)\n        cnt = defaultdict(int)\n        ans = 0\n        \n\t\t// we have the key stores the node edges[i], and the value indicates the edge score.\n        for i in range(n):\n            cnt[edges[i]] += i\n\n        m = max(cnt.values())\n\n\t\t// In the second iteration, i is also the index of the node. So the first one meets == m, is the smallest index.\n        for i in range(n):\n            if cnt[i] == m:\n                ans = i\n                break\n        \n        return ans"}
{"prompt": "def smallestNumber(self, pattern: str) -> str:\n        ans = [1]\n        for ch in pattern: \n            if ch == 'I': \n                m = ans[-1]+1\n                while m in ans: m += 1\n                ans.append(m)\n            else: \n                ans.append(ans[-1])\n                for i in range(len(ans)-1, 0, -1): \n                    if ans[i-1] == ans[i]: ans[i-1] += 1\n        return ''.join(map(str, ans))"}
{"prompt": "def countSpecialNumbers(self, n: int) -> int:\n        vals = list(map(int, str(n)))\n        \n        @cache\n        def fn(i, m, on): \n            \"\"\"Return count at index i with mask m and profile flag (True/False)\"\"\"\n            ans = 0 \n            if i == len(vals): return 1\n            for v in range(vals[i] if on else 10 ): \n                if m &amp; 1<<v == 0: \n                    if m or v: ans += fn(i+1, m ^ 1<<v, False)\n                    else: ans += fn(i+1, m, False)\n            if on and m &amp; 1<<vals[i] == 0: ans += fn(i+1, m ^ 1<<vals[i], True)\n            return ans \n        \n        return fn(0, 0, True)-1"}
{"prompt": "def minimumRecolors(self, blocks: str, k: int) -> int:\n        \n        ans = 0\n        res = 0\n\n        for i in range(len(blocks) - k + 1):\n            res = blocks.count('B', i, i + k)\n            ans = max(res, ans)\n\n        ans = k - ans\n        return ans"}
{"prompt": "def secondsToRemoveOccurrences(self, s: str) -> int:\n        ans = prefix = prev = 0 \n        for i, ch in enumerate(s): \n            if ch == '1': \n                ans = max(prev, i - prefix)\n                prefix += 1\n                if ans: prev = ans+1\n        return ans"}
{"prompt": "def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\n        cum_shifts = [0 for _ in range(len(s)+1)]\n        \n        for st, end, d in shifts:\n            if d == 0:\n                cum_shifts[st] -= 1\n                cum_shifts[end+1] += 1\n            else:\n                cum_shifts[st] += 1\n                cum_shifts[end+1] -= 1\n        \n        cum_sum = 0\n        for i in range(len(s)):\n            cum_sum += cum_shifts[i]\n            \n            new_code = (((ord(s[i]) + cum_sum) - 97) % 26) + 97\n            s = s[:i] + chr(new_code) + s[i+1:]\n        \n        return s"}
{"prompt": "def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\n        mp, cur, res = {}, 0, []\n        for q in reversed(removeQueries[1:]):\n            mp[q] = (nums[q], 1)\n            rv, rLen = mp.get(q+1, (0, 0))\n            lv, lLen = mp.get(q-1, (0, 0))\n                \n            total = nums[q] + rv + lv\n            mp[q+rLen] = (total, lLen + rLen + 1)\n            mp[q-lLen] = (total, lLen + rLen + 1)\n        \n            cur = max(cur, total)\n            res.append(cur)\n            \n        return res[::-1] + [0]"}
{"prompt": "def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\n        \n        ans = 0\n        n = len(energy)\n\n        for i in range(n):\n            while initialEnergy <= energy[i] or initialExperience <= experience[i]:\n                if initialEnergy <= energy[i]:\n                    initialEnergy += 1\n                    ans += 1\n                if initialExperience <= experience[i]:\n                    initialExperience += 1\n                    ans += 1\n            initialEnergy -= energy[i]\n            initialExperience += experience[i]\n        \n        return ans"}
{"prompt": "def largestPalindromic(self, num: str) -> str:\n\n        ans = []\n        b = [str(x) for x in range(9, -1, -1)]\n        from collections import defaultdict\n\n        a = defaultdict(int)\n\n        for x in num:\n            a[x] += 1\n\n        for x in b:\n            n = len(ans)\n            if n % 2 == 0:\n                if a[x] > 0:\n                    ans = ans[:n // 2] + [x] * a[x] + ans[n // 2:]\n            else:\n                if x == '0':\n                    if len(ans) != 1:\n                        ans = ans[:n // 2] + [x] * (a[x] // 2) + [ans[n // 2]] + [x] * (a[x] // 2) + ans[n // 2 + 1:]\n                else:\n                    if a[x] >= 2:\n                        ans = ans[:n // 2] + [x] * (a[x] // 2) + [ans[n // 2]] + [x] * (a[x] // 2) + ans[n // 2 + 1:]\n\n        res = \"\".join(ans)\n        return str(int(res))"}
{"prompt": "def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\n        graph = defaultdict(list)\n        \n        stack = [(root, None)]\n        while stack: \n            n, p = stack.pop()\n            if p: \n                graph[p.val].append(n.val)\n                graph[n.val].append(p.val)\n            if n.left: stack.append((n.left, n))\n            if n.right: stack.append((n.right, n))\n        \n        ans = -1\n        seen = {start}\n        queue = deque([start])\n        while queue: \n            for _ in range(len(queue)): \n                u = queue.popleft()\n                for v in graph[u]: \n                    if v not in seen: \n                        seen.add(v)\n                        queue.append(v)\n            ans += 1\n        return ans"}
{"prompt": "def kSum(self, nums: List[int], k: int) -> int:\n        maxSum = sum([max(0, num) for num in nums])\n        absNums = sorted([abs(num) for num in nums])\n        maxHeap = [(-maxSum + absNums[0], 0)]\n        ans = [maxSum]\n        while len(ans) < k:\n            nextSum, i = heapq.heappop(maxHeap)\n            heapq.heappush(ans, -nextSum)\n            if i + 1 < len(absNums):\n                heapq.heappush(maxHeap, (nextSum - absNums[i] + absNums[i + 1], i + 1))\n                heapq.heappush(maxHeap, (nextSum + absNums[i + 1], i + 1))\n        return ans[0]"}
{"prompt": "def answerQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        nums = list(accumulate(sorted(nums)))\n        return [bisect_right(nums, q) for q in queries]"}
{"prompt": "def removeStars(self, s: str) -> str:\n        stack = []\n        for ch in s: \n            if ch == '*': stack.pop()\n            else: stack.append(ch)\n        return ''.join(stack)"}
{"prompt": "def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\n        ans = sum(map(len, garbage))\n        prefix = list(accumulate(travel, initial=0))\n        for ch in \"MPG\": \n            ii = 0 \n            for i, s in enumerate(garbage): \n                if ch in s: ii = i \n            ans += prefix[ii]\n        return ans"}
{"prompt": "def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\n        \n        def fn(cond): \n            \"\"\"Return topological sort\"\"\"\n            graph = [[] for _ in range(k)]\n            indeg = [0]*k\n            for u, v in cond: \n                graph[u-1].append(v-1)\n                indeg[v-1] += 1\n            queue = deque(u for u, x in enumerate(indeg) if x == 0)\n            ans = []\n            while queue: \n                u = queue.popleft()\n                ans.append(u+1)\n                for v in graph[u]: \n                    indeg[v] -= 1\n                    if indeg[v] == 0: queue.append(v)\n            return ans \n        \n        row = fn(rowConditions)\n        col = fn(colConditions)\n        \n        if len(row) < k or len(col) < k: return []\n        ans = [[0]*k for _ in range(k)]\n        row = {x : i for i, x in enumerate(row)}\n        col = {x : j for j, x in enumerate(col)}\n        for x in range(1, k+1): ans[row[x]][col[x]] = x\n        return ans"}
{"prompt": "def findSubarrays(self, nums: List[int]) -> bool:\n    \"\"\" \n\tBruteforce approch\n\t\"\"\"\n#         for i in range(len(nums)-2):\n#             summ1 = nums[i] + nums[i+1]\n#             # for j in range(i+1,len(nums)):\n#             for j in range(i+1,len(nums)-1):\n#                 summ = nums[j] + nums[j+1]\n#                 if summ == summ1:\n#                     return True\n#         return False\n\t \"\"\"\n\t Sliding Window\n\t \"\"\"\n        one ,two = len(nums)-2,len(nums)-1      // at end of list\n        dic = {}\n        while one >= 0:\n            # print(one,two)\n            summ = nums[one] + nums[two]\n            if summ in dic:\n                return True               // if already there then there is 2 pairs\n            else:\n                dic[summ] = 1        // add summ in of window in dictonary\n            one -=1\n            two -=1\n        return False"}
{"prompt": "def isStrictlyPalindromic(self, n: int) -> bool:\n        def int2base(n,b):\n            r=\"\"\n            while n>0:\n                r+=str(n%b)\n                n//=b           \n            return int(r[-1::-1])\n        for i in range(2,n-1):\n            if int2base(n,i)!=n:\n                return False\n        return True"}
{"prompt": "def maximumRows(self, mat: List[List[int]], cols: int) -> int:\n        n,m = len(mat),len(mat[0])\n        ans = 0\n\n        def check(state,row,rowIncludedCount):\n            nonlocal ans\n            if row==n:\n                if sum(state)<=cols:\n                    ans = max(ans,rowIncludedCount)\n                return\n            \n            check(state[::],row+1,rowIncludedCount)\n            for j in range(m):\n                if mat[row][j]==1:\n                    state[j] = 1\n            check(state,row+1,rowIncludedCount+1)\n        \n        check([0]*m,0,0)\n        return ans"}
{"prompt": "def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:\n        \n        n=len(chargeTimes)\n        start=0\n        runningsum=0\n        max_consecutive=0\n        max_so_far=0\n        secondmax=0\n        \n        for end in range(n):\n            runningsum+=runningCosts[end]\n            \n            if max_so_far<=chargeTimes[end]:\n                secondmax=max_so_far\n                max_so_far=chargeTimes[end]\n                \n            k=end-start+1\n            \n            currentbudget=max_so_far+(k*runningsum)\n            \n            if currentbudget>budget:\n                runningsum-=runningCosts[start]\n                max_so_far=secondmax if chargeTimes[start]==max_so_far else max_so_far\n                start+=1\n\t\t\t\t\n            max_consecutive=max(max_consecutive,end-start+1)\n\t\t\t\n        return max_consecutive"}
{"prompt": "# Pretty much explains itself.\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\n        \n        d = defaultdict(list)\n\n        for i, ch in enumerate(s):\n            d[ch].append(i)\n\n        return all(b-a-1 == distance[ord(ch)-97] for ch, (a,b) in d.items())"}
{"prompt": "# A few points on the problem:\n                         #   • The start and end is a \"red herring.\" The answer to the problem \n                         #     depends only on the distance (dist = end-start) and k.\n                         #  \n                         #   • A little thought will convince one that theres no paths possible \n                         #     if k%2 != dist%2 or if abs(dist) > k.\n\n                         #   • The problem is equivalent to:\n                         #        Determine the count of distinct lists of length k with sum = dist\n                         #        and elements 1 and -1, in which the counts of 1s and -1s in each \n                         #        list differ by dist.\n                         # \n                         #   • The count of the lists is equal to the number of ways  the combination \n                         #     C((k, (dist+k)//2)). For example, if dist = 1 and k = 5. the count of 1s\n\t\t\t\t\t\t #.    is (5+1)//2 = 3, and C(5,3) = 10.\n                         #     (Note that if dist= -1 in this example, (5-1)//2 = 2, and C(5,2) = 10)\n\n    def numberOfWays(self, startPos: int, endPos: int, k: int) -> int:\n\n        dist = endPos-startPos\n\n        if k%2 != dist%2 or abs(dist) > k: return 0\n\n        return comb(k, (dist+k)//2) %1000000007"}
{"prompt": "def longestNiceSubarray(self, nums: List[int]) -> int:\n        maximum_length = 1\n        n = len(nums)\n        \n        current_group = 0\n        left = 0\n        \n        for right in range(n):\n\t\t\t# If the number at the right point is safe to include, include it in the group and update the maximum length.\n            if nums[right] &amp; current_group == 0:\n                current_group |=nums[right]\n                maximum_length = max(maximum_length, right - left + 1)\n                continue\n                \n\t\t\t# Shrink the window until the number at the right pointer is safe to include.\n            while left < right and nums[right] &amp; current_group != 0:    \n                current_group &amp;= (~nums[left]) \n                left += 1\n            \n\t\t\t# Include the number at the right pointer in the group.\n            current_group |= nums[right]\n                \n        return maximum_length"}
{"prompt": "def mostBooked(self, n: int, meetings: List[List[int]]) -> int:\r\n        meetings.sort() # make sure start times are sorted!!\r\n        \r\n        meetingCount = [0 for _ in range(n)]\r\n        availableRooms = list(range(n)); heapify(availableRooms)\r\n        occupiedRooms = []\r\n        \r\n        \r\n        for start, end in meetings:\r\n            while occupiedRooms and start >= occupiedRooms[0][0]:\r\n                heappush(availableRooms, heappop(occupiedRooms)[1]) # frees room and makes it available\r\n            \r\n            if availableRooms:\r\n                roomNumber = heappop(availableRooms)  # assigns next available room\r\n            else:\r\n                freedEnd, roomNumber = heappop(occupiedRooms)  # waits until the next room that would be available gets free\r\n                end += freedEnd - start\r\n            heappush(occupiedRooms, (end,roomNumber))  # make note that the ruom is occupied and when the assigned meeting ends\r\n            meetingCount[roomNumber] += 1  # update meeting counter\r\n            \r\n        return sorted([(count, i) for i, count in enumerate(meetingCount)], key = lambda x: (-x[0], x[1]))[0][1]  # find room with most meetings"}
{"prompt": "def mostFrequentEven(self, nums: List[int]) -> int:\n        ctr = Counter(nums)\n        return max([c for c in ctr if not c%2], key = lambda x:(ctr[x], -x), default = -1)"}
{"prompt": "def partitionString(self, s: str) -> int:\n        cur = set()\n        res = 1\n        \n        for c in s:\n            if c in cur:\n                cur = set()\n                res += 1\n            cur.add(c)\n                \n        return res"}
{"prompt": "def minGroups(self, intervals: List[List[int]]) -> int:\n        pq = []\n        for left, right in sorted(intervals):\n            if pq and pq[0] < left:\n                heappop(pq)\n            heappush(pq, right)\n        return len(pq)"}
{"prompt": "def getmax(self, st, start, end):\n        maxi = 0\n        \n        while start < end:\n            if start%2:#odd\n                maxi = max(maxi, st[start])\n                start += 1\n            if end%2:#odd\n                end -= 1\n                maxi = max(maxi, st[end])\n            start //= 2\n            end //= 2\n        return maxi\n        \n    def update(self, st, maxi, n):\n        st[n] = maxi\n        while n > 1:\n            n //= 2\n            st[n] = max(st[2*n], st[2*n+1])\n    \n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\n        ans = 1\n        length = max(nums)\n        st = [0]*length*2\n        for n in nums:\n            n -= 1\n            maxi = self.getmax(st, max(0, n-k)+length, n+length) + 1\n            self.update(st, maxi, n+length)\n            ans = max(maxi, ans)\n        return ans"}
{"prompt": "def countDaysTogether(self, arAl: str, lAl: str, arBo: str, lBo: str) -> int:\n        months = [-1, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n        start = max(arAl, arBo)\n        end = min(lAl, lBo)\n\n        startDay = int(start[3:])\n        startMonth = int(start[:2])\n        endDay = int(end[3:])\n        endMonth = int(end[:2])\n        \n        if start > end:\n            return 0\n        if startMonth == endMonth:\n            return endDay-startDay+1\n        elif startMonth < endMonth:\n            return months[startMonth]-startDay + endDay + 1 + sum(months[m] for m in range(startMonth+1, endMonth))"}
{"prompt": "def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\n        n = len(players)\n        m = len(trainers)\n        players.sort()\n        trainers.sort()\n        dp = {}\n        def helper(i,j):\n            if i==n or j==m:\n                return 0\n            if (i,j) in dp:\n                return dp[(i,j)]\n            if players[i]<=trainers[j]:\n                dp[(i,j)] = 1+helper(i+1,j+1)\n            else:\n                dp[(i,j)] = helper(i,j+1)\n            return dp[(i,j)]\n        return helper(0,0)"}
{"prompt": "def smallestSubarrays(self, nums: List[int]) -> List[int]:\n\n        def create(m):\n            t = 0\n            for n in m:\n                if m[n] > 0:\n                    t = t | (1 << n)\n            return t\n        \n        def add(a,m):\n            ans = bin( a )\n            s = str(ans)[2:]\n            for i, b in enumerate( s[::-1]):\n                if b == '1':\n                    m[i] += 1\n\n        def remove(a,m):\n            ans = bin( a )\n            s = str(ans)[2:]\n            for i, b in enumerate( s[::-1]):\n                if b == '1':\n                    m[i] -= 1\n        \n        res = []\n\n        \n        n = defaultdict(int)\n        for i in nums:\n            add(i,n)\n\n        \n        m = defaultdict(int)\n        r = 0\n        c = 0\n\n        for i,v in enumerate(nums):\n            # The last check is for if nums[i] == 0, in that case we still want to add to the map\n            while r < len(nums) and (create(m) != create(n) or (c==0 and nums[i] ==0)):\n                add(nums[r],m)\n                r+=1\n                c+=1\n\n            res.append(c)\n\n            remove(nums[i],m)\n            remove(nums[i],n)\n            c-=1\n\n        return res"}
{"prompt": "def minimumMoney(self, transactions: List[List[int]]) -> int:\n        ans = val = 0 \n        for cost, cashback in transactions: \n            ans += max(0, cost - cashback)\n            val = max(val, min(cost, cashback))\n        return ans + val"}
{"prompt": "def smallestEvenMultiple(self, n: int) -> int:\n\t\t# it's just asking for LCM of 2 and n\n        return lcm(2, n)"}
{"prompt": "def longestContinuousSubstring(self, s: str) -> int:\n\n        arr = ''.join(['1' if ord(s[i])-ord(s[i-1]) == 1 \n                       else ' ' for i in range(1,len(s))]).split()\n                       \n        return max((len(ones)+1 for ones in arr), default = 1)"}
{"prompt": "def reverseOddLevels(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        def dfs(n1, n2, level):\n            if not n1:\n                return\n            \n            if level % 2:\n                n1.val, n2.val = n2.val, n1.val\n                \n            dfs(n1.left,  n2.right, level + 1)\n            dfs(n1.right, n2.left,  level + 1)\n            \n        dfs(root.left, root.right, 1)       \n        return root"}
{"prompt": "def sumPrefixScores(self, words: List[str]) -> List[int]:\n\n\t\td = defaultdict(int)\n\n\t\tfor word in words:\n\t\t\tfor index in range(1, len(word) + 1):\n\t\t\t\td[word[:index]] += 1 \n\n\t\tresult = []\n\n\t\tfor word in words:\n\t\t\tcurrent_sum = 0\n\n\t\t\tfor index in range(1, len(word) + 1):\n\t\t\t\tcurrent_sum = current_sum + d[word[:index]]\n\n\t\t\tresult.append(current_sum)\n\n\t\treturn result"}
{"prompt": "# Ex: names = [\"Larry\",\"Curly\",\"Moe\"]   heights = [130,125,155] \n\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\n\n        _,names = zip(*sorted(zip(heights,names), reverse = True))   \n                                  # zipped   --> [(130,\"Larry\"), (125,\"Curly\"), (155,\"Moe\")  ]\n                                  # sorted   --> [(155,\"Moe\"  ), (130,\"Larry\"), (125,\"Curly\")]\n                                  # unzipped --> _ = (155,130,125) , names = (\"Moe\",\"Larry\",\"Curly\")\n        \n\t\treturn  list(names)       # list(names) = [\"Moe\",\"Larry\",\"Curly\"]"}
{"prompt": "def longestSubarray(self, nums: List[int]) -> int:\n        max_n = max(nums)\n        return max(len(list(it)) for n, it in groupby(nums) if n == max_n)"}
{"prompt": "def goodIndices(self, nums: List[int], k: int) -> List[int]:\n        ### forward pass.\n        forward = [False]*len(nums) ### For the forward pass, store if index i is good or not.\n        stack = []\n        for i in range(len(nums)):\n        \t### if the leangth of stack is greater or equal to k, it means this index is good.\n            if len(stack)>=k:\n                forward[i] = True\n            ### if the stack is empty, just add the current number to it.\n            if not stack:\n                stack.append(nums[i])\n            ### check to see if the current number is smaller or equal to the last number in stack, if it is not, put this number into the stack.\n            else:\n                if nums[i]<=stack[-1]:\n                    stack.append(nums[i])\n                else:\n                    stack = [nums[i]]\n        ### backward pass\n        res = []\n        stack = []\n        for i in reversed(range(len(nums))):\n        \t### Check to see if the length of stack is greater or equal to k and also check if the forward pass at this index is Ture.\n            if len(stack)>=k and forward[i]:\n                res.append(i)\n            if not stack:\n                stack.append(nums[i])\n            else:\n                if nums[i]<=stack[-1]:\n                    stack.append(nums[i])\n                else:\n                    stack = [nums[i]]\n        return res[::-1]"}
{"prompt": "def numberOfGoodPaths(self, vals: List[int], edges: List[List[int]]) -> int:\n        n = len(vals)\n        \n        g = defaultdict(list)\n        \n        # start from node with minimum val\n        for a, b in edges:\n            heappush(g[a], (vals[b], b))\n            heappush(g[b], (vals[a], a))\n\n        \n        loc = list(range(n))\n        \n        def find(x):\n            if loc[x] != x:\n                loc[x] = find(loc[x])\n            return loc[x]\n        \n        def union(x, y):\n            a, b = find(x), find(y)\n            if a != b:\n                loc[b] = a\n        \n        # node by val\n        v = defaultdict(list)\n        for i, val in enumerate(vals):\n            v[val].append(i)\n        \n        ans = n\n        \n        \n        for k in sorted(v):\n            for node in v[k]:\n                # build graph if neighboring node <= current node val\n                while g[node] and g[node][0][0] <= k:\n                    nei_v, nei = heappop(g[node])\n                    union(node, nei)\n            \n            # Count unioned groups\n            grp = Counter([find(x) for x in v[k]])\n            \n            # for each unioned group, select two nodes (order doesn't matter)\n            ans += sum(math.comb(x, 2) for x in grp.values())            \n        \n        return ans"}
{"prompt": "def equalFrequency(self, word: str) -> bool:\n        cnt = Counter(Counter(word).values())\n        if (len(cnt) == 1):\n            return list(cnt.keys())[0] == 1 or list(cnt.values())[0] == 1\n        if (len(cnt) == 2):\n            f1, f2 = min(cnt.keys()), max(cnt.keys())\n            return (f1 + 1 == f2 and cnt[f2] == 1) or (f1 == 1 and cnt[f1] == 1)\n        return False"}
{"prompt": "def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:\n        m, n = map(len, (nums1, nums2))\n        return (m % 2 * reduce(xor, nums2)) ^ (n % 2 * reduce(xor, nums1))"}
{"prompt": "def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:\n        n=len(nums1)\n        for i in range(n):\n            nums1[i]=nums1[i]-nums2[i]\n        ans=0\n        arr=[]\n        for i in range(n):\n            x=bisect_right(arr,nums1[i]+diff)\n            ans+=x\n            insort(arr,nums1[i])\n        return ans"}
{"prompt": "def commonFactors(self, a: int, b: int) -> int:\n        c=0\n        mi=min(a,b)\n        for i in range(1,mi+1):\n            if a%i==0 and b%i==0:\n                c+=1\n        return c"}
{"prompt": "def maxSum(self, grid: List[List[int]]) -> int:\n        res=0\n        cur=0\n        \n        for i in range(len(grid)-2):\n            for j in range(1,len(grid[0])-1):\n               \n                cur=sum(grid[i][j-1:j+2]) +grid[i+1][j] + sum(grid[i+2][j-1:j+2])\n                res = max(res,cur)\n                                                     \n        return res"}
{"prompt": "def minimizeXor(self, num1: int, num2: int) -> int:       \n        nbit1 = 0\n        while num2>0:\n            nbit1 = nbit1 + (num2&amp;1)\n            num2 = num2 >> 1\n        # print(nbit1)\n        \n        chk = []\n        ans = 0\n        # print(bin(num1), bin(ans))\n        for i in range(31, -1, -1):\n            biti = (num1>>i)&amp;1\n            if biti==1 and nbit1>0:\n                num1 = num1 &amp; ~(1<<i)\n                ans = ans | (1<<i)\n                chk.append(i)\n                nbit1 -= 1\n        # print(bin(num1), bin(ans))\n        \n        if nbit1>0:\n            for i in range(0, 32, 1):\n                biti = (num1>>i)&amp;1\n                if i not in chk and nbit1>0:\n                    num1 = num1 | (1<<i)\n                    ans = ans | (1<<i)\n                    nbit1 -= 1\n        # print(bin(num1), bin(ans))\n        # print(\"=\" * 20)\n        \n        return ans"}
{"prompt": "def deleteString(self, s: str) -> int:\n        n = len(s)\n        if len(set(s)) == 1:\n            return n\n        dp = [1] * n\n        for i in range(n - 2, -1, -1):\n            for l in range(1, (n - i) // 2 + 1):\n                if s[i : i + l] == s[i + l : i + 2 * l]:\n                    dp[i] = max(dp[i], 1 + dp[i + l])\n        return dp[0]"}
{"prompt": "\"\"\"\n    Time:   O(n)\n    Memory: O(1)\n    \"\"\"\n\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\n        best_id = best_time = start = 0\n\n        for emp_id, end in logs:\n            time = end - start\n            if time > best_time or (time == best_time and best_id > emp_id):\n                best_id = emp_id\n                best_time = time\n            start = end\n\n        return best_id"}
{"prompt": "def findArray(self, pref: List[int]) -> List[int]:\n        ans = [0 for i in range(len(pref))]\n        ans[0] = pref[0]\n        for i in range(1, len(pref)):\n            ans[i] = pref[i-1]^pref[i]\n        return ans"}
{"prompt": "def robotWithString(self, s: str) -> str:\n        cnt, lo, p, t = Counter(s), 'a', [], []\n        for ch in s:\n            t += ch\n            cnt[ch] -= 1\n            while lo < 'z' and cnt[lo] == 0:\n                lo = chr(ord(lo) + 1)\n            while t and t[-1] <= lo:\n                p += t.pop()\n        return \"\".join(p)"}
{"prompt": "def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\n        dp = [[[0 for i in range(k)] for _ in range(len(grid[0]))] for _ in range(len(grid))]\n        rem = grid[0][0] % k\n        dp[0][0][rem] = 1\n        for i in range(1, len(grid[0])):\n            dp[0][i][(rem + grid[0][i]) % k] = 1\n            rem = (rem + grid[0][i]) % k\n        rem = grid[0][0] % k\n        for j in range(1, len(grid)):\n            dp[j][0][(rem + grid[j][0]) % k] = 1\n            rem = (rem + grid[j][0]) % k\n        for i in range(1, len(grid)):\n            for j in range(1, len(grid[0])):\n                for rem in range(k):\n                    dp[i][j][(rem + grid[i][j]) % k] = dp[i - 1][j][rem] + dp[i][j - 1][rem]\n        return dp[-1][-1][0] % (10**9 + 7)"}
{"prompt": "def countTime(self, t: str) -> int:\n        mm = (6 if t[3] == '?' else 1) * (10 if t[4] == '?' else 1)\n        match [t[0], t[1]]:\n            case ('?', '?'):\n                return mm * 24\n            case ('?', ('0' | '1' | '2' | '3')):\n                return mm * 3\n            case ('?', _):\n                return mm * 2\n            case (('0' | '1'), '?'):\n                return mm * 10\n            case (_, '?'):\n                return mm * 4\n        return mm"}
{"prompt": "def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        MOD = (10**9)+7\n        binary = bin(n)[2:]\n        powers = []\n        result = []\n        for index, val in enumerate(binary[::-1]):\n            if val == \"1\":\n                powers.append(2**index)\n                \n        for index in range(1, len(powers)):\n            powers[index] = powers[index] * powers[index - 1]    \n        \n        for l,r in queries:\n            if l == 0:\n                result.append(powers[r]%MOD)\n            else:\n                result.append((powers[r]//powers[l-1])%MOD)\n                \n        return result"}
{"prompt": "def minimizeArrayValue(self, nums: List[int]) -> int:\n        return max(ceil(n / (i + 1)) for i, n in enumerate(accumulate(nums)))"}
{"prompt": "def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        tree = [[] for _ in nums]\n        for u, v in edges: \n            tree[u].append(v)\n            tree[v].append(u)\n        \n        def fn(u, p):\n            \"\"\"Post-order dfs.\"\"\"\n            ans = nums[u]\n            for v in tree[u]: \n                if v != p: ans += fn(v, u)\n            return 0 if ans == cand else ans\n        \n        total = sum(nums)\n        for cand in range(1, total//2+1): \n            if total % cand == 0 and fn(0, -1) == 0: return total//cand-1\n        return 0"}
{"prompt": "def findMaxK(self, nums: List[int]) -> int:\n        nums.sort()\n        for i in nums[::-1]:\n            if -i in nums:\n                return i\n        return -1"}
{"prompt": "def countDistinctIntegers(self, nums: List[int]) -> int:\n        return len(set([int(str(i)[::-1]) for i in nums] + nums))"}
{"prompt": "def sumOfNumberAndReverse(self, num: int) -> bool:\n        digits = []\n        while num > 0:\n            digits.append(num % 10)\n            num = num // 10\n\n        digits.reverse()\n        hi, lo = 0, len(digits) - 1\n        while hi <= lo:\n            if hi == lo:\n                if digits[hi] % 2 == 0:\n                    break\n                else:\n                    return False\n            if digits[hi] == digits[lo]:\n                hi += 1\n                lo -= 1\n            elif digits[hi] == 1 and digits[hi] != digits[lo]:\n                digits[hi] -= 1\n                digits[hi+1] += 10\n                hi += 1\n                if lo != hi:\n                    digits[lo] += 10\n                    digits[lo-1] -= 1\n                    cur = lo - 1\n                    while digits[cur] < 0:\n                        digits[cur] = 0\n                        digits[cur-1] -= 1\n                        cur -= 1\n                \n            elif digits[hi]-1 == digits[lo] and hi + 1 < lo:\n                    digits[hi]-= 1\n                    digits[hi+1] += 10\n                    hi += 1\n                    lo -= 1\n                # else:\n                #     return False\n            elif digits[hi] - 1 == digits[lo] + 10 and hi + 1 < lo:\n                digits[hi] -= 1\n                digits[hi+1] += 10\n                digits[lo-1] -= 1\n                cur = lo - 1\n                while digits[cur] < 0:\n                    digits[cur] = 0\n                    digits[cur-1] -= 1\n                    cur -= 1     \n                digits[lo] += 10\n            elif hi-1>=0 and lo+1<=len(digits)-1 and digits[hi-1] == 1 and digits[lo+1] == 1:\n                digits[hi-1] -= 1\n                digits[hi] += 10\n                digits[lo+1] += 10\n                digits[lo] -= 1\n                cur = lo\n                while digits[cur] < 0:\n                    digits[cur] = 0\n                    digits[cur-1] -= 1\n                    cur -= 1\n                lo += 1\n            else:\n                return False\n        return True"}
{"prompt": "def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\n        if minK > maxK: return 0\n        \n        def count(l, r):\n            if l + 1 == r: return 0\n            dic = Counter([nums[l]])\n            ans, j = 0, l + 1\n            for i in range(l + 1, r):\n                dic[nums[i - 1]] -= 1\n                while not dic[minK] * dic[maxK] and j < r:\n                    dic[nums[j]] += 1\n                    j += 1\n                if dic[minK] * dic[maxK]: ans += r - j + 1\n                else: break\n            return ans\n        \n        arr = [-1] + [i for i, num in enumerate(nums) if num < minK or num > maxK] + [len(nums)]\n        return sum(count(arr[i - 1], arr[i]) for i in range(1, len(arr)))"}
{"prompt": "\"\"\"\n    Time:   O(1)\n    Memory: O(1)\n    \"\"\"\n\n    def haveConflict(self, a: List[str], b: List[str]) -> bool:\n        a_start, a_end = a\n        b_start, b_end = b\n        return b_start <= a_start <= b_end or \\\n               b_start <= a_end <= b_end or \\\n               a_start <= b_start <= a_end or \\\n               a_start <= b_end <= a_end"}
{"prompt": "def subarrayGCD(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        ans = 0\n        for i in range(n):\n            temp = nums[i]\n            for j in range(i, n):\n                temp = math.gcd(temp, nums[j])\n                if temp == k:\n                    ans += 1\n                elif temp < k:\n                    break\n        return ans"}
{"prompt": "def minCost(self, nums: List[int], cost: List[int]) -> int:\n        arr = sorted(zip(nums, cost))\n        total, cnt = sum(cost), 0\n        for num, c in arr:\n            cnt += c\n            if cnt > total // 2:\n                target = num\n                break\n        return sum(c * abs(num - target) for num, c in arr)"}
{"prompt": "def makeSimilar(self, A: List[int], B: List[int]) -> int:\n        if sum(A)!=sum(B): return 0\n        # The first intuition is that only odd numbers can be chaged to odd numbers and even to even hence separate them\n        # Now minimum steps to making the target to highest number in B is by converting max of A to max of B similarily\n        # every number in A can be paired with a number in B by index hence sorting\n        # now we need only the number of positives or number of negatives.\n        oddA,evenA=[i for i in A if i%2],[i for i in A if i%2==0]\n        oddB,evenB=[i for i in B if i%2],[i for i in B if i%2==0]        \n        oddA.sort(),evenA.sort()\n        oddB.sort(),evenB.sort()\n        res=0\n        for i,j in zip(oddA,oddB):\n            if i>=j: res+=i-j\n        \n        for i,j in zip(evenA,evenB):\n            if i>=j: res+=i-j\n        \n        return res//2"}
{"prompt": "def oddString(self, words: List[str]) -> str:\n        k=len(words[0])\n        arr=[]\n        for i in words:\n            l=[]\n            for j in range(1,k):\n                diff=ord(i[j])-ord(i[j-1])\n                l.append(diff)\n            arr.append(l)\n        for i in range(len(arr)):\n            if arr.count(arr[i])==1:\n                return words[i]"}
{"prompt": "def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\n        # T: ((N + M) * L^3), S: O(M * L^3)\n        N, M, L = len(queries), len(dictionary), len(queries[0])\n        validWords = set()\n        \n        for word in dictionary:\n            for w in self.wordModifications(word):\n                validWords.add(w)\n        \n        ans = []\n        for word in queries:\n            for w in self.wordModifications(word):\n                if w in validWords:\n                    ans.append(word)\n                    break\n\n        return ans\n    \n    def wordModifications(self, word):\n        # T: O(L^3)\n        L = len(word)\n        for i in range(L):\n            yield word[:i] + \"*\" + word[i+1:]\n\n        for i, j in itertools.combinations(range(L), 2):\n            yield word[:i] + \"*\" + word[i+1:j] + \"*\" + word[j+1:]"}
{"prompt": "def destroyTargets(self, nums: List[int], space: int) -> int:\n\t\t# example:  nums = [3,7,8,1,1,5], space = 2\n        groups = defaultdict(list)\n        for num in nums:\n            groups[num % space].append(num)\n        \n        # print(groups) # defaultdict(<class 'list'>, {1: [3, 7, 1, 1, 5], 0: [8]}) groups is [3, 7, 1, 1, 5] and [8] \n        \"\"\" min of [3, 7, 1, 1, 5] can destroy all others (greedy approach) => 1 can destory 1,3,5,7 ... \"\"\"\n        performance = defaultdict(list)\n        for group in groups.values():\n            performance[len(group)].append(min(group))\n        \n        # print(performance) # defaultdict(<class 'list'>, {5: [1], 1: [8]})\n\t\t# nums that can destory 5 targets are [1], nums that can destory 1 target are [8] \n        return min(performance[max(performance)])"}
{"prompt": "def secondGreaterElement(self, nums: List[int]) -> List[int]:\n        ans = [-1] * len(nums)\n        s, ss = [], []\n        for i, x in enumerate(nums): \n            while ss and nums[ss[-1]] < x: ans[ss.pop()] = x\n            buff = []\n            while s and nums[s[-1]] < x: buff.append(s.pop())\n            while buff: ss.append(buff.pop())\n            s.append(i)\n        return ans"}
{"prompt": "def averageValue(self, nums: List[int]) -> int:\n        l=[]\n        for i in nums:\n            if i%6==0:\n                l.append(i)\n        return sum(l)//len(l) if len(l)>0 else 0"}
{"prompt": "def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\n        memo = {}\n\t\t#tracking the max popular video count\n        overall_max_popular_video_count = -1\n        #looping over the creators\n        for i in range(len(creators)):\n            if creators[i] in memo:\n                #Step 1: update number of views for the creator\n                memo[creators[i]][0] += views[i]\n                #Step 2: update current_popular_video_view and id_of_most_popular_video_so_far\n                if memo[creators[i]][2] < views[i]:\n                    memo[creators[i]][1] = ids[i]\n                    memo[creators[i]][2] = views[i]\n                #Step 2a: finding the lexicographically smallest id as we hit the current_popularity_video_view again!\n                elif memo[creators[i]][2] == views[i]:\n                    memo[creators[i]][1] = min(memo[creators[i]][1],ids[i])\n            else:\n\t\t\t#adding new entry to our memo\n\t\t\t#new entry is of the format memo[creator[i]] = [total number current views for the creator, store the lexicographic id of the popular video, current popular view of the creator]\n                memo[creators[i]] = [views[i],ids[i],views[i]]\n\t\t\t#track the max popular video count\n            overall_max_popular_video_count = max(memo[creators[i]][0],overall_max_popular_video_count)\n        \n        result = []\n        for i in memo:\n            if memo[i][0] == overall_max_popular_video_count:\n                result.append([i,memo[i][1]])\n        return result"}
{"prompt": "def makeIntegerBeautiful(self, n: int, target: int) -> int:\n        i=n\n        l=1\n        while i<=10**12:\n            s=0\n            for j in str(i):\n                s+=int(j)\n            if s<=target:\n                return i-n\n            i//=10**l\n            i+=1\n            i*=10**l\n            l+=1"}
{"prompt": "def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\n        depth = {}\n        height = {}\n        nodes_at_depth = {}\n\n        max_height = 0\n\n        def rec(n, d):\n            nonlocal max_height\n            if n is None:\n                return 0\n            height_below = max(rec(n.left, d+1), rec(n.right, d+1))\n            v = n.val\n            depth[v] = d\n            h = d + 1 + height_below\n            height[v] = h\n            max_height = max(max_height, h)\n\n            if d not in nodes_at_depth:\n                nodes_at_depth[d] = [v]\n            else:\n                nodes_at_depth[d].append(v)\n\n            return 1 + height_below\n\n\n        rec(root, -1)  # subtract one because the problem reports heights weird\n        ret = []\n\n\n        for q in queries:\n            if height[q] >= max_height:\n                d = depth[q]\n                for cousin in nodes_at_depth[depth[q]]:\n                    if cousin != q:  # don't count self, obviously\n                        d = max(d, height[cousin])\n                ret.append(d)  \n            else:\n                ret.append(max_height)\n        \n        return ret"}
{"prompt": "def applyOperations(self, nums: List[int]) -> List[int]:\n        for i in range(len(nums)-1):\n            if nums[i]==nums[i+1]:\n                nums[i]*=2\n                nums[i+1]=0                \n        temp = []\n        zeros = []\n        a=nums\n        for i in range(len(a)):\n            if a[i] !=0:\n                temp.append(a[i])\n            else:\n                zeros.append(a[i])\n        return (temp+zeros)"}
{"prompt": "def maximumSubarraySum(self, nums: List[int], k: int) -> int:\n        \n        seen = collections.Counter(nums[:k]) #from collections import Counter (elements and their respective count are stored as a dictionary)\n        summ = sum(nums[:k])\n        \n        \n        res = 0\n        if len(seen) == k:\n            res = summ\n            \n            \n        for i in range(k, len(nums)):\n            summ += nums[i] - nums[i-k]\n            seen[nums[i]] += 1\n            seen[nums[i-k]] -= 1\n            \n            if seen[nums[i-k]] == 0:\n                del seen[nums[i-k]]\n                \n            if len(seen) == k:\n                res = max(res, summ) \n                \n        return res"}
{"prompt": "def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\n        q = costs[:candidates]\n        qq = costs[max(candidates, len(costs)-candidates):]\n        heapify(q)\n        heapify(qq)\n        ans = 0 \n        i, ii = candidates, len(costs)-candidates-1\n        for _ in range(k): \n            if not qq or q and q[0] <= qq[0]: \n                ans += heappop(q)\n                if i <= ii: \n                    heappush(q, costs[i])\n                    i += 1\n            else: \n                ans += heappop(qq)\n                if i <= ii: \n                    heappush(qq, costs[ii])\n                    ii -= 1\n        return ans"}
{"prompt": "def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:\n        robot.sort()\n        factory.sort()\n        m, n = len(robot), len(factory)\n        dp = [[0]*(n+1) for _ in range(m+1)] \n        for i in range(m): dp[i][-1] = inf \n        for j in range(n-1, -1, -1): \n            prefix = 0 \n            qq = deque([(m, 0)])\n            for i in range(m-1, -1, -1): \n                prefix += abs(robot[i] - factory[j][0])\n                if qq[0][0] > i+factory[j][1]: qq.popleft()\n                while qq and qq[-1][1] >= dp[i][j+1] - prefix: qq.pop()\n                qq.append((i, dp[i][j+1] - prefix))\n                dp[i][j] = qq[0][1] + prefix\n        return dp[0][0]"}
{"prompt": "def distinctAverages(self, nums: List[int]) -> int:\n        av=[]\n        nums.sort()\n        while nums:\n            av.append((nums[-1]+nums[0])/2)\n            nums.pop(-1)\n            nums.pop(0)\n        return len(set(av))"}
{"prompt": "def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\n        def recursive(s,ans):\n            if len(s)>=low and len(s)<=high:\n                ans+=[s]\n            if len(s)>high:\n                return \n            recursive(s+\"0\"*zero,ans)\n            recursive(s+\"1\"*one,ans)\n            return\n        ans=[]\n        recursive(\"\",ans)\n        return len(ans)"}
{"prompt": "def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\n        path_b = set([bob])\n        lvl_b = {bob:0}\n        g = defaultdict(list)\n        for u, v in edges:\n            g[u].append(v)\n            g[v].append(u)\n        n = len(amount)\n        node_lvl = [0] * n\n        q = deque([0])\n        \n        lvl = 0\n        seen = set([0])\n        while q:\n            size = len(q)\n            for _ in range(size):\n                u = q.popleft()\n                node_lvl[u] = lvl\n                for v in g[u]:\n                    if v in seen:\n                        continue\n                    q.append(v)\n                    seen.add(v)\n            lvl += 1\n        b = bob\n        lvl = 1\n        while b != 0:\n            for v in g[b]:\n                if node_lvl[v] > node_lvl[b]:\n                    continue\n                b = v\n                cost = amount[b]\n                path_b.add(b)\n                lvl_b[b] = lvl\n                break\n            lvl += 1\n        # print(f\"lvl_b {lvl_b} path_b {path_b}  \")\n        cost_a = []\n        q = deque([(0, amount[0])])\n        seen = set([0])\n        lvl = 1\n        while q:\n            size = len(q)\n            for _ in range(size):\n                u, pre_cost = q.popleft()\n                child_cnt = 0\n                for v in g[u]:\n                    if v in seen:\n                        continue\n                    seen.add(v)\n                    child_cnt += 1\n                    cost = pre_cost\n                    inc = amount[v]\n                    if v in path_b:\n                        if lvl_b[v] == lvl:\n                            cost += inc//2\n                        elif lvl_b[v] > lvl:\n                            cost += inc\n                        else:\n                            cost += 0\n                    else:\n                        cost += amount[v]\n                    q.append((v, cost))\n                if child_cnt == 0:\n                    cost_a.append(pre_cost)\n            lvl += 1\n        ans = max(cost_a)\n        return ans"}
{"prompt": "def splitMessage(self, message: str, limit: int) -> List[str]:\n        def splitable_within(parts_limit):\n            # check the message length achievable with <parts_limit> parts\n            length = sum(limit - len(str(i)) - len(str(parts_limit)) - 3 for i in range(1, parts_limit + 1))\n            return length >= len(message)\n        \n        parts_limit = 9\n        if not splitable_within(parts_limit):\n            parts_limit = 99\n        if not splitable_within(parts_limit):\n            parts_limit = 999\n        if not splitable_within(parts_limit):\n            parts_limit = 9999\n        if not splitable_within(parts_limit):\n            return []\n        \n        # generate the actual message parts\n        parts = []\n        m_index = 0  # message index\n        for part_index in range(1, parts_limit + 1):\n            if m_index >= len(message): break\n            length = limit - len(str(part_index)) - len(str(parts_limit)) - 3\n            parts.append(message[m_index:m_index + length])\n            m_index += length\n        \n        return [f'{part}<{i + 1}/{len(parts)}>' for i, part in enumerate(parts)]"}
{"prompt": "def convertTemperature(self, celsius: float) -> List[float]:\n        return [(celsius + 273.15),(celsius * 1.80 + 32.00)]"}
{"prompt": "def subarrayLCM(self, nums: List[int], k: int) -> int:\n        def find_lcm(num1, num2):\n            if(num1>num2):\n                num = num1\n                den = num2\n            else:\n                num = num2\n                den = num1\n            rem = num % den\n            while(rem != 0):\n                num = den\n                den = rem\n                rem = num % den\n            gcd = den\n            lcm = int(int(num1 * num2)/int(gcd))\n            return lcm\n        count=0\n        for i in range(len(nums)):\n            lcm=1\n            for j in range(i,len(nums)):\n                lcm=find_lcm(nums[j],lcm)\n                \n                if lcm==k:\n                    count+=1\n                if lcm>k:\n                    break\n        return count"}
{"prompt": "def minimumOperations(self, root: Optional[TreeNode]) -> int:\n        ans = 0 \n        queue = deque([root])\n        while queue: \n            vals = []\n            for _ in range(len(queue)): \n                node = queue.popleft()\n                vals.append(node.val)\n                if node.left: queue.append(node.left)\n                if node.right: queue.append(node.right)\n            mp = {x : i for i, x in enumerate(sorted(vals))}\n            visited = [0]*len(vals)\n            for i in range(len(vals)): \n                cnt = 0 \n                while not visited[i] and i != mp[vals[i]]: \n                    visited[i] = 1\n                    cnt += 1\n                    i = mp[vals[i]]\n                ans += max(0, cnt-1)\n        return ans"}
{"prompt": "def maxPalindromes(self, s: str, k: int) -> int:\n        n = len(s)\n        dp = [0] * (n + 1)\n        for i in range(k, n + 1):\n            dp[i] = dp[i - 1]\n            for length in range(k, k + 2):\n                j = i - length\n                if j < 0:\n                    break\n                if self.isPalindrome(s, j, i):\n                    dp[i] = max(dp[i], 1 + dp[j])\n        return dp[-1]\n    \n    \n    def isPalindrome(self, s, j, i):\n        left, right = j, i - 1\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n        return True"}
{"prompt": "def unequalTriplets(self, nums: List[int]) -> int:\n        c = Counter(nums)\n        res = 0\n        \n        left = 0\n        right = len(nums)\n        \n        for _, freq in c.items():\n            right -= freq\n            res += left * freq * right\n            left += freq\n        \n        return res"}
{"prompt": "def closestNodes(self, root, queries):\n        def dfs(root, arr):\n            if not root: return\n            dfs(root.left, arr)\n            arr.append(root.val)\n            dfs(root.right, arr)\n        arr = []\n        dfs(root, arr)\n        ans = []\n        n = len(arr)\n        for key in queries:\n            left, right = 0, n - 1\n            while right >= left:\n                mid = (right + left) // 2\n                if arr[mid] == key:\n                    break\n                elif arr[mid] > key:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            if arr[mid] == key:\n                ans.append([arr[mid], arr[mid]])\n            elif arr[mid] > key:\n                if (mid - 1) >= 0:\n                    ans.append([arr[mid - 1], arr[mid]])\n                else:\n                    ans.append([-1, arr[mid]])\n            else:\n                if (mid + 1) < n:\n                    ans.append([arr[mid], arr[mid + 1]])\n                else:\n                    ans.append([arr[mid], -1])\n        return ans"}
{"prompt": "def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\n        n = len(roads) + 1\n        graph = defaultdict(list)\n        for a, b in roads:\n            graph[a].append(b)\n            graph[b].append(a)\n        \n        def dfs(u, p):\n            cnt = 1\n            for v in graph[u]:\n                if v == p: continue\n                cnt += dfs(v, u)\n            if u != 0:\n                self.ans += math.ceil(cnt / seats)  # number of litters for `cnt` people to travel from node `u` to node `p`\n            return cnt\n                \n        self.ans = 0\n        dfs(0, -1)\n        return self.ans"}
{"prompt": "def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\n        n = len(s)\n        MOD = 10**9 + 7\n\n        def isPrime(c):\n            return c in ['2', '3', '5', '7']\n\n        @lru_cache(None)\n        def dp(i, k):\n            if k == 0 and i <= n:\n                return 1\n            if i >= n:\n                return 0\n\n            ans = dp(i+1, k)  # Skip\n            if isPrime(s[i]) and not isPrime(s[i-1]):  # Split\n                ans += dp(i+minLength, k-1)\n            return ans % MOD\n\n        if not isPrime(s[0]) or isPrime(s[-1]): return 0\n\n        return dp(minLength, k-1)"}
